---
title: ASP.NET Core 中的分部视图
author: ardalis
description: 了解分部视图是如何呈现在另一视图中，以及何时应在 ASP.NET Core 应用中使用它们。
manager: wpickett
ms.author: riande
ms.date: 03/14/2018
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/views/partial
ms.openlocfilehash: 3deaaeb666e5443d0784f2ac6977e58e1b25d711
ms.sourcegitcommit: 71b93b42cbce8a9b1a12c4d88391e75a4dfb6162
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/20/2018
---
# <a name="partial-views-in-aspnet-core"></a><span data-ttu-id="7f055-103">ASP.NET Core 中的分部视图</span><span class="sxs-lookup"><span data-stu-id="7f055-103">Partial Views in ASP.NET Core</span></span>

<span data-ttu-id="7f055-104">作者：[Steve Smith](https://ardalis.com/)、[Maher JENDOUBI](https://twitter.com/maherjend)、[Rick Anderson](https://twitter.com/RickAndMSFT) 和 [Scott Sauber](https://twitter.com/scottsauber)</span><span class="sxs-lookup"><span data-stu-id="7f055-104">By [Steve Smith](https://ardalis.com/), [Maher JENDOUBI](https://twitter.com/maherjend), [Rick Anderson](https://twitter.com/RickAndMSFT), and [Scott Sauber](https://twitter.com/scottsauber)</span></span>

<span data-ttu-id="7f055-105">ASP.NET Core MVC 支持分部视图，如果拥有想要在不同视图之间共享的网页的可重用部分，分部视图十分有用。</span><span class="sxs-lookup"><span data-stu-id="7f055-105">ASP.NET Core MVC supports partial views, which are useful when you have reusable parts of web pages you want to share between different views.</span></span>

<span data-ttu-id="7f055-106">[查看或下载示例代码](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/views/partial/sample)（[如何下载](xref:tutorials/index#how-to-download-a-sample)）</span><span class="sxs-lookup"><span data-stu-id="7f055-106">[View or download sample code](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/views/partial/sample) ([how to download](xref:tutorials/index#how-to-download-a-sample))</span></span>

## <a name="what-are-partial-views"></a><span data-ttu-id="7f055-107">什么是分部视图？</span><span class="sxs-lookup"><span data-stu-id="7f055-107">What are Partial Views?</span></span>

<span data-ttu-id="7f055-108">分部视图是指在其他视图内呈现的视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-108">A partial view is a view that's rendered within another view.</span></span> <span data-ttu-id="7f055-109">通过执行分部视图生成的 HTML 输出在调用视图（或父视图）中呈现。</span><span class="sxs-lookup"><span data-stu-id="7f055-109">The HTML output generated by executing the partial view is rendered into the calling (or parent) view.</span></span> <span data-ttu-id="7f055-110">和视图一样，分部视图也使用 *.cshtml* 文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="7f055-110">Like views, partial views use the *.cshtml* file extension.</span></span>

## <a name="when-should-i-use-partial-views"></a><span data-ttu-id="7f055-111">应在何时使用分部视图？</span><span class="sxs-lookup"><span data-stu-id="7f055-111">When Should I Use Partial Views?</span></span>

<span data-ttu-id="7f055-112">分部视图是将大型视图分解为较小组件的有效方法。</span><span class="sxs-lookup"><span data-stu-id="7f055-112">Partial views are an effective way of breaking up large views into smaller components.</span></span> <span data-ttu-id="7f055-113">它们可减少视图内容的重复并使视图元素得以重复使用。</span><span class="sxs-lookup"><span data-stu-id="7f055-113">They can reduce duplication of view content and allow view elements to be reused.</span></span> <span data-ttu-id="7f055-114">常见布局元素应在 [_Layout.cshtml](layout.md) 中指定。</span><span class="sxs-lookup"><span data-stu-id="7f055-114">Common layout elements should be specified in [_Layout.cshtml](layout.md).</span></span> <span data-ttu-id="7f055-115">非布局可重用内容可封装到分部视图中。</span><span class="sxs-lookup"><span data-stu-id="7f055-115">Non-layout reusable content can be encapsulated into partial views.</span></span>

<span data-ttu-id="7f055-116">如果拥有由多个逻辑部分组成的复杂页面，将每个部分用作其自己的分部视图十分有用。</span><span class="sxs-lookup"><span data-stu-id="7f055-116">If you have a complex page made up of several logical pieces, it can be helpful to work with each piece as its own partial view.</span></span> <span data-ttu-id="7f055-117">页面的每个部分都可独立于页面的其余部分进行查看，且页面本身的视图也会变得更加简单，因为它仅包含整体页面结构以及用于呈现分部视图的调用。</span><span class="sxs-lookup"><span data-stu-id="7f055-117">Each piece of the page can be viewed in isolation from the rest of the page, and the view for the page itself becomes much simpler since it only contains the overall page structure and calls to render the partial views.</span></span>

<span data-ttu-id="7f055-118">提示：在视图中遵守[不要自我重复原则](http://deviq.com/don-t-repeat-yourself/)。</span><span class="sxs-lookup"><span data-stu-id="7f055-118">Tip: Follow the [Don't Repeat Yourself Principle](http://deviq.com/don-t-repeat-yourself/) in your views.</span></span>

## <a name="declaring-partial-views"></a><span data-ttu-id="7f055-119">声明分部视图</span><span class="sxs-lookup"><span data-stu-id="7f055-119">Declaring Partial Views</span></span>

<span data-ttu-id="7f055-120">分部视图的创建方式与任何其他视图的创建方式类似：在 *Views* 文件夹内创建 *.cshtml* 文件。</span><span class="sxs-lookup"><span data-stu-id="7f055-120">Partial views are created like any other view: you create a *.cshtml* file within the *Views* folder.</span></span> <span data-ttu-id="7f055-121">分部视图和常规视图之间没有语义差异-，仅呈现方式不同。</span><span class="sxs-lookup"><span data-stu-id="7f055-121">There's no semantic difference between a partial view and a regular view - they're just rendered differently.</span></span> <span data-ttu-id="7f055-122">可拥有直接从控制器的 `ViewResult` 返回的视图，并可将同一视图用作分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-122">You can have a view that's returned directly from a controller's `ViewResult`, and the same view can be used as a partial view.</span></span> <span data-ttu-id="7f055-123">视图和分部视图的主要呈现方式差异在于分部视图不运行 *_ViewStart.cshtml*（而视图运行 — 有关 *_ViewStart.cshtml* 的详细信息，请参阅[布局](layout.md)）。</span><span class="sxs-lookup"><span data-stu-id="7f055-123">The main difference between how a view and a partial view are rendered is that partial views don't run *_ViewStart.cshtml* (while views do - learn more about *_ViewStart.cshtml* in [Layout](layout.md)).</span></span>

## <a name="referencing-a-partial-view"></a><span data-ttu-id="7f055-124">引用分部视图</span><span class="sxs-lookup"><span data-stu-id="7f055-124">Referencing a Partial View</span></span>

<span data-ttu-id="7f055-125">在视图页中，有多种方法可呈现分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-125">From within a view page, there are several ways in which you can render a partial view.</span></span> <span data-ttu-id="7f055-126">最佳做法是使用 `Html.PartialAsync`，它会返回 `IHtmlString` 并可通过为调用添加 `@` 前缀进行引用：</span><span class="sxs-lookup"><span data-stu-id="7f055-126">The best practice is to use `Html.PartialAsync`, which returns an `IHtmlString` and can be referenced by prefixing the call with `@`:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Home/About.cshtml?range=8)]

<span data-ttu-id="7f055-127">可使用 `RenderPartialAsync` 呈现分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-127">You can render a partial view with `RenderPartialAsync`.</span></span> <span data-ttu-id="7f055-128">此方法不返回结果；它将呈现的输出直接流式传输到响应。</span><span class="sxs-lookup"><span data-stu-id="7f055-128">This method doesn't return a result; it streams the rendered output directly to the response.</span></span> <span data-ttu-id="7f055-129">因为它不返回结果，所以必须在 Razor 代码块内调用它：</span><span class="sxs-lookup"><span data-stu-id="7f055-129">Because it doesn't return a result, it must be called within a Razor code block:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Home/About.cshtml?range=11-13)]

<span data-ttu-id="7f055-130">由于它直接流式传输结果，`RenderPartialAsync` 在某些情况下可能会表现更佳。</span><span class="sxs-lookup"><span data-stu-id="7f055-130">Because it streams the result directly, `RenderPartialAsync` may perform better in some scenarios.</span></span> <span data-ttu-id="7f055-131">但是，建议使用 `PartialAsync`。</span><span class="sxs-lookup"><span data-stu-id="7f055-131">However, it's recommended you use `PartialAsync`.</span></span>

<span data-ttu-id="7f055-132">虽然存在 `Html.PartialAsync` (`Html.Partial`) 和 `Html.RenderPartialAsync` (`Html.RenderPartial`) 的同步等效项，但不建议使用同步等效项，因为可能会出现死锁的情况。</span><span class="sxs-lookup"><span data-stu-id="7f055-132">While there are synchronous equivalents of `Html.PartialAsync` (`Html.Partial`) and `Html.RenderPartialAsync` (`Html.RenderPartial`), use of the synchronous equivalents isn't recommended because there are scenarios where they deadlock.</span></span> <span data-ttu-id="7f055-133">同步方法在将来版本中不可用。</span><span class="sxs-lookup"><span data-stu-id="7f055-133">The synchronous methods will be unavailable in future versions.</span></span>

> [!NOTE]
> <span data-ttu-id="7f055-134">如果视图需要执行代码，建议模式为使用[视图组件](view-components.md)，而不要使用分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-134">If your views need to execute code, the recommended pattern is to use a [view component](view-components.md) instead of a partial view.</span></span>

### <a name="partial-view-discovery"></a><span data-ttu-id="7f055-135">分部视图发现</span><span class="sxs-lookup"><span data-stu-id="7f055-135">Partial View Discovery</span></span>

<span data-ttu-id="7f055-136">引用分部视图时，可通过多种方式引用其位置：</span><span class="sxs-lookup"><span data-stu-id="7f055-136">When referencing a partial view, you can refer to its location in several ways:</span></span>

```cshtml
// Uses a view in current folder with this name
// If none is found, searches the Shared folder
@await Html.PartialAsync("ViewName")

// A view with this name must be in the same folder
@await Html.PartialAsync("ViewName.cshtml")

// Locate the view based on the application root
// Paths that start with "/" or "~/" refer to the application root
@await Html.PartialAsync("~/Views/Folder/ViewName.cshtml")
@await Html.PartialAsync("/Views/Folder/ViewName.cshtml")

// Locate the view using relative paths
@await Html.PartialAsync("../Account/LoginPartial.cshtml")
```

<span data-ttu-id="7f055-137">可在不同视图文件夹中拥有具有相同名称的不同分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-137">You can have different partial views with the same name in different view folders.</span></span> <span data-ttu-id="7f055-138">按名称（不带文件扩展名）引用视图时，每个文件夹中的视图都会使用与其位于同一文件夹中的分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-138">When referencing the views by name (without file extension), views in each folder will use the partial view in the same folder with them.</span></span> <span data-ttu-id="7f055-139">还可指定要使用的默认分部视图，将其放在 *Shared* 文件夹中。</span><span class="sxs-lookup"><span data-stu-id="7f055-139">You can also specify a default partial view to use, placing it in the *Shared* folder.</span></span> <span data-ttu-id="7f055-140">任何没有属于自己的分部视图的视图则可使用共享分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-140">The shared partial view will be used by any views that don't have their own version of the partial view.</span></span> <span data-ttu-id="7f055-141">可设置默认分部视图（位于 *Shared* 中），该视图被与父视图位于同一文件夹并具有相同名称的分部视图替代。</span><span class="sxs-lookup"><span data-stu-id="7f055-141">You can have a default partial view (in *Shared*), which is overridden by a partial view with the same name in the same folder as the parent view.</span></span>

<span data-ttu-id="7f055-142">分部视图可*链接*。</span><span class="sxs-lookup"><span data-stu-id="7f055-142">Partial views can be *chained*.</span></span> <span data-ttu-id="7f055-143">也就是说，分部视图可调用其他分部视图（只要未创建循环）。</span><span class="sxs-lookup"><span data-stu-id="7f055-143">That is, a partial view can call another partial view (as long as you don't create a loop).</span></span> <span data-ttu-id="7f055-144">在每个视图或分部视图内，相对路径始终相对于该视图，而不相对于根视图或父视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-144">Within each view or partial view, relative paths are always relative to that view, not the root or parent view.</span></span>

> [!NOTE]
> <span data-ttu-id="7f055-145">如果在分部视图中声明 [Razor](razor.md) `section`，它不会对其父对象可见；它会局限于分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-145">If you declare a [Razor](razor.md) `section` in a partial view, it will not be visible to its parent(s); it will be limited to the partial view.</span></span>

## <a name="accessing-data-from-partial-views"></a><span data-ttu-id="7f055-146">通过分部视图访问数据</span><span class="sxs-lookup"><span data-stu-id="7f055-146">Accessing Data From Partial Views</span></span>

<span data-ttu-id="7f055-147">实例化分部视图时，它会获得父视图的 `ViewData` 字典的副本。</span><span class="sxs-lookup"><span data-stu-id="7f055-147">When a partial view is instantiated, it gets a copy of the parent view's `ViewData` dictionary.</span></span> <span data-ttu-id="7f055-148">在分部视图内对数据所做的更新不会保存到父视图中。</span><span class="sxs-lookup"><span data-stu-id="7f055-148">Updates made to the data within the partial view are not persisted to the parent view.</span></span> <span data-ttu-id="7f055-149">在分部视图中更改的 `ViewData` 会在分部视图返回时丢失。</span><span class="sxs-lookup"><span data-stu-id="7f055-149">`ViewData` changed in a partial view is lost when the partial view returns.</span></span>

<span data-ttu-id="7f055-150">可将 `ViewDataDictionary` 的实例传递到分部视图：</span><span class="sxs-lookup"><span data-stu-id="7f055-150">You can pass an instance of `ViewDataDictionary` to the partial view:</span></span>

```cshtml
@await Html.PartialAsync("PartialName", customViewData)
```

<span data-ttu-id="7f055-151">还可将模型传入分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-151">You can also pass a model into a partial view.</span></span> <span data-ttu-id="7f055-152">该模型可以是页面的视图模型或自定义对象。</span><span class="sxs-lookup"><span data-stu-id="7f055-152">This can be the page's view model or a custom object.</span></span> <span data-ttu-id="7f055-153">可将模型传递到 `PartialAsync` 或 `RenderPartialAsync`：</span><span class="sxs-lookup"><span data-stu-id="7f055-153">You can pass a model to `PartialAsync` or `RenderPartialAsync`:</span></span>

```cshtml
@await Html.PartialAsync("PartialName", viewModel)
```

<span data-ttu-id="7f055-154">可将 `ViewDataDictionary` 的实例和视图模型传递到分部视图：</span><span class="sxs-lookup"><span data-stu-id="7f055-154">You can pass an instance of `ViewDataDictionary` and a view model to a partial view:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Articles/Read.cshtml?range=15-16)]

<span data-ttu-id="7f055-155">以下标记显示包含两个分部视图的 *Views/Articles/Read.cshtml* 视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-155">The markup below shows the *Views/Articles/Read.cshtml* view which contains two partial views.</span></span> <span data-ttu-id="7f055-156">第二个分部视图将模型和 `ViewData` 传入分部视图。</span><span class="sxs-lookup"><span data-stu-id="7f055-156">The second partial view passes in a model and `ViewData` to the partial view.</span></span> <span data-ttu-id="7f055-157">如果使用下方突出显示的 `ViewDataDictionary` 的构造函数重载，则可在传递新 `ViewData` 字典的同时保留现有的 `ViewData`：</span><span class="sxs-lookup"><span data-stu-id="7f055-157">You can pass new `ViewData` dictionary while retaining the existing `ViewData` if you use the constructor overload of the `ViewDataDictionary` highlighted below:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Articles/Read.cshtml)]

<span data-ttu-id="7f055-158">*Views/Shared/AuthorPartial*：</span><span class="sxs-lookup"><span data-stu-id="7f055-158">*Views/Shared/AuthorPartial*:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Shared/AuthorPartial.cshtml)]

<span data-ttu-id="7f055-159">*ArticleSection* 分部视图：</span><span class="sxs-lookup"><span data-stu-id="7f055-159">The *ArticleSection* partial:</span></span>

[!code-cshtml[](partial/sample/src/PartialViewsSample/Views/Articles/ArticleSection.cshtml)]

<span data-ttu-id="7f055-160">在运行时，分部视图在父视图中呈现，而父视图本身在共享的 *_Layout.cshtml* 内呈现</span><span class="sxs-lookup"><span data-stu-id="7f055-160">At runtime, the partials are rendered into the parent view, which itself is rendered within the shared *_Layout.cshtml*</span></span>

![分部视图输出](partial/_static/output.png)
