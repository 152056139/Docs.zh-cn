---
title: "使用者 Api 概述"
author: rick-anderson
description: 
keywords: "ASP.NET 核心"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: f69beb9d-a519-43a8-857c-f6b01886a903
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/overview
ms.openlocfilehash: d23a6ce50eef71f393124b9420f4ba473904d8b4
ms.sourcegitcommit: 0b6c8e6d81d2b3c161cd375036eecbace46a9707
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/11/2017
---
# <a name="consumer-apis-overview"></a><span data-ttu-id="7e834-103">使用者 Api 概述</span><span class="sxs-lookup"><span data-stu-id="7e834-103">Consumer APIs overview</span></span>

<span data-ttu-id="7e834-104">IDataProtectionProvider 和 IDataProtector 接口都是通过该使用者使用数据保护系统的基本接口。</span><span class="sxs-lookup"><span data-stu-id="7e834-104">The IDataProtectionProvider and IDataProtector interfaces are the basic interfaces through which consumers use the data protection system.</span></span> <span data-ttu-id="7e834-105">它们位于 Microsoft.AspNetCore.DataProtection.Abstractions 包中。</span><span class="sxs-lookup"><span data-stu-id="7e834-105">They are located in the Microsoft.AspNetCore.DataProtection.Abstractions package.</span></span>

## <a name="idataprotectionprovider"></a><span data-ttu-id="7e834-106">IDataProtectionProvider</span><span class="sxs-lookup"><span data-stu-id="7e834-106">IDataProtectionProvider</span></span>

<span data-ttu-id="7e834-107">提供程序接口表示数据保护系统的根目录。</span><span class="sxs-lookup"><span data-stu-id="7e834-107">The provider interface represents the root of the data protection system.</span></span> <span data-ttu-id="7e834-108">它不能直接用于保护或取消保护数据。</span><span class="sxs-lookup"><span data-stu-id="7e834-108">It cannot directly be used to protect or unprotect data.</span></span> <span data-ttu-id="7e834-109">相反，使用者必须通过调用的 IDataProtectionProvider.CreateProtector(purpose)，其中，目的是一个字符串，描述预期的使用者用例获得对 IDataProtector 的引用。</span><span class="sxs-lookup"><span data-stu-id="7e834-109">Instead, the consumer must get a reference to an IDataProtector by calling IDataProtectionProvider.CreateProtector(purpose), where purpose is a string that describes the intended consumer use case.</span></span> <span data-ttu-id="7e834-110">请参阅[目的字符串](purpose-strings.md)着眼于此参数以及如何选择适当的值的更多的信息。</span><span class="sxs-lookup"><span data-stu-id="7e834-110">See [Purpose Strings](purpose-strings.md) for much more information on the intent of this parameter and how to choose an appropriate value.</span></span>

## <a name="idataprotector"></a><span data-ttu-id="7e834-111">IDataProtector</span><span class="sxs-lookup"><span data-stu-id="7e834-111">IDataProtector</span></span>

<span data-ttu-id="7e834-112">保护程序接口将返回通过调用 CreateProtector，并且此接口使用者可以用于执行保护和取消保护操作。</span><span class="sxs-lookup"><span data-stu-id="7e834-112">The protector interface is returned by a call to CreateProtector, and it is this interface which consumers can use to perform protect and unprotect operations.</span></span>

<span data-ttu-id="7e834-113">若要保护的数据片段，请将数据传递给保护方法。</span><span class="sxs-lookup"><span data-stu-id="7e834-113">To protect a piece of data, pass the data to the Protect method.</span></span> <span data-ttu-id="7e834-114">基本接口定义的方法的将 byte []-> byte []，但还存在 （提供作为扩展方法） 将字符串转换的重载-> 字符串。</span><span class="sxs-lookup"><span data-stu-id="7e834-114">The basic interface defines a method which converts byte[] -> byte[], but there is also an overload (provided as an extension method) which converts string -> string.</span></span> <span data-ttu-id="7e834-115">提供两种方法的安全性是相同的;开发人员应选择任何重载是最方便对其用例。</span><span class="sxs-lookup"><span data-stu-id="7e834-115">The security offered by the two methods is identical; the developer should choose whichever overload is most convenient for their use case.</span></span> <span data-ttu-id="7e834-116">而不考虑的重载选择，则返回保护方法现在受保护 （enciphered 和防考验） 和应用程序可以将其发送到不受信任的客户端。</span><span class="sxs-lookup"><span data-stu-id="7e834-116">Irrespective of the overload chosen, the value returned by the Protect method is now protected (enciphered and tamper-proofed), and the application can send it to an untrusted client.</span></span>

<span data-ttu-id="7e834-117">要取消对以前受保护的数据片段的保护，请将受保护的数据传递给取消保护方法。</span><span class="sxs-lookup"><span data-stu-id="7e834-117">To unprotect a previously-protected piece of data, pass the protected data to the Unprotect method.</span></span> <span data-ttu-id="7e834-118">(有 byte []-基于和基于字符串的重载，为开发人员方便起见。)如果受保护的负载由以前在此同一 IDataProtector 保护调用生成的取消保护方法将返回原始的未受保护的负载。</span><span class="sxs-lookup"><span data-stu-id="7e834-118">(There are byte[]-based and string-based overloads for developer convenience.) If the protected payload was generated by an earlier call to Protect on this same IDataProtector, the Unprotect method will return the original unprotected payload.</span></span> <span data-ttu-id="7e834-119">如果已被篡改或由不同 IDataProtector 生成受保护的负载的情况下，取消保护方法将引发 CryptographicException。</span><span class="sxs-lookup"><span data-stu-id="7e834-119">If the protected payload has been tampered with or was produced by a different IDataProtector, the Unprotect method will throw CryptographicException.</span></span>

<span data-ttu-id="7e834-120">与不同 IDataProtector 的相同的概念将联系回目的的概念。</span><span class="sxs-lookup"><span data-stu-id="7e834-120">The concept of same vs. different IDataProtector ties back to the concept of purpose.</span></span> <span data-ttu-id="7e834-121">如果从同一根 IDataProtectionProvider 但通过不同的用途字符串 IDataProtectionProvider.CreateProtector，对的调用中生成两个 IDataProtector 实例，则它们将被视为[不同保护程序](purpose-strings.md)，和一个将无法取消保护由其他生成的负载。</span><span class="sxs-lookup"><span data-stu-id="7e834-121">If two IDataProtector instances were generated from the same root IDataProtectionProvider but via different purpose strings in the call to IDataProtectionProvider.CreateProtector, then they are considered [different protectors](purpose-strings.md), and one will not be able to unprotect payloads generated by the other.</span></span>

## <a name="consuming-these-interfaces"></a><span data-ttu-id="7e834-122">使用这些接口</span><span class="sxs-lookup"><span data-stu-id="7e834-122">Consuming these interfaces</span></span>

<span data-ttu-id="7e834-123">对于 DI 感知的组件，预期的用法是组件在其构造函数采用 IDataProtectionProvider 参数，参数，并在实例化组件时，DI 系统可以自动提供此服务。</span><span class="sxs-lookup"><span data-stu-id="7e834-123">For a DI-aware component, the intended usage is that the component take an IDataProtectionProvider parameter in its constructor and that the DI system automatically provides this service when the component is instantiated.</span></span>

> [!NOTE]
> <span data-ttu-id="7e834-124">某些应用程序 （如控制台应用程序或 ASP.NET 4.x 应用程序） 可能不是 DI 感知因此不能使用此处所述的机制。</span><span class="sxs-lookup"><span data-stu-id="7e834-124">Some applications (such as console applications or ASP.NET 4.x applications) might not be DI-aware so cannot use the mechanism described here.</span></span> <span data-ttu-id="7e834-125">有关这些方案，请查阅[非 DI 感知的情境](../configuration/non-di-scenarios.md)文档而无需通过 DI 获取 IDataProtection 提供程序实例的详细信息。</span><span class="sxs-lookup"><span data-stu-id="7e834-125">For these scenarios consult the [Non DI Aware Scenarios](../configuration/non-di-scenarios.md) document for more information on getting an instance of an IDataProtection provider without going through DI.</span></span>

<span data-ttu-id="7e834-126">下面的示例演示三个概念：</span><span class="sxs-lookup"><span data-stu-id="7e834-126">The following sample demonstrates three concepts:</span></span>

1. <span data-ttu-id="7e834-127">[添加数据保护系统](../configuration/overview.md)到服务容器</span><span class="sxs-lookup"><span data-stu-id="7e834-127">[Adding the data protection system](../configuration/overview.md) to the service container,</span></span>

2. <span data-ttu-id="7e834-128">使用 DI 接收的 IDataProtectionProvider 实例和</span><span class="sxs-lookup"><span data-stu-id="7e834-128">Using DI to receive an instance of an IDataProtectionProvider, and</span></span>

3. <span data-ttu-id="7e834-129">从 IDataProtectionProvider 创建 IDataProtector 并使用它来保护和取消保护数据。</span><span class="sxs-lookup"><span data-stu-id="7e834-129">Creating an IDataProtector from an IDataProtectionProvider and using it to protect and unprotect data.</span></span>

<span data-ttu-id="7e834-130">[!code-csharp[Main](../using-data-protection/samples/protectunprotect.cs?highlight=26,34,35,36,37,38,39,40)]</span><span class="sxs-lookup"><span data-stu-id="7e834-130">[!code-csharp[Main](../using-data-protection/samples/protectunprotect.cs?highlight=26,34,35,36,37,38,39,40)]</span></span>

<span data-ttu-id="7e834-131">包 Microsoft.AspNetCore.DataProtection.Abstractions 包含扩展方法 IServiceProvider.GetDataProtector 为开发人员方便起见。</span><span class="sxs-lookup"><span data-stu-id="7e834-131">The package Microsoft.AspNetCore.DataProtection.Abstractions contains an extension method IServiceProvider.GetDataProtector as a developer convenience.</span></span> <span data-ttu-id="7e834-132">它封装作为单个操作同时从服务提供程序检索 IDataProtectionProvider 并调用 IDataProtectionProvider.CreateProtector。</span><span class="sxs-lookup"><span data-stu-id="7e834-132">It encapsulates as a single operation both retrieving an IDataProtectionProvider from the service provider and calling IDataProtectionProvider.CreateProtector.</span></span> <span data-ttu-id="7e834-133">下面的示例演示其用法。</span><span class="sxs-lookup"><span data-stu-id="7e834-133">The following sample demonstrates its usage.</span></span>

<span data-ttu-id="7e834-134">[!code-csharp[Main](./overview/samples/getdataprotector.cs?highlight=15)]</span><span class="sxs-lookup"><span data-stu-id="7e834-134">[!code-csharp[Main](./overview/samples/getdataprotector.cs?highlight=15)]</span></span>

>[!TIP]
> <span data-ttu-id="7e834-135">IDataProtectionProvider 和 IDataProtector 的实例是线程安全的多个调用方。</span><span class="sxs-lookup"><span data-stu-id="7e834-135">Instances of IDataProtectionProvider and IDataProtector are thread-safe for multiple callers.</span></span> <span data-ttu-id="7e834-136">它旨在后一个组件获取通过 CreateProtector 调用 IDataProtector 的引用，它将该引用用于保护的多个调用和 Unprotect Unprotect.A 调用将引发 CryptographicException，如果受保护的负载不能为验证或中译解出来。</span><span class="sxs-lookup"><span data-stu-id="7e834-136">It is intended that once a component gets a reference to an IDataProtector via a call to CreateProtector, it will use that reference for multiple calls to Protect and Unprotect.A call to Unprotect will throw CryptographicException if the protected payload cannot be verified or deciphered.</span></span> <span data-ttu-id="7e834-137">某些组件可能想要忽略错误期间取消保护操作;组件它读取身份验证 cookie 可能处理此错误和请求则将视为根本具有任何 cookie，而不使迫切地请求失败。</span><span class="sxs-lookup"><span data-stu-id="7e834-137">Some components may wish to ignore errors during unprotect operations; a component which reads authentication cookies might handle this error and treat the request as if it had no cookie at all rather than fail the request outright.</span></span> <span data-ttu-id="7e834-138">需要此行为的组件应专门捕获 CryptographicException，而不是忽略所有异常。</span><span class="sxs-lookup"><span data-stu-id="7e834-138">Components which want this behavior should specifically catch CryptographicException instead of swallowing all exceptions.</span></span>
