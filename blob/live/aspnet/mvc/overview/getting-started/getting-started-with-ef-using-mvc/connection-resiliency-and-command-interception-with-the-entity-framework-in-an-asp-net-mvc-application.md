---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
title: "连接复原和与实体框架中的 ASP.NET MVC 应用程序的命令截获 |Microsoft 文档"
author: tdykstra
description: "Contoso 大学示例 web 应用程序演示如何创建使用 Entity Framework 6 Code First 和 Visual Studio 的 ASP.NET MVC 5 应用程序..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 01/13/2015
ms.topic: article
ms.assetid: c89d809f-6c65-4425-a3fa-c9f6e8ac89f2
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
msc.type: authoredcontent
ms.openlocfilehash: fecdd582918a61f3d01519c75d159f9c601c8223
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="connection-resiliency-and-command-interception-with-the-entity-framework-in-an-aspnet-mvc-application"></a><span data-ttu-id="b397f-103">连接复原和命令截获与实体框架中的 ASP.NET MVC 应用程序</span><span class="sxs-lookup"><span data-stu-id="b397f-103">Connection Resiliency and Command Interception with the Entity Framework in an ASP.NET MVC Application</span></span>
====================
<span data-ttu-id="b397f-104">通过[Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="b397f-104">by [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="b397f-105">[下载已完成的项目](http://code.msdn.microsoft.com/ASPNET-MVC-Application-b01a9fe8)或[下载 PDF](http://download.microsoft.com/download/0/F/B/0FBFAA46-2BFD-478F-8E56-7BF3C672DF9D/Getting%20Started%20with%20Entity%20Framework%206%20Code%20First%20using%20MVC%205.pdf)</span><span class="sxs-lookup"><span data-stu-id="b397f-105">[Download Completed Project](http://code.msdn.microsoft.com/ASPNET-MVC-Application-b01a9fe8) or [Download PDF](http://download.microsoft.com/download/0/F/B/0FBFAA46-2BFD-478F-8E56-7BF3C672DF9D/Getting%20Started%20with%20Entity%20Framework%206%20Code%20First%20using%20MVC%205.pdf)</span></span>

> <span data-ttu-id="b397f-106">Contoso 大学示例 web 应用程序演示如何创建使用 Entity Framework 6 Code First 和 Visual Studio 2013 的 ASP.NET MVC 5 应用程序。</span><span class="sxs-lookup"><span data-stu-id="b397f-106">The Contoso University sample web application demonstrates how to create ASP.NET MVC 5 applications using the Entity Framework 6 Code First and Visual Studio 2013.</span></span> <span data-ttu-id="b397f-107">有关教程系列的信息，请参阅[序列中的第一个教程](creating-an-entity-framework-data-model-for-an-asp-net-mvc-application.md)。</span><span class="sxs-lookup"><span data-stu-id="b397f-107">For information about the tutorial series, see [the first tutorial in the series](creating-an-entity-framework-data-model-for-an-asp-net-mvc-application.md).</span></span>


<span data-ttu-id="b397f-108">到目前为止应用程序已经运行本地 IIS Express 在开发计算机上。</span><span class="sxs-lookup"><span data-stu-id="b397f-108">So far the application has been running locally in IIS Express on your development computer.</span></span> <span data-ttu-id="b397f-109">若要使实际的应用程序可用于通过 Internet 使用其他人，你必须将其部署到 web 宿主提供程序，并且必须将数据库部署到数据库服务器。</span><span class="sxs-lookup"><span data-stu-id="b397f-109">To make a real application available for other people to use over the Internet, you have to deploy it to a web hosting provider, and you have to deploy the database to a database server.</span></span>

<span data-ttu-id="b397f-110">在本教程中，你将了解如何使用 Entity Framework 6 的两个特别有价值，当你要部署到云环境的功能： 连接复原 （自动重试的暂时性错误） 和命令截获 （捕捉所有 SQL 查询发送到数据库才能登录或更改它们）。</span><span class="sxs-lookup"><span data-stu-id="b397f-110">In this tutorial you'll learn how to use two features of Entity Framework 6 that are especially valuable when you are deploying to the cloud environment: connection resiliency (automatic retries for transient errors) and command interception (catch all SQL queries sent to the database in order to log or change them).</span></span>

<span data-ttu-id="b397f-111">此连接复原能力和命令截获教程是可选的。</span><span class="sxs-lookup"><span data-stu-id="b397f-111">This connection resiliency and command interception tutorial is optional.</span></span> <span data-ttu-id="b397f-112">如果你跳过本教程中，将具有少量小的调整将在后续教程中进行。</span><span class="sxs-lookup"><span data-stu-id="b397f-112">If you skip this tutorial, a few minor adjustments will have to be made in subsequent tutorials.</span></span>

## <a name="enable-connection-resiliency"></a><span data-ttu-id="b397f-113">启用连接复原</span><span class="sxs-lookup"><span data-stu-id="b397f-113">Enable connection resiliency</span></span>

<span data-ttu-id="b397f-114">在部署到 Windows Azure 应用程序时，你将部署到 Windows Azure SQL Database、 云数据库服务数据库。</span><span class="sxs-lookup"><span data-stu-id="b397f-114">When you deploy the application to Windows Azure, you'll deploy the database to Windows Azure SQL Database, a cloud database service.</span></span> <span data-ttu-id="b397f-115">连接到云数据库服务时与你的 web 服务器和数据库服务器直接连接在一起位于同一数据中心时，暂时性连接错误是通常更频繁。</span><span class="sxs-lookup"><span data-stu-id="b397f-115">Transient connection errors are typically more frequent when you connect to a cloud database service than when your web server and your database server are directly connected together in the same data center.</span></span> <span data-ttu-id="b397f-116">即使在同一数据中心中承载的云 web 服务器和云数据库服务时，有更多的网络连接，它们将会出现问题，例如负载平衡器之间。</span><span class="sxs-lookup"><span data-stu-id="b397f-116">Even if a cloud web server and a cloud database service are hosted in the same data center, there are more network connections between them that can have problems, such as load balancers.</span></span>

<span data-ttu-id="b397f-117">此外云服务通常由其他用户共享，这意味着其响应能力可能受到它们。</span><span class="sxs-lookup"><span data-stu-id="b397f-117">Also a cloud service is typically shared by other users, which means its responsiveness can be affected by them.</span></span> <span data-ttu-id="b397f-118">并且您对数据库访问权限可能受到限制。</span><span class="sxs-lookup"><span data-stu-id="b397f-118">And your access to the database might be subject to throttling.</span></span> <span data-ttu-id="b397f-119">当你尝试访问更多经常大于所允许你服务级别协议 (SLA) 中时限制意味着数据库服务将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-119">Throttling means the database service throws exceptions when you try to access it more frequently than is allowed in your Service Level Agreement (SLA).</span></span>

<span data-ttu-id="b397f-120">许多或大多数连接问题时你正在访问云服务是暂时的也就是说，它们自身解决在短时间的时间。</span><span class="sxs-lookup"><span data-stu-id="b397f-120">Many or most connection problems when you're accessing a cloud service are transient, that is, they resolve themselves in a short period of time.</span></span> <span data-ttu-id="b397f-121">因此当你尝试数据库操作，并获取一种是通常暂时性的错误，稍等片刻，该操作可能会成功后无法重试该操作。</span><span class="sxs-lookup"><span data-stu-id="b397f-121">So when you try a database operation and get a type of error that is typically transient, you could try the operation again after a short wait, and the operation might be successful.</span></span> <span data-ttu-id="b397f-122">如果通过自动重试，处理暂时性错误，可以为你的用户提供更好的体验使其中的大多数客户不可见。</span><span class="sxs-lookup"><span data-stu-id="b397f-122">You can provide a much better experience for your users if you handle transient errors by automatically trying again, making most of them invisible to the customer.</span></span> <span data-ttu-id="b397f-123">连接复原功能 Entity Framework 6 中的自动执行过程的重试失败的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="b397f-123">The connection resiliency feature in Entity Framework 6 automates that process of retrying failed SQL queries.</span></span>

<span data-ttu-id="b397f-124">针对特定数据库服务，必须适当地配置连接复原功能：</span><span class="sxs-lookup"><span data-stu-id="b397f-124">The connection resiliency feature must be configured appropriately for a particular database service:</span></span>

- <span data-ttu-id="b397f-125">它必须知道哪些异常很可能是暂时的。</span><span class="sxs-lookup"><span data-stu-id="b397f-125">It has to know which exceptions are likely to be transient.</span></span> <span data-ttu-id="b397f-126">你想要重试错误导致通过暂时丢失网络连接，不由程序 bug，例如引起的错误。</span><span class="sxs-lookup"><span data-stu-id="b397f-126">You want to retry errors caused by a temporary loss in network connectivity, not errors caused by program bugs, for example.</span></span>
- <span data-ttu-id="b397f-127">它必须等待适当的失败的操作的重试之间的时间量。</span><span class="sxs-lookup"><span data-stu-id="b397f-127">It has to wait an appropriate amount of time between retries of a failed operation.</span></span> <span data-ttu-id="b397f-128">你可以等待，再进行批处理的重试之间不是用户正在等待响应的联机 web 页可以。</span><span class="sxs-lookup"><span data-stu-id="b397f-128">You can wait longer between retries for a batch process than you can for an online web page where a user is waiting for a response.</span></span>
- <span data-ttu-id="b397f-129">它具有重试之前的适当次数。</span><span class="sxs-lookup"><span data-stu-id="b397f-129">It has to retry an appropriate number of times before it gives up.</span></span> <span data-ttu-id="b397f-130">你可能想要重试更多次，就像在联机应用程序中的批处理中。</span><span class="sxs-lookup"><span data-stu-id="b397f-130">You might want to retry more times in a batch process that you would in an online application.</span></span>

<span data-ttu-id="b397f-131">你可以配置这些设置的任何数据库环境中支持的实体框架提供程序中，手动但通常适用于的联机应用程序使用 Windows Azure SQL 数据库的默认值已为你配置和这些都是你将实施 Contoso 大学应用程序的设置。</span><span class="sxs-lookup"><span data-stu-id="b397f-131">You can configure these settings manually for any database environment supported by an Entity Framework provider, but default values that typically work well for an online application that uses Windows Azure SQL Database have already been configured for you, and those are the settings you'll implement for the Contoso University application.</span></span>

<span data-ttu-id="b397f-132">你所要做，以启用连接复原能力是中派生自程序集创建一个类[DbConfiguration](https://msdn.microsoft.com/en-us/data/jj680699.aspx)类和在该类中设置 SQL 数据库*执行策略*，即 EF 中另一个术语*重试策略*。</span><span class="sxs-lookup"><span data-stu-id="b397f-132">All you have to do to enable connection resiliency is create a class in your assembly that derives from the [DbConfiguration](https://msdn.microsoft.com/en-us/data/jj680699.aspx) class, and in that class set the SQL Database *execution strategy*, which in EF is another term for *retry policy*.</span></span>

1. <span data-ttu-id="b397f-133">在 DAL 文件夹中，添加一个名为的类文件*SchoolConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="b397f-133">In the DAL folder, add a class file named *SchoolConfiguration.cs*.</span></span>
2. <span data-ttu-id="b397f-134">模板代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b397f-134">Replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample1.cs)]

    <span data-ttu-id="b397f-135">实体框架将自动运行它派生自的类中找到的代码`DbConfiguration`。</span><span class="sxs-lookup"><span data-stu-id="b397f-135">The Entity Framework automatically runs the code it finds in a class that derives from `DbConfiguration`.</span></span> <span data-ttu-id="b397f-136">你可以使用`DbConfiguration`类来执行此在中否则所执行的操作的代码中的配置任务*Web.config*文件。</span><span class="sxs-lookup"><span data-stu-id="b397f-136">You can use the `DbConfiguration` class to do configuration tasks in code that you would otherwise do in the *Web.config* file.</span></span> <span data-ttu-id="b397f-137">有关详细信息，请参阅[EntityFramework 基于代码的配置](https://msdn.microsoft.com/en-us/data/jj680699)。</span><span class="sxs-lookup"><span data-stu-id="b397f-137">For more information, see [EntityFramework Code-Based Configuration](https://msdn.microsoft.com/en-us/data/jj680699).</span></span>
3. <span data-ttu-id="b397f-138">在*StudentController.cs*，添加`using`语句`System.Data.Entity.Infrastructure`。</span><span class="sxs-lookup"><span data-stu-id="b397f-138">In *StudentController.cs*, add a `using` statement for `System.Data.Entity.Infrastructure`.</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample2.cs)]
4. <span data-ttu-id="b397f-139">更改所有`catch`阻止该 catch`DataException`异常，以便它们捕获`RetryLimitExceededException`异常相反。</span><span class="sxs-lookup"><span data-stu-id="b397f-139">Change all of the `catch` blocks that catch `DataException` exceptions so that they catch `RetryLimitExceededException` exceptions instead.</span></span> <span data-ttu-id="b397f-140">例如: </span><span class="sxs-lookup"><span data-stu-id="b397f-140">For example:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample3.cs?highlight=1)]

    <span data-ttu-id="b397f-141">已使用`DataException`来尝试标识可能是暂时的以便提供友好的"重试"消息的错误。</span><span class="sxs-lookup"><span data-stu-id="b397f-141">You were using `DataException` to try to identify errors that might be transient in order to give a friendly "try again" message.</span></span> <span data-ttu-id="b397f-142">但现在，你已启用的重试策略，可能是暂时性的唯一错误将已尝试并失败几次和实际返回的异常将包装在`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-142">But now that you've turned on a retry policy, the only errors likely to be transient will already have been tried and failed several times and the actual exception returned will be wrapped in the `RetryLimitExceededException` exception.</span></span>

<span data-ttu-id="b397f-143">有关详细信息，请参阅[实体框架连接复原 / 重试逻辑](https://msdn.microsoft.com/en-us/data/dn456835)。</span><span class="sxs-lookup"><span data-stu-id="b397f-143">For more information, see [Entity Framework Connection Resiliency / Retry Logic](https://msdn.microsoft.com/en-us/data/dn456835).</span></span>

## <a name="enable-command-interception"></a><span data-ttu-id="b397f-144">启用命令截获</span><span class="sxs-lookup"><span data-stu-id="b397f-144">Enable Command Interception</span></span>

<span data-ttu-id="b397f-145">现在，你已启用的重试策略，如何进行你测试以验证它是否按预期工作？</span><span class="sxs-lookup"><span data-stu-id="b397f-145">Now that you've turned on a retry policy, how do you test to verify that it is working as expected?</span></span> <span data-ttu-id="b397f-146">不会轻易地强制暂时性错误发生，尤其是当您在本地，运行和它将会特别困难，可以将实际的暂时性错误集成到自动的单元测试。</span><span class="sxs-lookup"><span data-stu-id="b397f-146">It's not so easy to force a transient error to happen, especially when you're running locally, and it would be especially difficult to integrate actual transient errors into an automated unit test.</span></span> <span data-ttu-id="b397f-147">若要测试连接复原功能，需要一种方法将截获实体框架将发送到 SQL Server 的查询并将替换为通常暂时性异常类型的 SQL Server 响应。</span><span class="sxs-lookup"><span data-stu-id="b397f-147">To test the connection resiliency feature, you need a way to intercept queries that Entity Framework sends to SQL Server and replace the SQL Server response with an exception type that is typically transient.</span></span>

<span data-ttu-id="b397f-148">此外可以使用查询截获，以实现云应用程序的最佳做法：[记录延迟和成功或失败对外部服务的所有调用](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log)例如数据库服务。</span><span class="sxs-lookup"><span data-stu-id="b397f-148">You can also use query interception in order to implement a best practice for cloud applications: [log the latency and success or failure of all calls to external services](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) such as database services.</span></span> <span data-ttu-id="b397f-149">从 EF6 提供[专用日志记录 API](https://msdn.microsoft.com/en-us/data/dn469464) ，可以使其更轻松地执行日志记录，但在本教程的本部分中，你将了解如何使用实体框架的[截获功能](https://msdn.microsoft.com/en-us/data/dn469464)直接，同时包括这两者日志记录和用于模拟暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="b397f-149">EF6 provides a [dedicated logging API](https://msdn.microsoft.com/en-us/data/dn469464) that can make it easier to do logging, but in this section of the tutorial you'll learn how to use the Entity Framework's [interception feature](https://msdn.microsoft.com/en-us/data/dn469464) directly, both for logging and for simulating transient errors.</span></span>

### <a name="create-a-logging-interface-and-class"></a><span data-ttu-id="b397f-150">创建日志记录接口和类</span><span class="sxs-lookup"><span data-stu-id="b397f-150">Create a logging interface and class</span></span>

<span data-ttu-id="b397f-151">A[最佳做法的日志记录](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log)都需要执行使用接口而不是硬编码调用 System.Diagnostics.Trace 或日志记录类。</span><span class="sxs-lookup"><span data-stu-id="b397f-151">A [best practice for logging](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) is to do it by using an interface rather than hard-coding calls to System.Diagnostics.Trace or a logging class.</span></span> <span data-ttu-id="b397f-152">这使可更轻松地更改你的日志记录机制更高版本，如果你在某个时候需要执行该操作。</span><span class="sxs-lookup"><span data-stu-id="b397f-152">That makes it easier to change your logging mechanism later if you ever need to do that.</span></span> <span data-ttu-id="b397f-153">因此在本部分中，你将创建日志记录接口和类来实现它。 / p ></span><span class="sxs-lookup"><span data-stu-id="b397f-153">So in this section you'll create the logging interface and a class to implement it./p></span></span> 

1. <span data-ttu-id="b397f-154">在项目中创建一个文件夹并将其命名*日志记录*。</span><span class="sxs-lookup"><span data-stu-id="b397f-154">Create a folder in the project and name it *Logging*.</span></span>
2. <span data-ttu-id="b397f-155">在*日志记录*文件夹中，创建一个名为的类文件*ILogger.cs*，并将模板代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b397f-155">In the *Logging* folder, create a class file named *ILogger.cs*, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample4.cs)]

    <span data-ttu-id="b397f-156">该接口提供三种跟踪级别，以指示日志的相对重要性和旨在提供有关外部服务调用，如数据库查询的滞后时间信息的一个。</span><span class="sxs-lookup"><span data-stu-id="b397f-156">The interface provides three tracing levels to indicate the relative importance of logs, and one designed to provide latency information for external service calls such as database queries.</span></span> <span data-ttu-id="b397f-157">日志记录方法具有重载，可以传递引发异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-157">The logging methods have overloads that let you pass in an exception.</span></span> <span data-ttu-id="b397f-158">这是以便实现的接口，而不是依靠中每个日志记录方法调用在整个应用程序正在执行的类可靠地记录异常信息包括堆栈跟踪和内部异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-158">This is so that exception information including stack trace and inner exceptions is reliably logged by the class that implements the interface, instead of relying on that being done in each logging method call throughout the application.</span></span>

    <span data-ttu-id="b397f-159">TraceApi 方法使你能够跟踪的 SQL 数据库等外部服务每次调用的延迟。</span><span class="sxs-lookup"><span data-stu-id="b397f-159">The TraceApi methods enable you to track the latency of each call to an external service such as SQL Database.</span></span>
3. <span data-ttu-id="b397f-160">在*日志记录*文件夹中，创建一个名为的类文件*Logger.cs*，并将模板代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b397f-160">In the *Logging* folder, create a class file named *Logger.cs*, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample5.cs)]

    <span data-ttu-id="b397f-161">实现使用 System.Diagnostics 执行跟踪。</span><span class="sxs-lookup"><span data-stu-id="b397f-161">The implementation uses System.Diagnostics to do the tracing.</span></span> <span data-ttu-id="b397f-162">这是可以轻松地生成和使用跟踪信息的.NET 的内置功能。</span><span class="sxs-lookup"><span data-stu-id="b397f-162">This is a built-in feature of .NET which makes it easy to generate and use tracing information.</span></span> <span data-ttu-id="b397f-163">有许多"侦听器"你可以使用与 System.Diagnostics 跟踪日志写入文件，例如，或将它们写入到在 Azure 中的 blob 存储。</span><span class="sxs-lookup"><span data-stu-id="b397f-163">There are many "listeners" you can use with System.Diagnostics tracing, to write logs to files, for example, or to write them to blob storage in Azure.</span></span> <span data-ttu-id="b397f-164">在看到某些选项，以及指向其他资源的详细信息，[排除 Azure 网站在 Visual Studio 中](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="b397f-164">See some of the options, and links to other resources for more information, in [Troubleshooting Azure Web Sites in Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio).</span></span> <span data-ttu-id="b397f-165">在 Visual Studio 中的本教程中你将仅查看日志**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="b397f-165">For this tutorial you'll only look at logs in the Visual Studio **Output** window.</span></span>

    <span data-ttu-id="b397f-166">在生产应用程序中，你可能需要考虑 System.Diagnostics，以外的跟踪包和 ILogger 接口可以相对轻松地切换到不同的跟踪机制，如果你决定要执行该操作。</span><span class="sxs-lookup"><span data-stu-id="b397f-166">In a production application you might want to consider tracing packages other than System.Diagnostics, and the ILogger interface makes it relatively easy to switch to a different tracing mechanism if you decide to do that.</span></span>

### <a name="create-interceptor-classes"></a><span data-ttu-id="b397f-167">创建侦听器类</span><span class="sxs-lookup"><span data-stu-id="b397f-167">Create interceptor classes</span></span>

<span data-ttu-id="b397f-168">接下来你将创建每次它要将查询发送到数据库来模拟暂时性错误，其中进行日志记录时，实体框架将调入的类。</span><span class="sxs-lookup"><span data-stu-id="b397f-168">Next you'll create the classes that the Entity Framework will call into every time it is going to send a query to the database, one to simulate transient errors and one to do logging.</span></span> <span data-ttu-id="b397f-169">这些侦听器类必须派生自`DbCommandInterceptor`类。</span><span class="sxs-lookup"><span data-stu-id="b397f-169">These interceptor classes must derive from the `DbCommandInterceptor` class.</span></span> <span data-ttu-id="b397f-170">在它们编写查询是将要执行时，将自动调用的方法重写。</span><span class="sxs-lookup"><span data-stu-id="b397f-170">In them you write method overrides that are automatically called when query is about to be executed.</span></span> <span data-ttu-id="b397f-171">您可以在这些方法可以检查或日志查询正被发送到数据库，并可以更改查询发送到数据库之前，也可以返回某些内容到实体框架自己而无需甚至传递到数据库的查询。</span><span class="sxs-lookup"><span data-stu-id="b397f-171">In these methods you can examine or log the query that is being sent to the database, and you can change the query before it's sent to the database or return something to Entity Framework yourself without even passing the query to the database.</span></span>

1. <span data-ttu-id="b397f-172">若要创建将日志发送到数据库的每个 SQL 查询拦截器类，创建一个名为的类文件*SchoolInterceptorLogging.cs*中*DAL*文件夹，并将模板代码与以下代码：</span><span class="sxs-lookup"><span data-stu-id="b397f-172">To create the interceptor class that will log every SQL query that is sent to the database, create a class file named *SchoolInterceptorLogging.cs* in the *DAL* folder, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample6.cs)]

    <span data-ttu-id="b397f-173">对于成功的查询或命令，此代码将与滞后时间信息的信息日志。</span><span class="sxs-lookup"><span data-stu-id="b397f-173">For successful queries or commands, this code writes an Information log with latency information.</span></span> <span data-ttu-id="b397f-174">对于异常，它将创建错误日志。</span><span class="sxs-lookup"><span data-stu-id="b397f-174">For exceptions, it creates an Error log.</span></span>
2. <span data-ttu-id="b397f-175">若要创建在输入"引发"时，将生成 dummy 暂时性错误的侦听器类**搜索**框中，创建一个名为的类文件*SchoolInterceptorTransientErrors.cs*中*DAL*文件夹，并将替换为以下代码的模板代码：</span><span class="sxs-lookup"><span data-stu-id="b397f-175">To create the interceptor class that will generate dummy transient errors when you enter "Throw" in the **Search** box, create a class file named *SchoolInterceptorTransientErrors.cs* in the *DAL* folder, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample7.cs)]

    <span data-ttu-id="b397f-176">此代码仅重写`ReaderExecuting`方法，该调用可以返回多行数据的查询方法。</span><span class="sxs-lookup"><span data-stu-id="b397f-176">This code only overrides the `ReaderExecuting` method, which is called for queries that can return multiple rows of data.</span></span> <span data-ttu-id="b397f-177">如果你想要检查连接复原对于其他类型的查询，也可以重写`NonQueryExecuting`和`ScalarExecuting`方法，为日志记录侦听器未。</span><span class="sxs-lookup"><span data-stu-id="b397f-177">If you wanted to check connection resiliency for other types of queries, you could also override the `NonQueryExecuting` and `ScalarExecuting` methods, as the logging interceptor does.</span></span>

    <span data-ttu-id="b397f-178">当你运行学生页面，并输入搜索字符串形式的"引发"时，此代码将创建错误号 20，类型是已知是通常暂时性 dummy SQL 数据库异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-178">When you run the Student page and enter "Throw" as the search string, this code creates a dummy SQL Database exception for error number 20, a type known to be typically transient.</span></span> <span data-ttu-id="b397f-179">其他当前被识别为暂时性的错误号均 64、 233、 10053、 10054、 10060、 10928、 10929、 40197、 40501 和 40613，但它们是可能会有新版本的 SQL 数据库中的更改。</span><span class="sxs-lookup"><span data-stu-id="b397f-179">Other error numbers currently recognized as transient are 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501, and 40613, but these are subject to change in new versions of SQL Database.</span></span>

    <span data-ttu-id="b397f-180">该代码对 Entity Framework 而不是运行查询并通过后的查询结果返回的异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-180">The code returns the exception to Entity Framework instead of running the query and passing back query results.</span></span> <span data-ttu-id="b397f-181">暂时性异常返回四次，之后代码恢复为将查询传递给数据库的一般过程。</span><span class="sxs-lookup"><span data-stu-id="b397f-181">The transient exception is returned four times, and then the code reverts to the normal procedure of passing the query to the database.</span></span>

    <span data-ttu-id="b397f-182">记录的所有内容，因为你将能够看到实体框架尝试之后才最后成功，四次执行查询和应用程序中的唯一区别是，它使用更长时间才能呈现包含查询结果页。</span><span class="sxs-lookup"><span data-stu-id="b397f-182">Because everything is logged, you'll be able to see that Entity Framework tries to execute the query four times before finally succeeding, and the only difference in the application is that it takes longer to render a page with query results.</span></span>

    <span data-ttu-id="b397f-183">实体框架将重试次数是可配置;该代码指定四次，因为它是 SQL 数据库执行策略的默认值。</span><span class="sxs-lookup"><span data-stu-id="b397f-183">The number of times the Entity Framework will retry is configurable; the code specifies four times because that's the default value for the SQL Database execution policy.</span></span> <span data-ttu-id="b397f-184">如果更改执行策略，则必须还更改此处指定多少次暂时性错误生成的代码。</span><span class="sxs-lookup"><span data-stu-id="b397f-184">If you change the execution policy, you'd also change the code here that specifies how many times transient errors are generated.</span></span> <span data-ttu-id="b397f-185">您还可以更改代码以生成更多的异常，使实体框架将引发`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-185">You could also change the code to generate more exceptions so that Entity Framework will throw the `RetryLimitExceededException` exception.</span></span>

    <span data-ttu-id="b397f-186">在搜索框中输入的值将采用`command.Parameters[0]`和`command.Parameters[1]`（一个用于名字和姓氏的一个）。</span><span class="sxs-lookup"><span data-stu-id="b397f-186">The value you enter in the Search box will be in `command.Parameters[0]` and `command.Parameters[1]` (one is used for the first name and one for the last name).</span></span> <span data-ttu-id="b397f-187">当找到"%throw%"值时，"引发"都替换为这些参数在""，以便将找到某些学生，并将其返回。</span><span class="sxs-lookup"><span data-stu-id="b397f-187">When the value "%Throw%" is found, "Throw" is replaced in those parameters by "an" so that some students will be found and returned.</span></span>

    <span data-ttu-id="b397f-188">这是只是测试连接复原根据不断变化的应用程序 UI 的某些输入一种可方便方式。</span><span class="sxs-lookup"><span data-stu-id="b397f-188">This is just a convenient way to test connection resiliency based on changing some input to the application UI.</span></span> <span data-ttu-id="b397f-189">你也可以编写生成的所有查询或更新的暂时性错误的代码，如后面所述注释有关*DbInterception.Add*方法。</span><span class="sxs-lookup"><span data-stu-id="b397f-189">You can also write code that generates transient errors for all queries or updates, as explained later in the comments about the *DbInterception.Add* method.</span></span>
3. <span data-ttu-id="b397f-190">在*Global.asax*，添加以下`using`语句：</span><span class="sxs-lookup"><span data-stu-id="b397f-190">In *Global.asax*, add the following `using` statements:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample8.cs)]
4. <span data-ttu-id="b397f-191">添加到突出显示的行`Application_Start`方法：</span><span class="sxs-lookup"><span data-stu-id="b397f-191">Add the highlighted lines to the `Application_Start` method:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample9.cs?highlight=7-8)]

    <span data-ttu-id="b397f-192">这些代码行是什么因素会导致拦截器代码可在实体框架会将查询发送到数据库时运行。</span><span class="sxs-lookup"><span data-stu-id="b397f-192">These lines of code are what causes your interceptor code to be run when Entity Framework sends queries to the database.</span></span> <span data-ttu-id="b397f-193">请注意，因为创建单独的拦截器类进行暂时性错误模拟和日志记录，你可以单独启用和禁用它们。</span><span class="sxs-lookup"><span data-stu-id="b397f-193">Notice that because you created separate interceptor classes for transient error simulation and logging, you can independently enable and disable them.</span></span>

    <span data-ttu-id="b397f-194">你可以将拦截器添加使用`DbInterception.Add`方法任何位置中你的代码; 它不一定要处于`Application_Start`方法。</span><span class="sxs-lookup"><span data-stu-id="b397f-194">You can add interceptors using the `DbInterception.Add` method anywhere in your code; it doesn't have to be in the `Application_Start` method.</span></span> <span data-ttu-id="b397f-195">另一个选项是将此代码放置在你之前创建配置的执行策略 DbConfiguration 类。</span><span class="sxs-lookup"><span data-stu-id="b397f-195">Another option is to put this code in the DbConfiguration class that you created earlier to configure the execution policy.</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample10.cs?highlight=6-7)]

    <span data-ttu-id="b397f-196">无论你将此代码放，请注意不要执行`DbInterception.Add`对于相同的侦听器超过一次，或你将获取其他拦截器实例。</span><span class="sxs-lookup"><span data-stu-id="b397f-196">Wherever you put this code, be careful not to execute `DbInterception.Add` for the same interceptor more than once, or you'll get additional interceptor instances.</span></span> <span data-ttu-id="b397f-197">例如，如果两次添加日志记录拦截器，你将看到为每个 SQL 查询的两个日志。</span><span class="sxs-lookup"><span data-stu-id="b397f-197">For example, if you add the logging interceptor twice, you'll see two logs for every SQL query.</span></span>

    <span data-ttu-id="b397f-198">拦截器执行顺序注册 (的顺序`DbInterception.Add`调用方法)。</span><span class="sxs-lookup"><span data-stu-id="b397f-198">Interceptors are executed in the order of registration (the order in which the `DbInterception.Add` method is called).</span></span> <span data-ttu-id="b397f-199">顺序可能重要具体取决于您所做侦听器中。</span><span class="sxs-lookup"><span data-stu-id="b397f-199">The order might matter depending on what you're doing in the interceptor.</span></span> <span data-ttu-id="b397f-200">例如，侦听器可能会更改获取中的 SQL 命令`CommandText`属性。</span><span class="sxs-lookup"><span data-stu-id="b397f-200">For example, an interceptor might change the SQL command that it gets in the `CommandText` property.</span></span> <span data-ttu-id="b397f-201">如果它未更改的 SQL 命令下, 一步侦听器将获取已更改的 SQL 命令，而不是原始的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="b397f-201">If it does change the SQL command, the next interceptor will get the changed SQL command, not the original SQL command.</span></span>

    <span data-ttu-id="b397f-202">你可以通过在 UI 中输入不同的值导致暂时性错误的方式编写的暂时性错误模拟代码。</span><span class="sxs-lookup"><span data-stu-id="b397f-202">You've written the transient error simulation code in a way that lets you cause transient errors by entering a different value in the UI.</span></span> <span data-ttu-id="b397f-203">作为替代方法，你可以编写拦截器代码以始终生成暂时性异常的序列，而检查有特定的参数值。</span><span class="sxs-lookup"><span data-stu-id="b397f-203">As an alternative, you could write the interceptor code to always generate the sequence of transient exceptions without checking for a particular parameter value.</span></span> <span data-ttu-id="b397f-204">仅当你想要生成暂时性错误，然后可以添加侦听器。</span><span class="sxs-lookup"><span data-stu-id="b397f-204">You could then add the interceptor only when you want to generate transient errors.</span></span> <span data-ttu-id="b397f-205">如果这样做，但是，在数据库初始化完成后不添加直到侦听器。</span><span class="sxs-lookup"><span data-stu-id="b397f-205">If you do this, however, don't add the interceptor until after database initialization has completed.</span></span> <span data-ttu-id="b397f-206">在开始生成暂时性错误之前，换而言之，执行如查询实体集之一上的至少一个数据库操作。</span><span class="sxs-lookup"><span data-stu-id="b397f-206">In other words, do at least one database operation such as a query on one of your entity sets before you start generating transient errors.</span></span> <span data-ttu-id="b397f-207">实体框架在数据库初始化期间所执行多个查询和它们不执行在事务中，因此在初始化期间的错误可能会导致才能进入不一致状态的上下文。</span><span class="sxs-lookup"><span data-stu-id="b397f-207">The Entity Framework executes several queries during database initialization, and they aren't executed in a transaction, so errors during initialization could cause the context to get into an inconsistent state.</span></span>

## <a name="test-logging-and-connection-resiliency"></a><span data-ttu-id="b397f-208">测试日志记录和连接复原</span><span class="sxs-lookup"><span data-stu-id="b397f-208">Test logging and connection resiliency</span></span>

1. <span data-ttu-id="b397f-209">按 F5 在调试模式下运行应用程序，然后单击**学生**选项卡。</span><span class="sxs-lookup"><span data-stu-id="b397f-209">Press F5 to run the application in debug mode, and then click the **Students** tab.</span></span>
2. <span data-ttu-id="b397f-210">查看 Visual Studio**输出**窗口以查看跟踪输出。</span><span class="sxs-lookup"><span data-stu-id="b397f-210">Look at the Visual Studio **Output** window to see the tracing output.</span></span> <span data-ttu-id="b397f-211">你可能需要向上滚动过去的某些 JavaScript 错误可用于访问由你记录程序写入的日志。</span><span class="sxs-lookup"><span data-stu-id="b397f-211">You might have to scroll up past some JavaScript errors to get to the logs written by your logger.</span></span>

    <span data-ttu-id="b397f-212">请注意，你可以看到发送到数据库的实际 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="b397f-212">Notice that you can see the actual SQL queries sent to the database.</span></span> <span data-ttu-id="b397f-213">你看到的一些初始查询和实体框架执行的操作若要开始，检查该版本的数据库的命令和 （你将了解如何迁移在下一教程中） 的迁移历史记录表。</span><span class="sxs-lookup"><span data-stu-id="b397f-213">You see some initial queries and commands that Entity Framework does to get started, checking the database version and migration history table (you'll learn about migrations in the next tutorial).</span></span> <span data-ttu-id="b397f-214">和查看分页，若要了解如何很多学生，一个查询，并最后看到获取学生数据的查询。</span><span class="sxs-lookup"><span data-stu-id="b397f-214">And you see a query for paging, to find out how many students there are, and finally you see the query that gets the student data.</span></span>

    ![正常的查询的日志记录](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image1.png)
3. <span data-ttu-id="b397f-216">在**学生**页上，作为搜索字符串中，输入"引发"，单击**搜索**。</span><span class="sxs-lookup"><span data-stu-id="b397f-216">In the **Students** page, enter "Throw" as the search string, and click **Search**.</span></span>

    ![引发搜索字符串](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image2.png)

    <span data-ttu-id="b397f-218">你会注意到，浏览器看上去已挂起了几秒钟时实体框架重试查询多次。</span><span class="sxs-lookup"><span data-stu-id="b397f-218">You'll notice that the browser seems to hang for several seconds while Entity Framework is retrying the query several times.</span></span> <span data-ttu-id="b397f-219">首次重试发生速度非常快，然后之前增加每个其他的重试之前等待。</span><span class="sxs-lookup"><span data-stu-id="b397f-219">The first retry happens very quickly, then the wait before increases before each additional retry.</span></span> <span data-ttu-id="b397f-220">此过程的调用每次重试之前再等待*指数退让*。</span><span class="sxs-lookup"><span data-stu-id="b397f-220">This process of waiting longer before each retry is called *exponential backoff*.</span></span>

    <span data-ttu-id="b397f-221">当页显示时，显示学生都具有"的"在其名称中查看输出窗口中，并且您将看到相同的查询试图五次，第一次四次返回暂时性异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-221">When the page displays, showing students who have "an" in their names, look at the output window, and you'll see that the same query was attempted five times, the first four times returning transient exceptions.</span></span> <span data-ttu-id="b397f-222">对于每个暂时性错误，你将看到你编写在生成中的暂时性错误时的日志`SchoolInterceptorTransientErrors`类 （"返回暂时性错误命令..."），你将会看到日志写入时`SchoolInterceptorLogging`获取的异常。</span><span class="sxs-lookup"><span data-stu-id="b397f-222">For each transient error you'll see the log that you write when generating the transient error in the `SchoolInterceptorTransientErrors` class ("Returning transient error for command...") and you'll see the log written when `SchoolInterceptorLogging` gets the exception.</span></span>

    ![日志记录输出显示重试](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image3.png)

    <span data-ttu-id="b397f-224">由于你输入的搜索字符串，返回学生数据的查询进行参数化：</span><span class="sxs-lookup"><span data-stu-id="b397f-224">Since you entered a search string, the query that returns student data is parameterized:</span></span>

    [!code-sql[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample11.sql)]

    <span data-ttu-id="b397f-225">不日志记录的值的参数，但您可以这样做。</span><span class="sxs-lookup"><span data-stu-id="b397f-225">You're not logging the value of the parameters, but you could do that.</span></span> <span data-ttu-id="b397f-226">如果你想要查看的参数值，你可以编写日志记录代码，以获取从参数值`Parameters`属性`DbCommand`侦听器方法中获取的对象。</span><span class="sxs-lookup"><span data-stu-id="b397f-226">If you want to see the parameter values, you can write logging code to get parameter values from the `Parameters` property of the `DbCommand` object that you get in the interceptor methods.</span></span>

    <span data-ttu-id="b397f-227">请注意，不能重复此测试，除非停止应用程序并重新启动它。</span><span class="sxs-lookup"><span data-stu-id="b397f-227">Note that you can't repeat this test unless you stop the application and restart it.</span></span> <span data-ttu-id="b397f-228">如果你想要能够在应用程序的单次运行中测试连接复原多次，你可以编写代码以重置中的错误计数器`SchoolInterceptorTransientErrors`。</span><span class="sxs-lookup"><span data-stu-id="b397f-228">If you wanted to be able to test connection resiliency multiple times in a single run of the application, you could write code to reset the error counter in `SchoolInterceptorTransientErrors`.</span></span>
4. <span data-ttu-id="b397f-229">可以查看的差异 （重试策略） 的执行策略进行，注释`SetExecutionStrategy`中一行*SchoolConfiguration.cs*、 学生页在调试模式下再次运行，然后再次搜索"Throw"。</span><span class="sxs-lookup"><span data-stu-id="b397f-229">To see the difference the execution strategy (retry policy) makes, comment out the `SetExecutionStrategy` line in *SchoolConfiguration.cs*, run the Students page in debug mode again, and search for "Throw" again.</span></span>

    <span data-ttu-id="b397f-230">这一次调试器停止上第一次生成异常立即时它将尝试执行第一次的查询。</span><span class="sxs-lookup"><span data-stu-id="b397f-230">This time the debugger stops on the first generated exception immediately when it tries to execute the query the first time.</span></span>

    ![Dummy 异常](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image4.png)
5. <span data-ttu-id="b397f-232">取消注释*SetExecutionStrategy*中一行*SchoolConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="b397f-232">Uncomment the *SetExecutionStrategy* line in *SchoolConfiguration.cs*.</span></span>

## <a name="summary"></a><span data-ttu-id="b397f-233">摘要</span><span class="sxs-lookup"><span data-stu-id="b397f-233">Summary</span></span>

<span data-ttu-id="b397f-234">在本教程中，你已了解如何启用连接复原和记录的实体框架撰写并发送到数据库的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="b397f-234">In this tutorial you've seen how to enable connection resiliency and log SQL commands that Entity Framework composes and sends to the database.</span></span> <span data-ttu-id="b397f-235">在下一教程中，你将部署到 Internet，使用 Code First 迁移将数据库部署应用程序。</span><span class="sxs-lookup"><span data-stu-id="b397f-235">In the next tutorial you'll deploy the application to the Internet, using Code First Migrations to deploy the database.</span></span>

<span data-ttu-id="b397f-236">请在如何喜欢本教程的方式，我们可以提高上，留下反馈。</span><span class="sxs-lookup"><span data-stu-id="b397f-236">Please leave feedback on how you liked this tutorial and what we could improve.</span></span> <span data-ttu-id="b397f-237">你还可以请求新主题[教我编写代码](http://aspnet.uservoice.com/forums/228522-show-me-how-with-code)。</span><span class="sxs-lookup"><span data-stu-id="b397f-237">You can also request new topics at [Show Me How With Code](http://aspnet.uservoice.com/forums/228522-show-me-how-with-code).</span></span>

<span data-ttu-id="b397f-238">在找不到其他实体框架资源的链接[ASP.NET 数据访问的推荐资源](../../../../whitepapers/aspnet-data-access-content-map.md)。</span><span class="sxs-lookup"><span data-stu-id="b397f-238">Links to other Entity Framework resources can be found in [ASP.NET Data Access - Recommended Resources](../../../../whitepapers/aspnet-data-access-content-map.md).</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="b397f-239">[上一页](sorting-filtering-and-paging-with-the-entity-framework-in-an-asp-net-mvc-application.md)
[下一页](migrations-and-deployment-with-the-entity-framework-in-an-asp-net-mvc-application.md)</span><span class="sxs-lookup"><span data-stu-id="b397f-239">[Previous](sorting-filtering-and-paging-with-the-entity-framework-in-an-asp-net-mvc-application.md)
[Next](migrations-and-deployment-with-the-entity-framework-in-an-asp-net-mvc-application.md)</span></span>
