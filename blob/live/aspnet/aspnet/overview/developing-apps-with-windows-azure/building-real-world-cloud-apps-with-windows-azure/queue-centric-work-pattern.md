---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: "以队列为中心的工作模式 （使用 Azure 构建真实世界云应用） |Microsoft 文档"
author: MikeWasson
description: "构建真实世界云应用程序与 Azure 的电子书基于由 Scott Guthrie 的演示。 它还说明了 13 模式和实践，他可以..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/12/2014
ms.topic: article
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
ms.technology: 
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: 125d555a9e170ef35dd99e0409a2442d5f9ae34a
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="c4ed4-104">以队列为中心的工作模式 （使用 Azure 构建真实世界云应用）</span><span class="sxs-lookup"><span data-stu-id="c4ed4-104">Queue-Centric Work Pattern (Building Real-World Cloud Apps with Azure)</span></span>
====================
<span data-ttu-id="c4ed4-105">通过[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson](https://github.com/Rick-Anderson)， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://github.com/Rick-Anderson), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="c4ed4-106">[下载修复此错误项目](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下载电子书](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-106">[Download Fix It Project](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="c4ed4-107">**构建真实世界云应用程序与 Azure**电子书基于由 Scott Guthrie 的演示。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="c4ed4-108">它还说明了 13 模式和实践，从而帮助你为成功开发适用于云中的 web 应用。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="c4ed4-109">有关电子书的信息，请参阅[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>


<span data-ttu-id="c4ed4-110">更早版本，我们已了解使用多个服务可以导致"复合"SLA，其中应用程序的有效 SLA 是*产品*的单个 Sla。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-110">Earlier, we saw that using multiple services can result in a "composite" SLA, where the app's effective SLA is the *product* of the individual SLAs.</span></span> <span data-ttu-id="c4ed4-111">例如，修复它应用程序使用网站、 存储和 SQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-111">For example, the Fix It app uses Web Sites, Storage, and SQL Database.</span></span> <span data-ttu-id="c4ed4-112">如果这些服务的任何一个失败，则应用程序将向用户返回错误。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-112">If any one of these services fails, the app will return an error to the user.</span></span>

<span data-ttu-id="c4ed4-113">缓存是一种好的方法来处理暂时性故障只读内容。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-113">Caching is a good way to handle transient failures for read-only content.</span></span> <span data-ttu-id="c4ed4-114">但是，如果你的应用程序需要完成的工作？</span><span class="sxs-lookup"><span data-stu-id="c4ed4-114">But what if your application needs to do work?</span></span> <span data-ttu-id="c4ed4-115">例如，当用户提交新修复它任务，该应用程序不能只需将此任务放置到缓存。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-115">For example, when the user submits a new Fix It task, the app can't just put the task into the cache.</span></span> <span data-ttu-id="c4ed4-116">应用程序需要将修复它任务写入到永久性数据存储，以便它可以处理。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-116">The app needs to write the Fix It task into a persistent data store, so it can be processed.</span></span>

<span data-ttu-id="c4ed4-117">这是以队列为中心的工作模式传入的位置。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-117">That's where the queue-centric work pattern comes in.</span></span> <span data-ttu-id="c4ed4-118">此模式可让 web 层和后端服务之间的松散耦合。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-118">This pattern enables loose coupling between a web tier and a backend service.</span></span>

<span data-ttu-id="c4ed4-119">以下是模式的工作原理。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-119">Here's how the pattern works.</span></span> <span data-ttu-id="c4ed4-120">当应用程序收到请求时，它将工作项放置到队列，并立即返回响应。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-120">When the application gets a request, it puts a work item onto a queue and immediately returns the response.</span></span> <span data-ttu-id="c4ed4-121">然后单独的后端进程拉取队列中的工作项，并执行该操作。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-121">Then a separate backend process pulls work items from the queue and does the work.</span></span>

<span data-ttu-id="c4ed4-122">以队列为中心的工作模式适合用于：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-122">The queue-centric work pattern is useful for:</span></span>

- <span data-ttu-id="c4ed4-123">是耗时 （高延迟） 的工作。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-123">Work that is time consuming (high latency).</span></span>
- <span data-ttu-id="c4ed4-124">需要可能始终不可用的外部服务的工作。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-124">Work that requires an external service that might not always be available.</span></span>
- <span data-ttu-id="c4ed4-125">工作，它是资源密集型 (高 CPU)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-125">Work that is resource-intensive (high CPU).</span></span>
- <span data-ttu-id="c4ed4-126">会带来好处分级 （激增突然负载） 的速率的工作。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-126">Work that would benefit from rate leveling (subject to sudden load bursts).</span></span>

## <a name="reduced-latency"></a><span data-ttu-id="c4ed4-127">降低的延迟</span><span class="sxs-lookup"><span data-stu-id="c4ed4-127">Reduced Latency</span></span>

<span data-ttu-id="c4ed4-128">队列可任何时候执行耗时的工作。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-128">Queues are useful any time you are doing time-consuming work.</span></span> <span data-ttu-id="c4ed4-129">如果任务需要几秒钟或更长，而不是阻止最终用户，放入队列工作项。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-129">If a task takes a few seconds or longer, instead of blocking the end user, put the work item into a queue.</span></span> <span data-ttu-id="c4ed4-130">告知用户"我们正在努力解决它，"，然后使用队列侦听器以处理在后台任务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-130">Tell the user "We're working on it," and then use a queue listener to process the task in the background.</span></span>

<span data-ttu-id="c4ed4-131">例如，当你在一家网上零售商购买时，web 站点用于立即确认你的订单。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-131">For example, when you purchase something at an online retailer, the web site confirms your order immediately.</span></span> <span data-ttu-id="c4ed4-132">但这并不意味着你的资料已在卡车传递。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-132">But that doesn't mean your stuff is already in a truck being delivered.</span></span> <span data-ttu-id="c4ed4-133">它们将任务放在队列中，并在后台，它们的执行信用检查，供发运，准备你的项和等等。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-133">They put a task in a queue, and in the background they are doing the credit check, preparing your items for shipping, and so forth.</span></span>

<span data-ttu-id="c4ed4-134">对于短滞后时间的方案，总的端到端时间可能较长使用队列，相比于以同步方式执行任务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-134">For scenarios with short latency, the total end-to-end time might be longer using a queue, compared with doing the task synchronously.</span></span> <span data-ttu-id="c4ed4-135">但是，即使这样，其他好处可以超过该缺点。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-135">But even then, the other benefits can outweigh that disadvantage.</span></span>

## <a name="increased-reliability"></a><span data-ttu-id="c4ed4-136">更高的可靠性</span><span class="sxs-lookup"><span data-stu-id="c4ed4-136">Increased Reliability</span></span>

<span data-ttu-id="c4ed4-137">在修复它，则我们一直在考虑在到目前为止的版本，web 前端与 SQL 数据库后端紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-137">In the version of Fix It that we've been looking at so far, the web front-end is tightly coupled with the SQL Database back-end.</span></span> <span data-ttu-id="c4ed4-138">如果 SQL 数据库服务不可用，用户会收到错误。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-138">If the SQL database service is unavailable, the user gets an error.</span></span> <span data-ttu-id="c4ed4-139">如果重试不起作用 （也就是说，失败是暂时性多个），可以执行唯一操作是显示错误，并要求用户稍后重试。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-139">If retries don't work (that is, the failure is more than transient), the only thing you can do is show an error and ask the user to try again later.</span></span>

![关系图显示 web 前端失败的 SQL 数据库后端时失败](queue-centric-work-pattern/_static/image1.png)

<span data-ttu-id="c4ed4-141">使用队列，当用户提交修复它任务时，应用程序将消息写入队列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-141">Using queues, when a user submits a Fix It task, the app writes a message to the queue.</span></span> <span data-ttu-id="c4ed4-142">消息负载[JSON](http://json.org/)任务的表示形式。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-142">The message payload is a [JSON](http://json.org/) representation of the task.</span></span> <span data-ttu-id="c4ed4-143">一旦将消息写入到队列，该应用返回，并立即向用户显示一条成功消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-143">As soon as the message is written to the queue, the app returns and immediately shows a success message to the user.</span></span>

<span data-ttu-id="c4ed4-144">如果任何后端服务 – 例如，SQL 数据库或队列侦听器--进入脱机状态，用户仍然可以提交新修复它任务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-144">If any of the backend services – such as the SQL database or the queue listener -- go offline, users can still submit new Fix It tasks.</span></span> <span data-ttu-id="c4ed4-145">除非后端服务是再次可用，否则，只需将排队等待消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-145">The messages will just queue up until the backend services are available again.</span></span> <span data-ttu-id="c4ed4-146">此时后, 端服务将赶上积压工作上。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-146">At that point, the backend services will catch up on the backlog.</span></span>

![显示 web 前端持续运行 SQL 数据库错误时的图示](queue-centric-work-pattern/_static/image2.png)

<span data-ttu-id="c4ed4-148">此外，现在你可以添加更多的后端逻辑而无需担心前端的复原。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-148">Moreover, now you can add more backend logic without worrying about the resiliency of the front end.</span></span> <span data-ttu-id="c4ed4-149">例如，你可能想要每当新修复它分配给所有者发送电子邮件或 SMS 消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-149">For example, you might want to send an email or SMS message to the owner whenever a new Fix It is assigned.</span></span> <span data-ttu-id="c4ed4-150">如果电子邮件或 SMS 服务变为不可用，可以处理其他任何内容，并将消息放入单独的队列用于发送电子邮件/SMS 消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-150">If the email or SMS service becomes unavailable, you can process everything else, and then put a message into a separate queue for sending email/SMS messages.</span></span>

<span data-ttu-id="c4ed4-151">以前，我们有效的 SLA 是 Web Apps&times;存储&times;SQL Database = 99.7%。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-151">Previously, our effective SLA was Web Apps &times; Storage &times; SQL Database = 99.7%.</span></span> <span data-ttu-id="c4ed4-152">(请参阅[设计得以失败](design-to-survive-failures.md)。)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-152">(See [Design to Survive Failures](design-to-survive-failures.md).)</span></span>

<span data-ttu-id="c4ed4-153">当我们更改应用程序以使用队列时，web 前端只依赖于 Web 应用和存储，为复合 99.8%的 SLA。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-153">When we change the app to use a queue, the web front end depends only on Web Apps and Storage, for a composite SLA of 99.8%.</span></span> <span data-ttu-id="c4ed4-154">（请注意，队列都属于 Azure 存储服务，以便将它们包括在 blob 存储作为相同的 SLA。）</span><span class="sxs-lookup"><span data-stu-id="c4ed4-154">(Note that queues are part of the Azure storage service, so they are included in the same SLA as blob storage.)</span></span>

<span data-ttu-id="c4ed4-155">如果需要比 99.8%更理想的做法，你可以在两个不同区域中创建两个队列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-155">If you need even better than 99.8%, you can create two queues in two different regions.</span></span> <span data-ttu-id="c4ed4-156">将作为主，另一个指定为辅助数据库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-156">Designate one as the primary, and the other as the secondary.</span></span> <span data-ttu-id="c4ed4-157">在你的应用，故障转移到辅助队列未提供主队列时。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-157">In your app, fail over to the secondary queue if the primary queue is not available.</span></span> <span data-ttu-id="c4ed4-158">这两个不可在同一时间的机会是非常小。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-158">The chance of both being unavailable at the same time is very small.</span></span>

## <a name="rate-leveling-and-independent-scaling"></a><span data-ttu-id="c4ed4-159">速率分级和独立扩展性</span><span class="sxs-lookup"><span data-stu-id="c4ed4-159">Rate Leveling and Independent Scaling</span></span>

<span data-ttu-id="c4ed4-160">队列还可以用于称为*速率分级*或*负载分级*。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-160">Queues are also useful for something called *rate leveling* or *load leveling*.</span></span>

<span data-ttu-id="c4ed4-161">Web 应用程序通常都容易遭受流量的突现高峰。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-161">Web apps are often susceptible to sudden bursts in traffic.</span></span> <span data-ttu-id="c4ed4-162">尽管你可以使用自动缩放以自动添加 web 服务器来处理增加的 web 流量，自动缩放可能不能响应速度足够快处理突然峰值负载。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-162">While you can use autoscaling to automatically add web servers to handle increased web traffic, autoscaling might not be able to react quickly enough to handle abrupt spikes in load.</span></span> <span data-ttu-id="c4ed4-163">如果 web 服务器可以卸载一些操作，他们需要通过一条消息写入队列执行操作，它们可以处理更多流量。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-163">If the web servers can offload some of the work they have to do by writing a message to a queue, they can handle more traffic.</span></span> <span data-ttu-id="c4ed4-164">然后后, 端服务可以从队列中读取消息并处理它们。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-164">A backend service can then read messages from the queue and process them.</span></span> <span data-ttu-id="c4ed4-165">队列深度将扩大或收缩当传入负载变化。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-165">The depth of the queue will grow or shrink as the incoming load varies.</span></span>

<span data-ttu-id="c4ed4-166">使用其大部分耗时工作卸载到后端服务，web 层可以更轻松地响应突然出现流量高峰。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-166">With much of its time-consuming work off-loaded to a backend service, the web tier can more easily respond to sudden spikes in traffic.</span></span> <span data-ttu-id="c4ed4-167">因为任何给定的流量可以通过更少的 web 服务器来处理节省资金。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-167">And you save money because any given amount of traffic can be handled by fewer web servers.</span></span>

<span data-ttu-id="c4ed4-168">可以独立地扩展 web 层和后端服务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-168">You can scale the web tier and backend service independently.</span></span> <span data-ttu-id="c4ed4-169">例如，你可能需要三个 web 服务器，但只有一个服务器处理队列消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-169">For example, you might need three web servers but only one server processing queue messages.</span></span> <span data-ttu-id="c4ed4-170">或者，如果你在后台中运行计算密集型任务，则可能需要更多的后端服务器。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-170">Or if you're running a compute-intensive task in the background, you might need more backend servers.</span></span>

![](queue-centric-work-pattern/_static/image3.png)

<span data-ttu-id="c4ed4-171">自动缩放的工作原理与后端服务以及 web 层。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-171">Autoscaling works with backend services as well as with the web tier.</span></span> <span data-ttu-id="c4ed4-172">你可以向上扩展或缩减正在处理的任务在队列中，根据 CPU 使用情况的后端 Vm 的 Vm 数目。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-172">You can scale up or scale down the number of VMs that are processing the tasks in the queue, based on the CPU usage of the backend VMs.</span></span> <span data-ttu-id="c4ed4-173">或者，你可以基于多少项在队列中的自动缩放。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-173">Or, you can autoscale based on how many items are in a queue.</span></span> <span data-ttu-id="c4ed4-174">例如，你可以判断自动缩放来尝试保留在队列中的不超过 10 项。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-174">For example, you can tell autoscale to try to keep no more than 10 items in the queue.</span></span> <span data-ttu-id="c4ed4-175">如果队列中有 10 个以上的项，自动缩放将添加 Vm。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-175">If the queue has more than 10 items, autoscale will add VMs.</span></span> <span data-ttu-id="c4ed4-176">当它们赶上时，自动缩放将关闭额外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-176">When they catch up, autoscale will tear down the extra VMs.</span></span>

## <a name="adding-queues-to-the-fix-it-application"></a><span data-ttu-id="c4ed4-177">添加到该修补程序对其进行排队应用程序</span><span class="sxs-lookup"><span data-stu-id="c4ed4-177">Adding Queues to the Fix It Application</span></span>

<span data-ttu-id="c4ed4-178">若要实现的队列模式，我们需要更改修复它应用的两个。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-178">To implement the queue pattern, we need to make two changes to the Fix It app.</span></span>

- <span data-ttu-id="c4ed4-179">当用户提交新修复它任务时，则将此任务放置在队列中，而不是写入数据库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-179">When a user submits a new Fix It task, put the task in the queue, instead of writing it to the database.</span></span>
- <span data-ttu-id="c4ed4-180">创建处理队列中的消息的后端服务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-180">Create a back-end service that processes messages in the queue.</span></span>

<span data-ttu-id="c4ed4-181">对于队列中，我们将使用[Azure 队列存储服务](https://www.windowsazure.com/en-us/develop/net/how-to-guides/queue-service/)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-181">For the queue, we'll use the [Azure Queue Storage Service](https://www.windowsazure.com/en-us/develop/net/how-to-guides/queue-service/).</span></span> <span data-ttu-id="c4ed4-182">另一个选项是使用[Azure Service Bus](https://docs.microsoft.com/azure/service-bus/)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-182">Another option is to use [Azure Service Bus](https://docs.microsoft.com/azure/service-bus/).</span></span>

<span data-ttu-id="c4ed4-183">若要决定要使用的队列服务，请考虑您的应用程序需要发送和接收消息队列中的如何：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-183">To decide which queue service to use, consider how your app needs to send and receive the messages in the queue:</span></span>

- <span data-ttu-id="c4ed4-184">如果你有协同生产者和使用者竞争，请考虑使用 Azure 队列存储服务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-184">If you have cooperating producers and competing consumers, consider using Azure Queue Storage Service.</span></span> <span data-ttu-id="c4ed4-185">"共同完成的生成者"意味着多个进程要将消息添加到队列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-185">"Cooperating producers" means multiple processes are adding messages to a queue.</span></span> <span data-ttu-id="c4ed4-186">"使用者竞争"意味着多个进程要将消息从队列来处理，但任何给定的消息仅由一个"使用者。"</span><span class="sxs-lookup"><span data-stu-id="c4ed4-186">"Competing consumers" means multiple processes are pulling messages off the queue to process them, but any given message can only be processed by one "consumer."</span></span> <span data-ttu-id="c4ed4-187">如果你需要更大的吞吐量不是你可以使用单个队列，，使用额外的队列和/或其他存储帐户。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-187">If you need more throughput than you can get with a single queue, use additional queues and/or additional storage accounts.</span></span>
- <span data-ttu-id="c4ed4-188">如果你需要[发布/订阅模型](http://en.wikipedia.org/wiki/Publish/subscribe)，请考虑使用 Azure Service Bus 队列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-188">If you need a [publish/subscribe model](http://en.wikipedia.org/wiki/Publish/subscribe), consider using Azure Service Bus Queues.</span></span>

<span data-ttu-id="c4ed4-189">修复它应用适合协同生产者和竞争的使用者模型。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-189">The Fix It app fits the cooperating producers and competing consumers model.</span></span>

<span data-ttu-id="c4ed4-190">另一个注意事项是应用程序可用性。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-190">Another consideration is application availability.</span></span> <span data-ttu-id="c4ed4-191">队列存储服务是我们正在使用 blob 存储，因此它没有任何效果在我们的 SLA 的相同服务的一部分。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-191">The Queue Storage Service is part of the same service that we're using for blob storage, so using it has no effect on our SLA.</span></span> <span data-ttu-id="c4ed4-192">Azure Service Bus 是具有其自己的 SLA 的单独服务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-192">Azure Service Bus is a separate service with its own SLA.</span></span> <span data-ttu-id="c4ed4-193">如果我们使用 Service Bus 队列，我们必须考虑其他的 SLA 百分比，并且我们的复合 SLA 会较低。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-193">If we used Service Bus Queues, we would have to factor in an additional SLA percentage, and our composite SLA would be lower.</span></span> <span data-ttu-id="c4ed4-194">选择队列服务，请确保你了解所选应用程序可用性的影响。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-194">When you're choosing a queue service, make sure you understand the impact of your choice on application availability.</span></span> <span data-ttu-id="c4ed4-195">有关详细信息，请参阅[资源](#resources)部分。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-195">For more information, see the [Resources](#resources) section.</span></span>

## <a name="creating-queue-messages"></a><span data-ttu-id="c4ed4-196">创建队列消息</span><span class="sxs-lookup"><span data-stu-id="c4ed4-196">Creating Queue Messages</span></span>

<span data-ttu-id="c4ed4-197">若要将修复它任务放置在队列中，web 前端，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-197">To put a Fix It task on the queue, the web front end performs the following steps:</span></span>

1. <span data-ttu-id="c4ed4-198">创建[CloudQueueClient](https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx)实例。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-198">Create a [CloudQueueClient](https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) instance.</span></span> <span data-ttu-id="c4ed4-199">`CloudQueueClient`实例用于执行对队列服务的请求。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-199">The `CloudQueueClient` instance is used to execute requests against the Queue Service.</span></span>
2. <span data-ttu-id="c4ed4-200">创建队列，如果它尚不存在。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-200">Create the queue, if it doesn't exist yet.</span></span>
3. <span data-ttu-id="c4ed4-201">序列化修复它任务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-201">Serialize the Fix It task.</span></span>
4. <span data-ttu-id="c4ed4-202">调用[CloudQueue.AddMessageAsync](https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx)以将消息放到队列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-202">Call [CloudQueue.AddMessageAsync](https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) to put the message onto the queue.</span></span>

<span data-ttu-id="c4ed4-203">我们将执行此构造函数中的工作和`SendMessageAsync`方法的一个新`FixItQueueManager`类。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-203">We'll do this work in the constructor and `SendMessageAsync` method of a new `FixItQueueManager` class.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

<span data-ttu-id="c4ed4-204">此处我们将使用[Json.NET](https://github.com/JamesNK/Newtonsoft.Json)要序列化到 JSON 格式 fixit 库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-204">Here we are using the [Json.NET](https://github.com/JamesNK/Newtonsoft.Json) library to serialize the fixit to JSON format.</span></span> <span data-ttu-id="c4ed4-205">你可以使用任何您喜欢的序列化方法。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-205">You can use whatever serialization approach you prefer.</span></span> <span data-ttu-id="c4ed4-206">JSON 采用的优点，用户可读，但比 XML。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-206">JSON has the advantage of being human-readable, while being less verbose than XML.</span></span>

<span data-ttu-id="c4ed4-207">生产高质量代码将添加错误处理逻辑，暂停如果数据库变得不可用、 更完全处理恢复、 应用程序启动时创建队列和管理"[有害"消息](https://msdn.microsoft.com/en-us/library/ms789028(v=vs.110).aspx)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-207">Production-quality code would add error handling logic, pause if the database became unavailable, handle recovery more cleanly, create the queue on application start-up, and manage "[poison" messages](https://msdn.microsoft.com/en-us/library/ms789028(v=vs.110).aspx).</span></span> <span data-ttu-id="c4ed4-208">（病毒消息是由于某种原因无法处理的消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-208">(A poison message is a message that cannot be processed for some reason.</span></span> <span data-ttu-id="c4ed4-209">你不希望病毒消息发送到队列，其中辅助角色将不断尝试处理它们、 失败、 再试一次、 失败，和等。）</span><span class="sxs-lookup"><span data-stu-id="c4ed4-209">You don't want poison messages to sit in the queue, where the worker role will continually try to process them, fail, try again, fail, and so on.)</span></span>

<span data-ttu-id="c4ed4-210">在前端 MVC 应用程序，我们需要更新创建新任务的代码。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-210">In the front-end MVC application, we need to update the code that creates a new task.</span></span> <span data-ttu-id="c4ed4-211">而不是将任务放入存储库，调用`SendMessageAsync`上面所示方法。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-211">Instead of putting the task into the repository, call the `SendMessageAsync` method shown above.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a><span data-ttu-id="c4ed4-212">处理队列消息</span><span class="sxs-lookup"><span data-stu-id="c4ed4-212">Processing Queue Messages</span></span>

<span data-ttu-id="c4ed4-213">若要处理队列中的消息，我们将创建的后端服务。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-213">To process messages in the queue, we'll create a backend service.</span></span> <span data-ttu-id="c4ed4-214">后端服务将运行一个无限循环，执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-214">The backend service will run an infinite loop that performs the following steps:</span></span>

1. <span data-ttu-id="c4ed4-215">从队列中获取下一条消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-215">Get the next message from the queue.</span></span>
2. <span data-ttu-id="c4ed4-216">反序列化到修复它任务的消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-216">Deserialize the message to a Fix It task.</span></span>
3. <span data-ttu-id="c4ed4-217">修复它任务写入数据库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-217">Write the Fix It task to the database.</span></span>

<span data-ttu-id="c4ed4-218">若要托管后端服务，我们将创建 Azure 云服务包含*辅助角色*。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-218">To host the backend service, we'll create an Azure Cloud Service that contains a *worker role*.</span></span> <span data-ttu-id="c4ed4-219">辅助角色包含可以执行后端处理的一个或多个 Vm。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-219">A worker role consists of one or more VMs that can do backend processing.</span></span> <span data-ttu-id="c4ed4-220">在这些 Vm 中运行的代码将请求在变得可用队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-220">The code that runs in these VMs will pull messages from the queue as they become available.</span></span> <span data-ttu-id="c4ed4-221">对于每个消息中，我们将反序列化 JSON 负载，并将修复它任务实体的实例写入到数据库，使用我们之前在 web 层中使用相同的存储库。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-221">For each message, we'll deserialize the JSON payload and write an instance of the Fix It Task entity to the database, using the same repository that we used earlier in the web tier.</span></span>

<span data-ttu-id="c4ed4-222">以下步骤演示如何将工作人员添加到具有标准 web 项目的解决方案的角色项目。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-222">The following steps show how to add a worker role project to a solution that has a standard web project.</span></span> <span data-ttu-id="c4ed4-223">已修复它在项目中，你可以下载完成这些步骤。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-223">These steps have already been done in the Fix It project that you can download.</span></span>

<span data-ttu-id="c4ed4-224">首先将云服务项目添加到 Visual Studio 解决方案。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-224">First add a Cloud Service project to the Visual Studio solution.</span></span> <span data-ttu-id="c4ed4-225">右键单击解决方案并选择**添加**，然后**新项目**。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-225">Right-click the solution and select **Add**, then **New Project**.</span></span> <span data-ttu-id="c4ed4-226">在左窗格中，展开**Visual C#**和选择**云**。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-226">In the left pane, expand **Visual C#** and select **Cloud**.</span></span>

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

<span data-ttu-id="c4ed4-227">在**新建 Azure 云服务**对话框中，展开**Visual C#**左窗格中的节点。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-227">In the **New Azure Cloud Service** dialog, expand the **Visual C#** node on the left pane.</span></span> <span data-ttu-id="c4ed4-228">选择**辅助角色**，然后单击右箭头图标。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-228">Select **Worker Role** and click the right-arrow icon.</span></span>

![](queue-centric-work-pattern/_static/image6.png)

<span data-ttu-id="c4ed4-229">(请注意，你还可以添加*web 角色*。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-229">(Notice that you can also add a *web role*.</span></span> <span data-ttu-id="c4ed4-230">我们无法修复它前端相同的云服务，而不是运行它在 Azure 网站中运行。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-230">We could run the Fix It front-end in the same Cloud Service instead of running it in an Azure Web Site.</span></span> <span data-ttu-id="c4ed4-231">具有一些优势中使前端和后端之间的连接更方便地协调。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-231">That has some advantages in making connections between front-end and back-end easier to coordinate.</span></span> <span data-ttu-id="c4ed4-232">但是，为了简化本演示，我们要保持前端在 Azure App Service Web 应用并且仅在云服务中运行后端。）</span><span class="sxs-lookup"><span data-stu-id="c4ed4-232">However, to keep this demo simple, we're keeping the front-end in an Azure App Service Web App and only running the back-end in a Cloud Service.)</span></span>

<span data-ttu-id="c4ed4-233">默认名称分配给辅助角色。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-233">A default name is assigned to the worker role.</span></span> <span data-ttu-id="c4ed4-234">若要更改名称，将鼠标悬停在右窗格中，辅助角色，然后单击铅笔图标。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-234">To change the name, hover the mouse over the worker role in the right pane, then click the pencil icon.</span></span>

![](queue-centric-work-pattern/_static/image7.png)

<span data-ttu-id="c4ed4-235">单击**确定**以完成对话框。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-235">Click **OK** to complete the dialog.</span></span> <span data-ttu-id="c4ed4-236">这会将两个项目添加到 Visual Studio 解决方案。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-236">This adds two projects to the Visual Studio solution.</span></span>

- <span data-ttu-id="c4ed4-237">Azure 项目定义云服务，包括配置信息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-237">an Azure project that defines the cloud service, including configuration information.</span></span>
- <span data-ttu-id="c4ed4-238">辅助角色项目，定义辅助角色。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-238">A worker role project that defines the worker role.</span></span>

![](queue-centric-work-pattern/_static/image8.png)

<span data-ttu-id="c4ed4-239">有关详细信息，请参阅[使用 Visual Studio 创建 Azure 项目。](https://msdn.microsoft.com/en-us/library/windowsazure/ee405487.aspx)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-239">For more information, see [Creating an Azure Project with Visual Studio.](https://msdn.microsoft.com/en-us/library/windowsazure/ee405487.aspx)</span></span>

<span data-ttu-id="c4ed4-240">在辅助角色中，我们轮询消息通过调用`ProcessMessageAsync`方法`FixItQueueManager`我们前面看到的类。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-240">Inside the worker role, we poll for messages by calling the `ProcessMessageAsync` method of the `FixItQueueManager` class that we saw earlier.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

<span data-ttu-id="c4ed4-241">`ProcessMessagesAsync`方法检查是否正在等待消息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-241">The `ProcessMessagesAsync` method checks if there's a message waiting.</span></span> <span data-ttu-id="c4ed4-242">如果没有一个，反序列化到消息`FixItTask`实体，并将该实体保存在数据库中。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-242">If there is one, it deserializes the message into a `FixItTask` entity and saves the entity in the database.</span></span> <span data-ttu-id="c4ed4-243">它循环，直到队列为空。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-243">It loops until the queue is empty.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

<span data-ttu-id="c4ed4-244">轮询的队列消息会产生少量的事务进行收费，因此，如果没有消息等待处理，辅助角色的`RunAsync`方法等待第二个轮询之前再次通过调用`Task.Delay(1000)`。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-244">Polling for queue messages incurs a small transaction charge, so when there's no message waiting to be processed, the worker role's `RunAsync` method waits a second before polling again by calling `Task.Delay(1000)`.</span></span>

<span data-ttu-id="c4ed4-245">在 web 项目中，添加异步代码可以自动提高性能，因为 IIS 管理有限的线程池。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-245">In a web project, adding asynchronous code can automatically improve performance because IIS manages a limited thread pool.</span></span> <span data-ttu-id="c4ed4-246">即不是这种情况在辅助角色项目。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-246">That is not the case in a worker role project.</span></span> <span data-ttu-id="c4ed4-247">若要提高可伸缩性的辅助角色，你可以编写多线程的代码，或使用异步代码来实现[并行编程](https://msdn.microsoft.com/en-us/library/ff963553.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-247">To improve scalability of the worker role, you can write multi-threaded code or use asynchronous code to implement [parallel programming](https://msdn.microsoft.com/en-us/library/ff963553.aspx).</span></span> <span data-ttu-id="c4ed4-248">此示例未实现的并行编程，但演示如何使代码异步，因此您可以实施并行编程。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-248">The sample doesn't implement parallel programming but shows how to make the code asynchronous so you can implement parallel programming.</span></span>

## <a name="summary"></a><span data-ttu-id="c4ed4-249">摘要</span><span class="sxs-lookup"><span data-stu-id="c4ed4-249">Summary</span></span>

<span data-ttu-id="c4ed4-250">在本章中，你已了解如何通过实现以队列为中心的工作模式来提高应用程序响应能力、 可靠性和可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-250">In this chapter you've seen how to improve application responsiveness, reliability, and scalability by implementing the queue-centric work pattern.</span></span>

<span data-ttu-id="c4ed4-251">这是此电子书中介绍的 13 模式的最后一个但当然还有许多其他模式和实践，从而帮助你生成成功的云应用程序。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-251">This is the last of the 13 patterns covered in this e-book, but there are of course many other patterns and practices that can help you build successful cloud apps.</span></span> <span data-ttu-id="c4ed4-252">[最后一章](more-patterns-and-guidance.md)的主题，尚未已涉及的这些 13 模式提供的资源的链接。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-252">The [final chapter](more-patterns-and-guidance.md) provides links to resources for topics that haven't been covered in these 13 patterns.</span></span>

<a id="resources"></a>
## <a name="resources"></a><span data-ttu-id="c4ed4-253">资源</span><span class="sxs-lookup"><span data-stu-id="c4ed4-253">Resources</span></span>

<span data-ttu-id="c4ed4-254">有关队列的详细信息，请参阅以下资源。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-254">For more information about queues, see the following resources.</span></span>

<span data-ttu-id="c4ed4-255">文档：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-255">Documentation:</span></span>

- <span data-ttu-id="c4ed4-256">[Microsoft Azure 存储队列第 1 部分： 入门](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-256">[Microsoft Azure Storage Queues Part 1: Getting Started](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/).</span></span> <span data-ttu-id="c4ed4-257">通过罗马 Schacherl 的文章。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-257">Article by Roman Schacherl.</span></span>
- <span data-ttu-id="c4ed4-258">[执行后台任务](https://msdn.microsoft.com/en-us/library/ff803365.aspx)的第 5 章[移动应用程序迁移到云，第三版](https://msdn.microsoft.com/en-us/library/ff728592.aspx)从 Microsoft 模式和实践。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-258">[Executing Background Tasks](https://msdn.microsoft.com/en-us/library/ff803365.aspx), chapter 5 of [Moving Applications to the Cloud, 3rd Edition](https://msdn.microsoft.com/en-us/library/ff728592.aspx) from Microsoft Patterns and Practices.</span></span> <span data-ttu-id="c4ed4-259">(具体而言，部分["使用 Azure 存储队列"](https://msdn.microsoft.com/en-us/library/ff803365.aspx#sec7)。)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-259">(In particular, the section ["Using Azure Storage Queues"](https://msdn.microsoft.com/en-us/library/ff803365.aspx#sec7).)</span></span>
- <span data-ttu-id="c4ed4-260">[最大程度提高可伸缩性和成本的效率的 Azure 上的基于队列的消息传送解决方案的最佳做法](https://msdn.microsoft.com/en-us/library/windowsazure/hh697709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-260">[Best Practices for Maximizing Scalability and Cost Effectiveness of Queue-Based Messaging Solutions on Azure](https://msdn.microsoft.com/en-us/library/windowsazure/hh697709.aspx).</span></span> <span data-ttu-id="c4ed4-261">通过 Valery Mizonov 白皮书。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-261">White paper by Valery Mizonov.</span></span>
- <span data-ttu-id="c4ed4-262">[比较 Azure 队列和 Service Bus 队列](https://msdn.microsoft.com/en-us/magazine/jj159884.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-262">[Comparing Azure Queues and Service Bus Queues](https://msdn.microsoft.com/en-us/magazine/jj159884.aspx).</span></span> <span data-ttu-id="c4ed4-263">MSDN 杂志文章提供了可帮助您选择要使用的队列服务的其他信息。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-263">MSDN Magazine article, provides additional information that can help you choose which queue service to use.</span></span> <span data-ttu-id="c4ed4-264">本文提及 Service Bus 是依赖于 ACS 进行身份验证，这意味着 ACS 不可用时，你的 SB 队列也将不可用。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-264">The article mentions that Service Bus is dependent on ACS for authentication, which means your SB queues would be unavailable when ACS is unavailable.</span></span> <span data-ttu-id="c4ed4-265">但是，由于在撰写本文时，SB 已进行更改以使你能够使用[SAS 令牌](https://msdn.microsoft.com/en-us/library/windowsazure/dn170477.aspx)作为 ACS 的替代方法。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-265">However, since the article was written, SB was changed to enable you to use [SAS tokens](https://msdn.microsoft.com/en-us/library/windowsazure/dn170477.aspx) as an alternative to ACS.</span></span>
- <span data-ttu-id="c4ed4-266">[Microsoft 模式和实践-Azure 指南](https://msdn.microsoft.com/en-us/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-266">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/en-us/library/dn568099.aspx).</span></span> <span data-ttu-id="c4ed4-267">请参阅异步消息传送入门、 管道和筛选器模式、 补偿事务模式、 使用者竞争模式、 CQRS 模式。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-267">See Asynchronous Messaging primer, Pipes and Filters pattern, Compensating Transaction pattern, Competing Consumers pattern, CQRS pattern.</span></span>
- <span data-ttu-id="c4ed4-268">[CQRS 旅程](https://msdn.microsoft.com/en-us/library/jj554200)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-268">[CQRS Journey](https://msdn.microsoft.com/en-us/library/jj554200).</span></span> <span data-ttu-id="c4ed4-269">有关 Microsoft 模式与实践中的 CQRS 电子书。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-269">E-book about CQRS by Microsoft Patterns and Practices.</span></span>

<span data-ttu-id="c4ed4-270">视频：</span><span class="sxs-lookup"><span data-stu-id="c4ed4-270">Video:</span></span>

- <span data-ttu-id="c4ed4-271">[防故障： 构建可扩展、 有弹性的云服务](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-271">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="c4ed4-272">通过 Ulrich Homann、 Marc Mercuri 和 Mark Simms 九一部分视频系列。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-272">Nine-part video series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="c4ed4-273">高级概念和体系结构原理以非常可访问且有趣方式，提供与 Microsoft 客户咨询团队 (CAT) 体验与实际客户从绘制的情景。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-273">Presents high-level concepts and architectural principles in a very accessible and interesting way, with stories drawn from Microsoft Customer Advisory Team (CAT) experience with actual customers.</span></span> <span data-ttu-id="c4ed4-274">有关 Azure 存储服务和队列的介绍，请参阅段 5 开始 35:13。</span><span class="sxs-lookup"><span data-stu-id="c4ed4-274">For an introduction to the Azure Storage service and queues, see episode 5 starting at 35:13.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="c4ed4-275">[上一页](distributed-caching.md)
[下一页](more-patterns-and-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="c4ed4-275">[Previous](distributed-caching.md)
[Next](more-patterns-and-guidance.md)</span></span>
