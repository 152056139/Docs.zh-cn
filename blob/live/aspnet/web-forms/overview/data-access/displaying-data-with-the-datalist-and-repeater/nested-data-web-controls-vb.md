---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
title: "嵌套的数据 Web 控件 (VB) |Microsoft 文档"
author: rick-anderson
description: "在本教程中我们将探讨如何使用中继器嵌套在另一个转发器。 示例将演示如何以填充这两个 d 的内部中继器..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 09/13/2006
ms.topic: article
ms.assetid: 8b7fcf7b-722b-498d-a4e4-7c93701e0c95
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
msc.type: authoredcontent
ms.openlocfilehash: 944f208d6fe4f9fde13b530fb236ecc69ff5e9cd
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="nested-data-web-controls-vb"></a><span data-ttu-id="b4377-104">嵌套的数据 Web 控件 (VB)</span><span class="sxs-lookup"><span data-stu-id="b4377-104">Nested Data Web Controls (VB)</span></span>
====================
<span data-ttu-id="b4377-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="b4377-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="b4377-106">[下载示例应用程序](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe)或[下载 PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="b4377-106">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) or [Download PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span></span>

> <span data-ttu-id="b4377-107">在本教程中我们将探讨如何使用中继器嵌套在另一个转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="b4377-108">示例将演示如何同时以声明方式和以编程方式填充内部的转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


## <a name="introduction"></a><span data-ttu-id="b4377-109">介绍</span><span class="sxs-lookup"><span data-stu-id="b4377-109">Introduction</span></span>

<span data-ttu-id="b4377-110">除了静态 HTML 和数据绑定语法中，模板还可以包含 Web 控件和用户控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="b4377-111">这些 Web 控件可以有其属性分配通过声明性、 数据绑定语法，或可在相应的服务器端事件处理程序以编程方式访问。</span><span class="sxs-lookup"><span data-stu-id="b4377-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="b4377-112">通过将嵌入在模板中的控件，可以自定义和改进后的外观和用户体验。</span><span class="sxs-lookup"><span data-stu-id="b4377-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="b4377-113">例如，在[GridView 控件中使用 TemplateFields](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md)教程，我们已了解如何通过添加一个日历控件中以显示雇员雇佣日期为 TemplateField; 自定义 GridView 的显示[添加验证控件的编辑和插入接口到](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)和[自定义的数据修改界面](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md)教程，我们已了解如何自定义编辑和插入接口通过添加验证控件、 文本框、 DropDownLists 和其他 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="b4377-114">模板还可以包含其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="b4377-115">这就是，我们可以具有其模板中包含另一个 DataList （或转发器或 GridView 或说明，依次类推） DataList。</span><span class="sxs-lookup"><span data-stu-id="b4377-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="b4377-116">与此类接口的挑战适当的数据绑定到 Web 控件的内部数据。</span><span class="sxs-lookup"><span data-stu-id="b4377-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="b4377-117">有几种不同方法可用，范围从使用到编程的对象数据源的声明性选项。</span><span class="sxs-lookup"><span data-stu-id="b4377-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="b4377-118">在本教程中我们将探讨如何使用中继器嵌套在另一个转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="b4377-119">外部转发器将包含在数据库中，每个类别的项显示的类别的名称和描述。</span><span class="sxs-lookup"><span data-stu-id="b4377-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="b4377-120">每个类别项 s 内部转发器将显示属于该类别的每个产品信息 （请参见图 1） 中的项目符号列表。</span><span class="sxs-lookup"><span data-stu-id="b4377-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="b4377-121">我们的示例将说明如何同时以声明方式和以编程方式填充内部的转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>


<span data-ttu-id="b4377-122">[![列出其产品，每个类别](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="b4377-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span></span>

<span data-ttu-id="b4377-123">**图 1**： 每个类别，以及其产品，列出 ([单击以查看实际尺寸的图像](nested-data-web-controls-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="b4377-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-vb/_static/image3.png))</span></span>


## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="b4377-124">步骤 1： 创建类别列表</span><span class="sxs-lookup"><span data-stu-id="b4377-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="b4377-125">当生成使用的页嵌套数据 Web 控件时，我有所设计、 创建和测试最外面的数据的 Web 控件第一次，而无需甚至担心内部嵌套的控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="b4377-126">因此，让我们来开始通过浏览到列出的名称和描述每个类别的页面添加中继器所必需的步骤。</span><span class="sxs-lookup"><span data-stu-id="b4377-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="b4377-127">首先打开`NestedControls.aspx`页面`DataListRepeaterBasics`文件夹并将重复器控件添加到页上，设置其`ID`属性`CategoryList`。</span><span class="sxs-lookup"><span data-stu-id="b4377-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="b4377-128">从转发器 s 智能标记中，选择创建名为新 ObjectDataSource `CategoriesDataSource`。</span><span class="sxs-lookup"><span data-stu-id="b4377-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>


<span data-ttu-id="b4377-129">[![命名新 ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="b4377-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span></span>

<span data-ttu-id="b4377-130">**图 2**： 命名新 ObjectDataSource `CategoriesDataSource` ([单击以查看实际尺寸的图像](nested-data-web-controls-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="b4377-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-vb/_static/image6.png))</span></span>


<span data-ttu-id="b4377-131">配置对象数据源，以便它将从其数据`CategoriesBLL`类的`GetCategories`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>


<span data-ttu-id="b4377-132">[![配置对象数据源以使用 CategoriesBLL 类的 GetCategories 方法](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="b4377-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span></span>

<span data-ttu-id="b4377-133">**图 3**： 配置使用 ObjectDataSource`CategoriesBLL`类 s`GetCategories`方法 ([单击以查看实际尺寸的图像](nested-data-web-controls-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="b4377-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-vb/_static/image9.png))</span></span>


<span data-ttu-id="b4377-134">若要指定中继器的模板内容我们需要转至源视图，手动输入的声明性语法。</span><span class="sxs-lookup"><span data-stu-id="b4377-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="b4377-135">添加`ItemTemplate`显示中的类别的名称`<h4>`元素和段落元素中的类别的说明 (`<p>`)。</span><span class="sxs-lookup"><span data-stu-id="b4377-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="b4377-136">此外，让 s 分隔每个类别与水平规则 (`<hr>`)。</span><span class="sxs-lookup"><span data-stu-id="b4377-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="b4377-137">进行这些更改后你页面应类似于以下的 ObjectDataSource 转发器以及包含声明性语法：</span><span class="sxs-lookup"><span data-stu-id="b4377-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample1.aspx)]

<span data-ttu-id="b4377-138">图 4 显示我们通过浏览器查看时的进度。</span><span class="sxs-lookup"><span data-stu-id="b4377-138">Figure 4 shows our progress when viewed through a browser.</span></span>


<span data-ttu-id="b4377-139">[![每个类别名称和描述列出了，隔开水平标尺](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="b4377-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span></span>

<span data-ttu-id="b4377-140">**图 4**： 每个类别的名称和描述列出了，之间用水平标尺分隔 ([单击以查看实际尺寸的图像](nested-data-web-controls-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="b4377-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-vb/_static/image12.png))</span></span>


## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="b4377-141">步骤 2： 添加嵌套的产品中继器</span><span class="sxs-lookup"><span data-stu-id="b4377-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="b4377-142">列出完成类别，我们的下一个任务是添加到中继器`CategoryList`s`ItemTemplate`显示有关这些产品属于相应的类别的信息。</span><span class="sxs-lookup"><span data-stu-id="b4377-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="b4377-143">有多种方式我们可以为此内部的转发器，其中两个我们很快就会检索数据。</span><span class="sxs-lookup"><span data-stu-id="b4377-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="b4377-144">现在，让 s 只需创建转发器的产品内`CategoryList`中继器的`ItemTemplate`。</span><span class="sxs-lookup"><span data-stu-id="b4377-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="b4377-145">具体来说，让具有产品符号列表中的每个产品与每个列表项包括产品的名称和价格的转发器显示的 s。</span><span class="sxs-lookup"><span data-stu-id="b4377-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="b4377-146">若要创建此转发器，我们需要手动输入内部转发器 s 声明性语法和模板到`CategoryList`s `ItemTemplate`。</span><span class="sxs-lookup"><span data-stu-id="b4377-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="b4377-147">添加以下标记内的`CategoryList`中继器的`ItemTemplate`:</span><span class="sxs-lookup"><span data-stu-id="b4377-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="b4377-148">步骤 3： 绑定到 ProductsByCategoryList 转发器的特定于类别的产品</span><span class="sxs-lookup"><span data-stu-id="b4377-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="b4377-149">如果此时访问通过浏览器页面，你的屏幕将图与图 4 中的相同因为我们已尚未将任何数据绑定到转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="b4377-150">有几种方法，我们可以通过抓取适当的产品记录和将其绑定到转发器，它比其他一些更高效。</span><span class="sxs-lookup"><span data-stu-id="b4377-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="b4377-151">此处的主要难题获取相应的产品为指定类别。</span><span class="sxs-lookup"><span data-stu-id="b4377-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="b4377-152">要将绑定到内部的转发器控件的数据可以访问以声明方式，通过在 ObjectDataSource`CategoryList`中继器的`ItemTemplate`，或通过编程方式，从 ASP.NET 页的代码隐藏页。</span><span class="sxs-lookup"><span data-stu-id="b4377-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="b4377-153">同样，此数据可绑定到内部中继器或者以声明方式-通过内部中继器 s`DataSourceID`属性或通过声明性数据绑定语法或以编程方式通过引用在内部中继器`CategoryList`中继器 s`ItemDataBound`事件处理程序，以编程方式设置其`DataSource`属性，并调用其`DataBind()`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="b4377-154">让我们来探讨每一个这些方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="b4377-155">使用访问数据以声明方式 ObjectDataSource 控件和`ItemDataBound`事件处理程序</span><span class="sxs-lookup"><span data-stu-id="b4377-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="b4377-156">因为我们已使用在本系列教程的此示例继续使用对象数据源访问数据的最简单选择整个广泛 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="b4377-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="b4377-157">`ProductsBLL`类具有`GetProductsByCategoryID(categoryID)`返回属于指定这些产品有关的信息的方法 *`categoryID`* 。</span><span class="sxs-lookup"><span data-stu-id="b4377-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="b4377-158">因此，我们可以将添加到 ObjectDataSource`CategoryList`中继器的`ItemTemplate`和将其配置为从此类的方法访问其数据。</span><span class="sxs-lookup"><span data-stu-id="b4377-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="b4377-159">遗憾的是，转发器不允许其模板编辑通过设计视图中，因此我们需要手动添加此 ObjectDataSource 控件的声明性语法。</span><span class="sxs-lookup"><span data-stu-id="b4377-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="b4377-160">下面的语法演示`CategoryList`中继器 s`ItemTemplate`添加此新对象数据源后 (`ProductsByCategoryDataSource`):</span><span class="sxs-lookup"><span data-stu-id="b4377-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample3.aspx)]

<span data-ttu-id="b4377-161">我们使用 ObjectDataSource 方法时需要设置`ProductsByCategoryList`中继器 s`DataSourceID`属性`ID`的 ObjectDataSource (`ProductsByCategoryDataSource`)。</span><span class="sxs-lookup"><span data-stu-id="b4377-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="b4377-162">此外，请注意，我们 ObjectDataSource 具有`<asp:Parameter>`指定的元素 *`categoryID`* 值将传递到`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="b4377-163">但是，我们如何指定此值？</span><span class="sxs-lookup"><span data-stu-id="b4377-163">But how do we specify this value?</span></span> <span data-ttu-id="b4377-164">理想情况下，我们 d 能够只需设置`DefaultValue`属性`<asp:Parameter>`元素使用数据绑定的语法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b4377-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample4.aspx)]

<span data-ttu-id="b4377-165">遗憾的是，数据绑定语法才有效中具有的控件`DataBinding`事件。</span><span class="sxs-lookup"><span data-stu-id="b4377-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="b4377-166">`Parameter`的类没有此类事件，并因此上面的语法是非法的将导致运行时错误。</span><span class="sxs-lookup"><span data-stu-id="b4377-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="b4377-167">若要设置此值，我们需要创建的事件处理程序`CategoryList`中继器的`ItemDataBound`事件。</span><span class="sxs-lookup"><span data-stu-id="b4377-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="b4377-168">回想一下，`ItemDataBound`事件触发一次每个项绑定到转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="b4377-169">因此，对于外部转发器会激发此事件每次我们可以分配当前`CategoryID`值赋给`ProductsByCategoryDataSource`ObjectDataSource 的`CategoryID`参数。</span><span class="sxs-lookup"><span data-stu-id="b4377-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="b4377-170">创建的事件处理程序`CategoryList`中继器的`ItemDataBound`事件替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="b4377-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample5.vb)]

<span data-ttu-id="b4377-171">通过确保我们重新处理数据项而不是页眉、 页脚或分隔符项启动此事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="b4377-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="b4377-172">接下来，我们引用的实际`CategoriesRow`刚刚已绑定到当前的实例`RepeaterItem`。</span><span class="sxs-lookup"><span data-stu-id="b4377-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="b4377-173">最后，我们引用中的 ObjectDataSource`ItemTemplate`并分配其`CategoryID`参数值以`CategoryID`的当前`RepeaterItem`。</span><span class="sxs-lookup"><span data-stu-id="b4377-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="b4377-174">与此事件处理程序中，`ProductsByCategoryList`在每个转发器`RepeaterItem`绑定到这些产品`RepeaterItem`的类别。</span><span class="sxs-lookup"><span data-stu-id="b4377-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="b4377-175">图 5 显示生成的输出的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="b4377-175">Figure 5 shows a screen shot of the resulting output.</span></span>


<span data-ttu-id="b4377-176">[![外部中继器列出每个类别;内部一个列出该类别的产品](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="b4377-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span></span>

<span data-ttu-id="b4377-177">**图 5**: 外部中继器列出每个类别; 内部一个列出该类别的产品 ([单击以查看实际尺寸的图像](nested-data-web-controls-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="b4377-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-vb/_static/image15.png))</span></span>


## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="b4377-178">以编程方式访问通过类别数据的产品</span><span class="sxs-lookup"><span data-stu-id="b4377-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="b4377-179">而不是使用对象数据源检索当前的类别的产品，我们可以创建一种方法，在我们 ASP.NET 页的代码隐藏类 (或在`App_Code`文件夹或单独的类库项目中) 返回的相应的一组当传入的产品`CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="b4377-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="b4377-180">假设我们在我们 ASP.NET 页的代码隐藏类有这样的方法，该主题名为`GetProductsInCategory(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="b4377-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="b4377-181">使用此方法就地我们无法将当前的类别的产品绑定到内部的转发器，使用下面的声明性语法：</span><span class="sxs-lookup"><span data-stu-id="b4377-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>


[!code-aspx[Main](nested-data-web-controls-vb/samples/sample6.aspx)]

<span data-ttu-id="b4377-182">转发器 s`DataSource`属性使用的数据绑定语法来指示其数据来自于`GetProductsInCategory(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="b4377-183">由于`Eval("CategoryID")`返回类型的值`Object`，我们将对象转换为`Integer`然后再将传递到`GetProductsInCategory(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="b4377-184">请注意，`CategoryID`访问下面的语法是通过数据绑定`CategoryID`中*外部*转发器 (`CategoryList`)，一个 s 绑定到的记录`Categories`表。</span><span class="sxs-lookup"><span data-stu-id="b4377-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="b4377-185">因此，我们知道`CategoryID`不能为数据库`NULL`值，该值是我们可以隐式强制转换的原因`Eval`方法而不会检查如果我们重新处理`DBNull`。</span><span class="sxs-lookup"><span data-stu-id="b4377-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="b4377-186">使用此方法，我们需要创建`GetProductsInCategory(categoryID)`方法并让它检索相应的一组给定所提供的产品 *`categoryID`* 。</span><span class="sxs-lookup"><span data-stu-id="b4377-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="b4377-187">我们可以执行此操作通过只需返回`ProductsDataTable`返回`ProductsBLL`类的`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="b4377-188">让我们来创建`GetProductsInCategory(categoryID)`方法中的代码隐藏类我们`NestedControls.aspx`页。</span><span class="sxs-lookup"><span data-stu-id="b4377-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="b4377-189">此使用下面的代码：</span><span class="sxs-lookup"><span data-stu-id="b4377-189">Do so using the following code:</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample7.vb)]

<span data-ttu-id="b4377-190">此方法只需创建的一个实例`ProductsBLL`方法并返回的结果`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="b4377-191">请注意该方法必须标记为`Public`或`Protected`; 如果该方法标记为`Private`，它将不能从 ASP.NET 页 s 声明性标记访问。</span><span class="sxs-lookup"><span data-stu-id="b4377-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="b4377-192">进行这些更改，以使用此新方法后，花些时间查看通过浏览器的页。</span><span class="sxs-lookup"><span data-stu-id="b4377-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="b4377-193">使用对象数据源时，输出应为相同到输出和`ItemDataBound`事件处理程序方法 （回头参考图 5 显示屏幕截图中）。</span><span class="sxs-lookup"><span data-stu-id="b4377-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="b4377-194">它可能看上去东西而加以排斥创建`GetProductsInCategory(categoryID)`在 ASP.NET 页的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="b4377-195">毕竟，此方法只需创建的一个实例`ProductsBLL`类，并返回的结果其`GetProductsByCategoryID(categoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="b4377-196">为什么不只需调用此方法直接从内部转发器中的数据绑定语法类似： `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`？</span><span class="sxs-lookup"><span data-stu-id="b4377-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span></span> <span data-ttu-id="b4377-197">尽管此语法获胜 t 的当前实现使用`ProductsBLL`类 (由于`GetProductsByCategoryID(categoryID)`方法是实例方法)，你可以修改`ProductsBLL`包括一个静态`GetProductsByCategoryID(categoryID)`方法或具有包括静态类`Instance()`方法返回的新实例`ProductsBLL`类。</span><span class="sxs-lookup"><span data-stu-id="b4377-197">Although this syntax won t work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>


<span data-ttu-id="b4377-198">虽然此类修改将消除对需要`GetProductsInCategory(categoryID)`在 ASP.NET 页的代码隐藏类的方法，代码隐藏类方法会为我们提供更灵活地处理与数据检索，正如我们很快将看到。</span><span class="sxs-lookup"><span data-stu-id="b4377-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="b4377-199">检索所有产品信息一次</span><span class="sxs-lookup"><span data-stu-id="b4377-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="b4377-200">两个早期技术我们检查已通过调用获取这些类别的产品的当前`ProductsBLL`类 s`GetProductsByCategoryID(categoryID)`方法 (第一种方法之所以这样做是通过对象数据源，通过第二个`GetProductsInCategory(categoryID)`中的方法代码隐藏类）。</span><span class="sxs-lookup"><span data-stu-id="b4377-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="b4377-201">每次调用此方法时，给数据访问层，业务逻辑层调用的查询返回中的行的 SQL 语句的数据库`Products`表`CategoryID`字段与匹配提供的输入的参数。</span><span class="sxs-lookup"><span data-stu-id="b4377-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="b4377-202">给定*N*系统中的类别，这种方法网*N* + 1 调用数据库一个数据库查询来获取所有类别，然后*N*调用以获取产品特定于每个类别。</span><span class="sxs-lookup"><span data-stu-id="b4377-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="b4377-203">但是，我们可以检索仅使用两个数据库调用一次调用，若要获取所有类别，另一个用于获取所有产品的所有所需的数据。</span><span class="sxs-lookup"><span data-stu-id="b4377-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="b4377-204">一旦我们拥有的所有产品，我们可以因此筛选这些产品仅匹配当前的产品`CategoryID`绑定到该类别 s 内部转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="b4377-205">若要提供此功能，我们只需进行需要稍做修改`GetProductsInCategory(categoryID)`在我们 ASP.NET 页的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="b4377-206">而不会盲目地返回的结果`ProductsBLL`类 s`GetProductsByCategoryID(categoryID)`方法，我们可以改为第一次访问*所有*的产品 (如果它们没有 t 已访问)，然后返回的只是筛选的视图产品基于传入的`CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="b4377-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven t been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>


[!code-vb[Main](nested-data-web-controls-vb/samples/sample8.vb)]

<span data-ttu-id="b4377-207">请注意页面级别变量中，添加`allProducts`。</span><span class="sxs-lookup"><span data-stu-id="b4377-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="b4377-208">这包含有关的所有产品的信息，而且填充第一次`GetProductsInCategory(categoryID)`调用方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="b4377-209">后确保`allProducts`、 创建对象并将其填充方法选项 DataTable 的结果进行了筛选，以便只有行其`CategoryID`匹配所指定`CategoryID`可访问。</span><span class="sxs-lookup"><span data-stu-id="b4377-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="b4377-210">此方法可以降低从将访问该数据库的次数*N* + 1 到两个。</span><span class="sxs-lookup"><span data-stu-id="b4377-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="b4377-211">此增强功能不会引入到页上，呈现标记的任何更改也不会使其他方法相比，返回更少的记录。</span><span class="sxs-lookup"><span data-stu-id="b4377-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="b4377-212">它只是减少了对数据库的调用数。</span><span class="sxs-lookup"><span data-stu-id="b4377-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="b4377-213">一个直观的方式可能原因减少的数据库访问次数会肯定提高性能。</span><span class="sxs-lookup"><span data-stu-id="b4377-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="b4377-214">但是，这可能不是这种情况。</span><span class="sxs-lookup"><span data-stu-id="b4377-214">However, this might not be the case.</span></span> <span data-ttu-id="b4377-215">如果你有大量的产品其`CategoryID`是`NULL`，示例中，则调用`GetProducts`方法返回的产品的永远不会显示一个数字。</span><span class="sxs-lookup"><span data-stu-id="b4377-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="b4377-216">此外，返回所有产品可以都是一种浪费如果你重新仅显示了类别，这可能都是这种情况，如果已实现分页的子集。</span><span class="sxs-lookup"><span data-stu-id="b4377-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>


<span data-ttu-id="b4377-217">如往常一样，当涉及到分析的两种技术的性能，仅有效的度量值是运行的应用程序 s 常见案例方案而量身定制的受控的测试。</span><span class="sxs-lookup"><span data-stu-id="b4377-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="b4377-218">摘要</span><span class="sxs-lookup"><span data-stu-id="b4377-218">Summary</span></span>

<span data-ttu-id="b4377-219">在本教程中我们已了解如何嵌套一个数据在另一个，Web 控件专门检查如何让显示每个类别项列出符号列表中的每个类别的产品内部的转发器与外部转发器。</span><span class="sxs-lookup"><span data-stu-id="b4377-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="b4377-220">生成嵌套的用户界面中的主要挑战在于访问并将正确的数据绑定到内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="b4377-221">有多种技术可用，我们在本教程中检查其中有 2 个。</span><span class="sxs-lookup"><span data-stu-id="b4377-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="b4377-222">检查第一种方法中的外部数据 Web 控件 s 使用 ObjectDataSource `ItemTemplate` ，已绑定到内部数据 Web 控制通过其`DataSourceID`属性。</span><span class="sxs-lookup"><span data-stu-id="b4377-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="b4377-223">第二种方法访问的数据通过在 ASP.NET 页的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="b4377-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="b4377-224">然后，此方法可以绑定到内部数据 Web 控件的`DataSource`通过数据绑定语法的属性。</span><span class="sxs-lookup"><span data-stu-id="b4377-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="b4377-225">尽管检查在本教程中的嵌套的用户接口使用中继器嵌套在中继器，这些技术可以扩展到其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="b4377-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="b4377-226">可以嵌套在一个 GridView 或 DataList 内的 GridView 中继器等。</span><span class="sxs-lookup"><span data-stu-id="b4377-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="b4377-227">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="b4377-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="b4377-228">关于作者</span><span class="sxs-lookup"><span data-stu-id="b4377-228">About the Author</span></span>

<span data-ttu-id="b4377-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="b4377-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="b4377-230">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="b4377-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="b4377-231">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="b4377-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="b4377-232">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="b4377-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="b4377-233">特别感谢</span><span class="sxs-lookup"><span data-stu-id="b4377-233">Special Thanks To</span></span>

<span data-ttu-id="b4377-234">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="b4377-234">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="b4377-235">本教程中的前导审阅者已 Zack Jones 和沈 Shulok。</span><span class="sxs-lookup"><span data-stu-id="b4377-235">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="b4377-236">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="b4377-236">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="b4377-237">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="b4377-237">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
[<span data-ttu-id="b4377-238">上一篇</span><span class="sxs-lookup"><span data-stu-id="b4377-238">Previous</span></span>](showing-multiple-records-per-row-with-the-datalist-control-vb.md)
