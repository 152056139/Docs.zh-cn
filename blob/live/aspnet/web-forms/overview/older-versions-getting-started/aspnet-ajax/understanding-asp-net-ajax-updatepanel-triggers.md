---
uid: web-forms/overview/older-versions-getting-started/aspnet-ajax/understanding-asp-net-ajax-updatepanel-triggers
title: "了解 ASP.NET AJAX UpdatePanel 触发器 |Microsoft 文档"
author: scottcate
description: "当使用 Visual Studio 中的标记编辑器，你可能注意到 （从 IntelliSense) 有两个 UpdatePanel 控件的子元素。 疑问词之一..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/12/2008
ms.topic: article
ms.assetid: faab8503-2984-48a9-8a40-7728461abc50
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/aspnet-ajax/understanding-asp-net-ajax-updatepanel-triggers
msc.type: authoredcontent
ms.openlocfilehash: 1338ef0763d9bfab451bc30cafa39f715200153d
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="understanding-aspnet-ajax-updatepanel-triggers"></a><span data-ttu-id="897df-104">了解 ASP.NET AJAX UpdatePanel 触发器</span><span class="sxs-lookup"><span data-stu-id="897df-104">Understanding ASP.NET AJAX UpdatePanel Triggers</span></span>
====================
<span data-ttu-id="897df-105">通过[Scott 类别](https://github.com/scottcate)</span><span class="sxs-lookup"><span data-stu-id="897df-105">by [Scott Cate](https://github.com/scottcate)</span></span>

[<span data-ttu-id="897df-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="897df-106">Download PDF</span></span>](http://download.microsoft.com/download/C/1/9/C19A3451-1D14-477C-B703-54EF22E197EE/AJAX_tutorial02_Triggers_cs.pdf)

> <span data-ttu-id="897df-107">当使用 Visual Studio 中的标记编辑器，你可能注意到 （从 IntelliSense) 有两个 UpdatePanel 控件的子元素。</span><span class="sxs-lookup"><span data-stu-id="897df-107">When working in the markup editor in Visual Studio, you may notice (from IntelliSense) that there are two child elements of an UpdatePanel control.</span></span> <span data-ttu-id="897df-108">其中之一是触发器元素，它指定页 （或用户控件，如果你正在使用它） 上的控件将会触发 UpdatePanel 控件元素驻留在其中部分呈现器。</span><span class="sxs-lookup"><span data-stu-id="897df-108">One of which is the Triggers element, which specifies the controls on the page (or the user control, if you are using one) that will trigger a partial render of the UpdatePanel control in which the element resides.</span></span>


## <a name="introduction"></a><span data-ttu-id="897df-109">介绍</span><span class="sxs-lookup"><span data-stu-id="897df-109">Introduction</span></span>

<span data-ttu-id="897df-110">Microsoft ASP.NET 技术将的面向对象及事件驱动的编程模型，并将它具有已编译代码的好处结合在一起。</span><span class="sxs-lookup"><span data-stu-id="897df-110">Microsoft's ASP.NET technology brings an object-oriented and event-driven programming model and unites it with the benefits of compiled code.</span></span> <span data-ttu-id="897df-111">但是，其服务器端处理模型有很多这样的可以通过 Microsoft ASP.NET 3.5 AJAX Extensions 中包含的新功能进行寻址的技术中的固有的几个缺点。</span><span class="sxs-lookup"><span data-stu-id="897df-111">However, its server-side processing model has several drawbacks inherent in the technology, many of which can be addressed by the new features included in the Microsoft ASP.NET 3.5 AJAX Extensions.</span></span> <span data-ttu-id="897df-112">这些扩展使许多新的丰富的客户端功能，包括部分呈现页，而无需完整的页面刷新，能够通过 （包括 ASP.NET 分析 API） 的客户端脚本和广泛的客户端 API 访问 Web 服务用于镜像许多 ASP.NET 服务器端控件集中所示的控件方案。</span><span class="sxs-lookup"><span data-stu-id="897df-112">These extensions enable many new rich client features, including partial rendering of pages without requiring a full page refresh, the ability to access Web Services via client script (including the ASP.NET profiling API), and an extensive client-side API designed to mirror many of the control schemes seen in the ASP.NET server-side control set.</span></span>

<span data-ttu-id="897df-113">本白皮书检查 ASP.NET AJAX 的 XML 触发器功能`UpdatePanel`组件。</span><span class="sxs-lookup"><span data-stu-id="897df-113">This whitepaper examines the XML Triggers functionality of the ASP.NET AJAX `UpdatePanel` component.</span></span> <span data-ttu-id="897df-114">XML 触发器使精细控制可能会导致部分呈现特定 UpdatePanel 控件的组件。</span><span class="sxs-lookup"><span data-stu-id="897df-114">XML Triggers give granular control over the components that can cause partial rendering for specific UpdatePanel controls.</span></span>

<span data-ttu-id="897df-115">此白皮书基于 Beta 2 版本的.NET Framework 3.5 和 Visual Studio 2008。</span><span class="sxs-lookup"><span data-stu-id="897df-115">This whitepaper is based on the Beta 2 release of the .NET Framework 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="897df-116">ASP.NET AJAX Extensions 中，以前针对 ASP.NET 2.0 中，外接程序程序集现已集成到.NET Framework 基类库中。</span><span class="sxs-lookup"><span data-stu-id="897df-116">The ASP.NET AJAX Extensions, previously an add-on assembly targeted at ASP.NET 2.0, are now integrated into the .NET Framework Base Class Library.</span></span> <span data-ttu-id="897df-117">此白皮书还假定你将使用 Visual Studio 2008 中，不 Visual Web Developer Express，并将提供根据 Visual Studio 的用户界面的演练 （尽管将完全兼容而不考虑代码列表开发环境）。</span><span class="sxs-lookup"><span data-stu-id="897df-117">This whitepaper also assumes that you will be working with Visual Studio 2008, not Visual Web Developer Express, and will provide walkthroughs according to the user interface of Visual Studio (although code listings will be entirely compatible regardless of development environment).</span></span>

## <a name="triggers"></a><span data-ttu-id="897df-118">*触发器*</span><span class="sxs-lookup"><span data-stu-id="897df-118">*Triggers*</span></span>

<span data-ttu-id="897df-119">为给定 UpdatePanel，默认情况下，触发器自动包括调用回发，包括 （例如） TextBox 控件具有任何子控件其`AutoPostBack`属性设置为**true**。</span><span class="sxs-lookup"><span data-stu-id="897df-119">Triggers for a given UpdatePanel, by default, automatically include any child controls that invoke a postback, including (for example) TextBox controls that have their `AutoPostBack` property set to **true**.</span></span> <span data-ttu-id="897df-120">但是，触发器还可包含使用标记; 以声明方式在完成此操作`<triggers>`UpdatePanel 控件声明的一部分。</span><span class="sxs-lookup"><span data-stu-id="897df-120">However, triggers can also be included declaratively using markup; this is done within the `<triggers>` section of the UpdatePanel control declaration.</span></span> <span data-ttu-id="897df-121">尽管可以通过访问触发器`Triggers`集合属性，它建议 （例如，如果控件在设计时不可用） 注册任何部分呈现触发器在运行时通过使用`RegisterAsyncPostBackControl(Control)`方法ScriptManager 页，在对象`Page_Load`事件。</span><span class="sxs-lookup"><span data-stu-id="897df-121">Although triggers can be accessed via the `Triggers` collection property, it is recommended that you register any partial render triggers at run-time (for instance, if a control is not available at design time) by using the `RegisterAsyncPostBackControl(Control)` method of the ScriptManager object for your page, within the `Page_Load` event.</span></span> <span data-ttu-id="897df-122">请记住，页是无状态，因此你应重新注册这些控件每次创建它们。</span><span class="sxs-lookup"><span data-stu-id="897df-122">Remember that Pages are stateless, and so you should re-register these controls every time they are created.</span></span>

<span data-ttu-id="897df-123">自动子触发器包含也可禁用 （以便创建回发的子控件不自动触发部分呈现） 通过设置`ChildrenAsTriggers`属性**false**。</span><span class="sxs-lookup"><span data-stu-id="897df-123">Automatic child trigger inclusion can also be disabled (so that child controls that create postbacks do not automatically trigger partial renders) by setting the `ChildrenAsTriggers` property to **false**.</span></span> <span data-ttu-id="897df-124">这使得您最大的灵活性分配了哪些特定控件可能会调用页呈现，并建议，以便开发人员将选择加入以响应某个事件，而不是处理可能出现的任何事件。</span><span class="sxs-lookup"><span data-stu-id="897df-124">This allows you the greatest flexibility in assigning which specific controls may invoke a page render, and is recommended, so that a developer will opt-in to respond to an event, rather than handling any events that may arise.</span></span>

<span data-ttu-id="897df-125">请注意，当嵌套 UpdatePanel 控件时，当 UpdateMode 设置为**条件**，如果子 UpdatePanel 触发，但父无效，则仅将刷新 UpdatePanel 子。</span><span class="sxs-lookup"><span data-stu-id="897df-125">Note that when UpdatePanel controls are nested, when the UpdateMode is set to **Conditional**, if the child UpdatePanel is triggered, but the parent is not, then only the child UpdatePanel will refresh.</span></span> <span data-ttu-id="897df-126">但是，如果父 UpdatePanel 处于刷新，然后子 UpdatePanel 也将刷新。</span><span class="sxs-lookup"><span data-stu-id="897df-126">However, if the parent UpdatePanel is refreshed, then the child UpdatePanel will also be refreshed.</span></span>

## <a name="the-lttriggersgt-element"></a><span data-ttu-id="897df-127">*&lt;触发器&gt;元素*</span><span class="sxs-lookup"><span data-stu-id="897df-127">*The &lt;Triggers&gt; Element*</span></span>

<span data-ttu-id="897df-128">当使用 Visual Studio 中的标记编辑器，你可能注意到 （从 IntelliSense) 有两个子元素的`UpdatePanel`控件。</span><span class="sxs-lookup"><span data-stu-id="897df-128">When working in the markup editor in Visual Studio, you may notice (from IntelliSense) that there are two child elements of an `UpdatePanel` control.</span></span> <span data-ttu-id="897df-129">最常见的元素是`<ContentTemplate>`元素，它实质上是封装将被更新面板的内容 （我们要为其启用部分呈现的内容）。</span><span class="sxs-lookup"><span data-stu-id="897df-129">The most-frequently seen element is the `<ContentTemplate>` element, which essentially encapsulates the content that will be held by the update panel (the content for which we are enabling partial rendering).</span></span> <span data-ttu-id="897df-130">其他元素是`<Triggers>`元素，它指定页 （或用户控件，如果你正在使用它） 上的控件将会触发 UpdatePanel 控件中的部分呈现&lt;触发器&gt;元素驻留。</span><span class="sxs-lookup"><span data-stu-id="897df-130">The other element is the `<Triggers>` element, which specifies the controls on the page (or the user control, if you are using one) that will trigger a partial render of the UpdatePanel control in which the &lt;Triggers&gt; element resides.</span></span>

<span data-ttu-id="897df-131">`<Triggers>`元素可以包含任意数量每个的两个子节点：`<asp:AsyncPostBackTrigger>`和`<asp:PostBackTrigger>`。</span><span class="sxs-lookup"><span data-stu-id="897df-131">The `<Triggers>` element can contain any number each of two child nodes: `<asp:AsyncPostBackTrigger>` and `<asp:PostBackTrigger>`.</span></span> <span data-ttu-id="897df-132">它们都接受两个属性，`ControlID`和`EventName`，并可以指定在当前的单元中封装任何控件 （例如，如果 UpdatePanel 控件包含在 Web 用户控件中，你不应尝试引用上的控件用户控件将在其驻留的页确定）。</span><span class="sxs-lookup"><span data-stu-id="897df-132">They both accept two attributes, `ControlID` and `EventName`, and can specify any Control within the current unit of encapsulation (for instance, if your UpdatePanel control resides within a Web User Control, you should not attempt to reference a Control on the Page on which the User Control will reside).</span></span>

<span data-ttu-id="897df-133">`<asp:AsyncPostBackTrigger>`元素是特别有用，因为它可以指定目标中存在的子控件的任何事件*任何*UpdatePanel 封装，而不仅仅是在其下此触发器是子级 UpdatePanel 的单元中的控件.</span><span class="sxs-lookup"><span data-stu-id="897df-133">The `<asp:AsyncPostBackTrigger>` element is particularly useful in that it can target any event from a Control that exists as a child of *any* UpdatePanel control in the unit of encapsulation, not just the UpdatePanel under which this trigger is a child.</span></span> <span data-ttu-id="897df-134">因此，任何控件可用于触发分部页更新。</span><span class="sxs-lookup"><span data-stu-id="897df-134">Thus, any control can be made to trigger a partial page update.</span></span>

<span data-ttu-id="897df-135">同样，`<asp:PostBackTrigger>`元素可用于的触发器部分页呈现，但其中一个需要完整往返到服务器。</span><span class="sxs-lookup"><span data-stu-id="897df-135">Similarly, the `<asp:PostBackTrigger>` element can be used to trigger a partial page render, but one that requires a full round-trip to the server.</span></span> <span data-ttu-id="897df-136">此触发器元素还可以用于强制完整的页面呈现控件通常会否则触发部分页呈现器时 (例如，当`Button`中存在控件`<ContentTemplate>`UpdatePanel 控件元素)。</span><span class="sxs-lookup"><span data-stu-id="897df-136">This trigger element can also be used to force a full page render when a control would otherwise normally trigger a partial page render (for instance, when a `Button` control exists in the `<ContentTemplate>` element of an UpdatePanel control).</span></span> <span data-ttu-id="897df-137">同样，PostBackTrigger 元素可以指定是封装的当前单元中任何 UpdatePanel 控件的子级的任何控件。</span><span class="sxs-lookup"><span data-stu-id="897df-137">Again, the PostBackTrigger element can specify any control that is a child of any UpdatePanel control in the current unit of encapsulation.</span></span>

## <a name="lttriggersgt-element-reference"></a><span data-ttu-id="897df-138">*&lt;触发器&gt;元素引用*</span><span class="sxs-lookup"><span data-stu-id="897df-138">*&lt;Triggers&gt; Element Reference*</span></span>

<span data-ttu-id="897df-139">*标记后代：*</span><span class="sxs-lookup"><span data-stu-id="897df-139">*Markup Descendants:*</span></span>

| <span data-ttu-id="897df-140">**标记**</span><span class="sxs-lookup"><span data-stu-id="897df-140">**Tag**</span></span> | <span data-ttu-id="897df-141">**描述**</span><span class="sxs-lookup"><span data-stu-id="897df-141">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="897df-142">&lt;asp: AsyncPostBackTrigger&gt;</span><span class="sxs-lookup"><span data-stu-id="897df-142">&lt;asp:AsyncPostBackTrigger&gt;</span></span> | <span data-ttu-id="897df-143">指定的控件和将会包含此触发器引用 UpdatePanel 导致分部页更新的事件。</span><span class="sxs-lookup"><span data-stu-id="897df-143">Specifies a control and event that will cause a partial page update for the UpdatePanel that contains this trigger reference.</span></span> |
| <span data-ttu-id="897df-144">&lt;asp: PostBackTrigger&gt;</span><span class="sxs-lookup"><span data-stu-id="897df-144">&lt;asp:PostBackTrigger&gt;</span></span> | <span data-ttu-id="897df-145">指定的控件和将导致整页更新 （完整的页面刷新） 的事件。</span><span class="sxs-lookup"><span data-stu-id="897df-145">Specifies a control and event that will cause a full page update (a full page refresh).</span></span> <span data-ttu-id="897df-146">此标记可用于强制完全刷新时控件否则会触发部分呈现。</span><span class="sxs-lookup"><span data-stu-id="897df-146">This tag can be used to force a full refresh when a control would otherwise trigger partial rendering.</span></span> |

## <a name="walkthrough-cross-updatepanel-triggers"></a><span data-ttu-id="897df-147">*演练： 跨 UpdatePanel 触发器*</span><span class="sxs-lookup"><span data-stu-id="897df-147">*Walkthrough: Cross-UpdatePanel Triggers*</span></span>

1. <span data-ttu-id="897df-148">创建新的 ASP.NET 页的设置以启用部分呈现一个 ScriptManager 对象。</span><span class="sxs-lookup"><span data-stu-id="897df-148">Create a new ASP.NET page with a ScriptManager object set to enable partial rendering.</span></span> <span data-ttu-id="897df-149">将两个 UpdatePanels 添加到此页-在第一个，包括一个标签控件 (Label1) 和两个按钮控件 （Button1 和 Button2）。</span><span class="sxs-lookup"><span data-stu-id="897df-149">Add two UpdatePanels to this page - in the first, include a Label control ( Label1 ) and two Button controls ( Button1 and Button2 ).</span></span> <span data-ttu-id="897df-150">应该在 Button1 单击此项可同时更新和 Button2 应该显示单击此项可更新，或沿这些行的内容。</span><span class="sxs-lookup"><span data-stu-id="897df-150">Button1 should say Click to Update Both and Button2 should say Click to Update This, or something along those lines.</span></span> <span data-ttu-id="897df-151">在第二个 UpdatePanel，包括仅的标签控件 (Label2)，但将其前景色属性设置为默认值对其进行区分以外的项目。</span><span class="sxs-lookup"><span data-stu-id="897df-151">In the second UpdatePanel, include only a Label control ( Label2 ), but set its ForeColor property to something other than the default to differentiate it.</span></span>
2. <span data-ttu-id="897df-152">设置到这两个 UpdatePanel 标记的 UpdateMode 属性**条件**。</span><span class="sxs-lookup"><span data-stu-id="897df-152">Set the UpdateMode property of both UpdatePanel tags to **Conditional**.</span></span>

<span data-ttu-id="897df-153">**列表 1: default.aspx 标记：**</span><span class="sxs-lookup"><span data-stu-id="897df-153">**Listing 1: Markup for default.aspx:**</span></span> 

[!code-aspx[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample1.aspx)]

1. <span data-ttu-id="897df-154">在 Button1 单击事件处理程序，设置 Label1.Text 和 Label2.Text 某事时间相关 （例如 DateTime.Now.ToLongTimeString())。</span><span class="sxs-lookup"><span data-stu-id="897df-154">In the Click event handler for Button1, set Label1.Text and Label2.Text to something time-dependent (such as DateTime.Now.ToLongTimeString()).</span></span> <span data-ttu-id="897df-155">对于 Button2 的单击事件处理程序，设置为依赖于时间值的仅 Label1.Text。</span><span class="sxs-lookup"><span data-stu-id="897df-155">For the Click event handler for Button2, set only Label1.Text to the time-dependent value.</span></span>

<span data-ttu-id="897df-156">**列出 2： 代码隐藏文件 default.aspx.cs 中 （剪裁）：**</span><span class="sxs-lookup"><span data-stu-id="897df-156">**Listing 2: Codebehind (trimmed) in default.aspx.cs:**</span></span> 

[!code-csharp[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample2.cs)]

1. <span data-ttu-id="897df-157">按 F5 生成并运行项目。</span><span class="sxs-lookup"><span data-stu-id="897df-157">Press F5 to build and run the project.</span></span> <span data-ttu-id="897df-158">请注意，当你单击更新同时面板，这两个标签更改文本;但是，当你单击更新此面板，仅 Label1 更新。</span><span class="sxs-lookup"><span data-stu-id="897df-158">Note that, when you click Update Both Panels, both labels change text; however, when you click Update This Panel, only Label1 updates.</span></span>


[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image2.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image1.png)

<span data-ttu-id="897df-159">([单击以查看实际尺寸的图像](understanding-asp-net-ajax-updatepanel-triggers/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="897df-159">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image3.png))</span></span>


## <a name="under-the-hood"></a><span data-ttu-id="897df-160">*揭秘*</span><span class="sxs-lookup"><span data-stu-id="897df-160">*Under the Hood*</span></span>

<span data-ttu-id="897df-161">利用我们刚构建的示例，我们可以看看 ASP.NET AJAX 正在做什么以及我们 UpdatePanel 跨面板触发器的工作方式。</span><span class="sxs-lookup"><span data-stu-id="897df-161">Utilizing the example we just constructed, we can take a look at what ASP.NET AJAX is doing and how our UpdatePanel cross-panel triggers work.</span></span> <span data-ttu-id="897df-162">若要执行此操作，我们会使用生成的页面源文件 HTML，以及使用它，调用 FireBug-Mozilla Firefox 扩展我们可以轻松地检查 AJAX 回发。</span><span class="sxs-lookup"><span data-stu-id="897df-162">To do so, we will work with the generated page source HTML, as well as the Mozilla Firefox extension called FireBug - with it, we can easily examine the AJAX postbacks.</span></span> <span data-ttu-id="897df-163">我们还将使用通过 Lutz Roeder.NET 反射器工具。</span><span class="sxs-lookup"><span data-stu-id="897df-163">We will also use the .NET Reflector tool by Lutz Roeder.</span></span> <span data-ttu-id="897df-164">这两种工具，请随意联机，并可以使用 internet 搜索找到。</span><span class="sxs-lookup"><span data-stu-id="897df-164">Both of these tools are freely available online, and can be found with an internet search.</span></span>

<span data-ttu-id="897df-165">对页源代码的检查显示不正常; 几乎任何内容UpdatePanel 控件呈现为`<div>`容器以及我们可以看到了脚本资源包括提供通过`<asp:ScriptManager>`。</span><span class="sxs-lookup"><span data-stu-id="897df-165">An examination of the page source code shows almost nothing out of the ordinary; the UpdatePanel controls are rendered as `<div>` containers, and we can see the script resource includes provided by the `<asp:ScriptManager>`.</span></span> <span data-ttu-id="897df-166">此外，还存在一些新特定于 AJAX 调用到 PageRequestManager 的内部 AJAX 客户端脚本库。</span><span class="sxs-lookup"><span data-stu-id="897df-166">There are also some new AJAX-specific calls to the PageRequestManager that are internal to the AJAX client script library.</span></span> <span data-ttu-id="897df-167">最后，我们看到两个 UpdatePanel 容器-一个具有呈现`<input>`带两个按钮`<asp:Label>`控件呈现为`<span>`容器。</span><span class="sxs-lookup"><span data-stu-id="897df-167">Finally, we see the two UpdatePanel containers - one with the rendered `<input>` buttons with the two `<asp:Label>` controls rendered as `<span>` containers.</span></span> <span data-ttu-id="897df-168">（如果您检查的 DOM 树中 FireBug，你将注意到标签灰显以表示它们不能发出可见内容）。</span><span class="sxs-lookup"><span data-stu-id="897df-168">(If you inspect the DOM tree in FireBug, you will notice that the labels are dimmed to indicate that they are not producing visible content).</span></span>

<span data-ttu-id="897df-169">单击更新此面板按钮，并注意顶部 UpdatePanel 将更新与当前服务器的时间。</span><span class="sxs-lookup"><span data-stu-id="897df-169">Click the Update This Panel button, and notice the top UpdatePanel will be updated with the current server time.</span></span> <span data-ttu-id="897df-170">因此，你可以检查请求，请在 FireBug，选择控制台选项卡。</span><span class="sxs-lookup"><span data-stu-id="897df-170">In FireBug, choose the Console tab so that you can examine the request.</span></span> <span data-ttu-id="897df-171">首先检查 POST 请求参数：</span><span class="sxs-lookup"><span data-stu-id="897df-171">Examine the POST request parameters first:</span></span>


[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image5.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image4.png)

<span data-ttu-id="897df-172">([单击以查看实际尺寸的图像](understanding-asp-net-ajax-updatepanel-triggers/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="897df-172">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image6.png))</span></span>


<span data-ttu-id="897df-173">请注意，UpdatePanel 表明对服务器端 AJAX 代码精确的控制树触发通过 ScriptManager1 参数：`Button1`的`UpdatePanel1`控件。</span><span class="sxs-lookup"><span data-stu-id="897df-173">Note that the UpdatePanel has indicated to the server-side AJAX code precisely which control tree was fired via the ScriptManager1 parameter: `Button1` of the `UpdatePanel1` control.</span></span> <span data-ttu-id="897df-174">现在，单击更新两个面板按钮。</span><span class="sxs-lookup"><span data-stu-id="897df-174">Now, click on the Update Both Panels button.</span></span> <span data-ttu-id="897df-175">然后，检查响应，我们请参阅竖线分隔的一系列变量字符串; 中的设置具体而言，我们看到顶部 UpdatePanel， `UpdatePanel1`，已发送到浏览器其 HTML 整个。</span><span class="sxs-lookup"><span data-stu-id="897df-175">Then, examining the response, we see a pipe-delimited series of variables set in a string; specifically, we see the top UpdatePanel, `UpdatePanel1`, has the entirety of its HTML sent to the browser.</span></span> <span data-ttu-id="897df-176">AJAX 客户端脚本库替换 UpdatePanel 的原始 HTML 内容使用新的内容通过`.innerHTML`属性，因此服务器从服务器以 HTML 的形式发送已更改的内容。</span><span class="sxs-lookup"><span data-stu-id="897df-176">The AJAX client script library substitutes the UpdatePanel's original HTML content with the new content via the `.innerHTML` property, and so the server sends the changed content from the server as HTML.</span></span>

<span data-ttu-id="897df-177">现在，单击更新两个面板按钮，并检查从服务器的结果。</span><span class="sxs-lookup"><span data-stu-id="897df-177">Now, click on the Update Both Panels button and examine the results from the server.</span></span> <span data-ttu-id="897df-178">结果将是非常类似-这两个 UpdatePanels 从服务器接收新的 html 代码。</span><span class="sxs-lookup"><span data-stu-id="897df-178">The results are very similar - both UpdatePanels receive new HTML from the server.</span></span> <span data-ttu-id="897df-179">与以前的回调中，将发送其他页面状态。</span><span class="sxs-lookup"><span data-stu-id="897df-179">As with the previous callback, additional page state is sent.</span></span>

<span data-ttu-id="897df-180">我们可以看到，因为没有特殊的代码用于执行 AJAX 回发，则 AJAX 客户端脚本库就能够截获无需任何其他代码的窗体回发。</span><span class="sxs-lookup"><span data-stu-id="897df-180">As we can see, because no special code is utilized to perform an AJAX postback, the AJAX client script library is able to intercept form postbacks without any additional code.</span></span> <span data-ttu-id="897df-181">服务器控件自动利用 JavaScript，以便它们不会自动提交表单-ASP.NET 自动插入代码窗体验证和状态，主要通过自动脚本资源包含，PostBackOptions 类和 ClientScriptManager 类。</span><span class="sxs-lookup"><span data-stu-id="897df-181">Server controls automatically utilize JavaScript so that they do not automatically submit the form - ASP.NET automatically injects code for form validation and state already, primarily achieved by automatic script resource inclusion, the PostBackOptions class, and the ClientScriptManager class.</span></span>

<span data-ttu-id="897df-182">例如，假设复选框控件，则检查在.NET 反射器类反汇编。</span><span class="sxs-lookup"><span data-stu-id="897df-182">For instance, consider a CheckBox control; examine the class disassembly in .NET Reflector.</span></span> <span data-ttu-id="897df-183">为此，请确保你 System.Web 程序集处于打开状态，并导航到`System.Web.UI.WebControls.CheckBox`类中，打开`RenderInputTag`方法。</span><span class="sxs-lookup"><span data-stu-id="897df-183">To do so, ensure that your System.Web assembly is open, and navigate to the `System.Web.UI.WebControls.CheckBox` class, opening the `RenderInputTag` method.</span></span> <span data-ttu-id="897df-184">检查的条件查找`AutoPostBack`属性：</span><span class="sxs-lookup"><span data-stu-id="897df-184">Look for a conditional that checks the `AutoPostBack` property:</span></span>


[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image8.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image7.png)

<span data-ttu-id="897df-185">([单击以查看实际尺寸的图像](understanding-asp-net-ajax-updatepanel-triggers/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="897df-185">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image9.png))</span></span>


<span data-ttu-id="897df-186">当在上启用自动回发`CheckBox`控制 （通过有些属性是否均为 true），所产生的`<input>`标记因此呈现与 ASP.NET 事件处理中的脚本其`onclick`属性。</span><span class="sxs-lookup"><span data-stu-id="897df-186">When automatic postback is enabled on a `CheckBox` control (via the AutoPostBack property being true), the resultant `<input>` tag is therefore rendered with an ASP.NET event handling script in its `onclick` attribute.</span></span> <span data-ttu-id="897df-187">窗体的提交，然后，截获允许 ASP.NET AJAX，若要插入到页 nonintrusively，有助于避免任何重大更改，可能出现的使用可能不精确的字符串替换的可能性。</span><span class="sxs-lookup"><span data-stu-id="897df-187">The interception of the form's submission, then, allows ASP.NET AJAX to be injected into the page nonintrusively, helping to avoid any potential breaking changes that might occur by utilizing a possibly-imprecise string replacement.</span></span> <span data-ttu-id="897df-188">此外，这使*任何*自定义 ASP.NET 控件，若要利用的功能的 ASP.NET AJAX 无需任何其他代码以支持其使用 UpdatePanel 容器中的。</span><span class="sxs-lookup"><span data-stu-id="897df-188">Furthermore, this enables *any* custom ASP.NET control to utilize the power of ASP.NET AJAX without any additional code to support its use within an UpdatePanel container.</span></span>

<span data-ttu-id="897df-189">`<triggers>`功能对应于 PageRequestManager 调用中初始化的值\_updateControls （请注意 ASP.NET AJAX 客户端脚本库利用约定，该方法、 事件和开始的字段名称下划线开头标记为内部，而不适合在库自身之外的使用）。</span><span class="sxs-lookup"><span data-stu-id="897df-189">The `<triggers>` functionality corresponds to the values initialized in the PageRequestManager call to \_updateControls (note that the ASP.NET AJAX client script library utilizes the convention that methods, events, and field names that begin with an underscore are marked as internal, and are not meant for use outside of the library itself).</span></span> <span data-ttu-id="897df-190">通过该对话框，我们可以看到哪些控件旨在导致 AJAX 回发。</span><span class="sxs-lookup"><span data-stu-id="897df-190">With it, we can observe which controls are intended to cause AJAX postbacks.</span></span>

<span data-ttu-id="897df-191">例如，让我们添加到页中，完全，离开 UpdatePanels 之外的一个控件并离开 UpdatePanel 中的两个其他控件。</span><span class="sxs-lookup"><span data-stu-id="897df-191">For example, let's add two additional controls to the page, leaving one control outside of the UpdatePanels entirely, and leaving one within an UpdatePanel.</span></span> <span data-ttu-id="897df-192">我们将添加内上部 UpdatePanel，复选框控件拖 DropDownList 包含列表中定义的颜色数。</span><span class="sxs-lookup"><span data-stu-id="897df-192">We will add a CheckBox control within the upper UpdatePanel, and drop a DropDownList with a number of colors defined within the list.</span></span> <span data-ttu-id="897df-193">下面是新的标记：</span><span class="sxs-lookup"><span data-stu-id="897df-193">Here is the new markup:</span></span>

<span data-ttu-id="897df-194">**列出 3： 新的标记**</span><span class="sxs-lookup"><span data-stu-id="897df-194">**Listing 3: New Markup**</span></span>

[!code-aspx[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample3.aspx)]

<span data-ttu-id="897df-195">而以下是新的代码隐藏：</span><span class="sxs-lookup"><span data-stu-id="897df-195">And here is the new code-behind:</span></span>

<span data-ttu-id="897df-196">**列出 4： 代码隐藏**</span><span class="sxs-lookup"><span data-stu-id="897df-196">**Listing 4: Codebehind**</span></span>

[!code-csharp[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample4.cs)]

<span data-ttu-id="897df-197">此页背后的理念是，下拉列表中选择一个三种颜色以显示第二个标签、 复选框确定是否显示为粗体，又标签显示日期，以及时间。</span><span class="sxs-lookup"><span data-stu-id="897df-197">The idea behind this page is that the drop-down list selects one of three colors to show the second label, that the check box determines both whether it is bold, and whether the labels display the date as well as the time.</span></span> <span data-ttu-id="897df-198">复选框不应导致 AJAX 更新，但应下拉列表，即使不将其存放在 UpdatePanel 也是如此。</span><span class="sxs-lookup"><span data-stu-id="897df-198">The check box should not cause an AJAX update, but the drop-down list should, even though it is not housed within an UpdatePanel.</span></span>


[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image11.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image10.png)

<span data-ttu-id="897df-199">([单击以查看实际尺寸的图像](understanding-asp-net-ajax-updatepanel-triggers/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="897df-199">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image12.png))</span></span>


<span data-ttu-id="897df-200">很明显上述的屏幕截图中，最新的按钮被单击时右侧的按钮更新此面板中，更新前的时间独立于的底部时间。</span><span class="sxs-lookup"><span data-stu-id="897df-200">As is apparent in the above screen shot, the most-recent button to be clicked was the right button Update This Panel, which updated the top time independent of the bottom time.</span></span> <span data-ttu-id="897df-201">日期也关闭了点击，之间因为日期是在底部标签中可见。</span><span class="sxs-lookup"><span data-stu-id="897df-201">The date was also switched off between clicks, as the date is visible in the bottom label.</span></span> <span data-ttu-id="897df-202">最后需要注意的是底部标签的颜色： 它更新的时间比标签的文本，其演示了控件状态很重要，并且用户希望它将保留通过 AJAX 回发。</span><span class="sxs-lookup"><span data-stu-id="897df-202">Finally of interest is the bottom label's color: it was updated more recently than the label's text, which demonstrates that control state is important, and users expect it to be preserved through AJAX postbacks.</span></span> <span data-ttu-id="897df-203">*但是*，不更新的时间。</span><span class="sxs-lookup"><span data-stu-id="897df-203">*However*, the time was not updated.</span></span> <span data-ttu-id="897df-204">时间已自动重填的持久性通过\_\_控件在服务器上重新呈现时，ASP.NET 运行时被解释的页面的视图状态字段。</span><span class="sxs-lookup"><span data-stu-id="897df-204">The time was automatically repopulated through the persistence of the \_\_VIEWSTATE field of the page being interpreted by the ASP.NET runtime when the control was being re-rendered on the server.</span></span> <span data-ttu-id="897df-205">ASP.NET AJAX 服务器代码不能识别控件的方法在其中更改状态;它只需重新填充从视图状态，然后运行相应的事件。</span><span class="sxs-lookup"><span data-stu-id="897df-205">The ASP.NET AJAX server code does not recognize in which methods the controls are changing state; it simply repopulates from view state and then runs the events that are appropriate.</span></span>

<span data-ttu-id="897df-206">它应被指出，但是，，具有我初始化页内的时间\_负载事件时间将具有已正确增加。</span><span class="sxs-lookup"><span data-stu-id="897df-206">It should be pointed out, however, that had I initialized the time within the Page\_Load event, the time would have been incremented correctly.</span></span> <span data-ttu-id="897df-207">因此，开发人员应应谨慎，相应的代码运行期间相应的事件处理程序，并避免使用页\_加载时控件的事件处理程序将适用。</span><span class="sxs-lookup"><span data-stu-id="897df-207">Consequently, developers should be wary that the appropriate code is being run during the appropriate event handlers, and avoid use of Page\_Load when a control event handler would be appropriate.</span></span>

## <a name="summary"></a><span data-ttu-id="897df-208">摘要</span><span class="sxs-lookup"><span data-stu-id="897df-208">Summary</span></span>

<span data-ttu-id="897df-209">ASP.NET AJAX 扩展 UpdatePanel 控件是通用的并且可以利用大量用于标识应将导致其要更新的控件事件的方法。</span><span class="sxs-lookup"><span data-stu-id="897df-209">The ASP.NET AJAX Extensions UpdatePanel control is versatile, and can utilize a number of methods for identifying control events that should cause it to be updated.</span></span> <span data-ttu-id="897df-210">它支持正由子控件，自动更新，但还可以响应在其他位置的页上的控件事件。</span><span class="sxs-lookup"><span data-stu-id="897df-210">It supports being updated automatically by its child controls, but can also respond to control events elsewhere on the page.</span></span>

<span data-ttu-id="897df-211">若要减少潜在的服务器处理负载，建议`ChildrenAsTriggers`UpdatePanel 属性设置为`false`，事件会选择到而不是默认情况下包括和。</span><span class="sxs-lookup"><span data-stu-id="897df-211">To reduce potential for server processing load, it is recommended that the `ChildrenAsTriggers` property of an UpdatePanel be set to `false`, and that events be opted-into rather than included by default.</span></span> <span data-ttu-id="897df-212">此外可防止不需要的任何事件造成可能不需要的影响，包括验证和更改输入字段。</span><span class="sxs-lookup"><span data-stu-id="897df-212">This also prevents any unneeded events from causing potentially-unwanted effects, including validation, and changes to input fields.</span></span> <span data-ttu-id="897df-213">这些类型的 bug 可能很难隔离，因为页更新以透明方式对用户来说，并且可能的原因可能因此不会即时显现内容。</span><span class="sxs-lookup"><span data-stu-id="897df-213">These types of bugs may be difficult to isolate, because the page updates transparently to the user, and the cause may therefore not be immediately obvious.</span></span>

<span data-ttu-id="897df-214">通过检查 ASP.NET AJAX 窗体的内部工作情况截获模型，我们无法确定它利用已经提供的 ASP.NET 框架。</span><span class="sxs-lookup"><span data-stu-id="897df-214">By examining the inner workings of the ASP.NET AJAX form post interception model, we were able to determine that it utilizes the framework already provided by ASP.NET.</span></span> <span data-ttu-id="897df-215">在此情况下，它会保留与使用同一个框架，设计控件的最大兼容性，按最小方式侵入页写入任何其他 javascript。</span><span class="sxs-lookup"><span data-stu-id="897df-215">In doing so, it preserves maximum compatibility with controls designed using the same framework, and intrudes minimally on any additional JavaScript written for the page.</span></span>

## <a name="bio"></a><span data-ttu-id="897df-216">简介</span><span class="sxs-lookup"><span data-stu-id="897df-216">Bio</span></span>

<span data-ttu-id="897df-217">Rob Paveza 是在 Terralever 高级.NET 应用程序开发人员 ([www.terralever.com](http://www.terralever.com))，在 Tempe，AZ.前导交互式市场营销公司</span><span class="sxs-lookup"><span data-stu-id="897df-217">Rob Paveza is a senior .NET application developer at Terralever ([www.terralever.com](http://www.terralever.com)), a leading interactive marketing firm in Tempe, AZ.</span></span> <span data-ttu-id="897df-218">他可以达到在[ robpaveza@gmail.com ](mailto:robpaveza@gmail.com)，且其博客地址位于处[http://geekswithblogs.net/robp/](http://geekswithblogs.net/robp/)。</span><span class="sxs-lookup"><span data-stu-id="897df-218">He can be reached at [robpaveza@gmail.com](mailto:robpaveza@gmail.com), and his blog is located at [http://geekswithblogs.net/robp/](http://geekswithblogs.net/robp/).</span></span>

<span data-ttu-id="897df-219">Scott 类别自 1997 年以来处理与 Microsoft Web 技术，并且是 myKB.com 总裁 ([www.myKB.com](http://www.myKB.com)) 其中他专注于编写 ASP.NET 基于侧重于知识库软件解决方案的应用程序。</span><span class="sxs-lookup"><span data-stu-id="897df-219">Scott Cate has been working with Microsoft Web technologies since 1997 and is the President of myKB.com ([www.myKB.com](http://www.myKB.com)) where he specializes in writing ASP.NET based applications focused on Knowledge Base Software solutions.</span></span> <span data-ttu-id="897df-220">可以通过在电子邮件联系 Scott [ scott.cate@myKB.com ](mailto:scott.cate@myKB.com)或在其博客地址[ScottCate.com](http://ScottCate.com)</span><span class="sxs-lookup"><span data-stu-id="897df-220">Scott can be contacted via email at [scott.cate@myKB.com](mailto:scott.cate@myKB.com) or his blog at [ScottCate.com](http://ScottCate.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="897df-221">[上一页](understanding-partial-page-updates-with-asp-net-ajax.md)
[下一页](understanding-asp-net-ajax-authentication-and-profile-application-services.md)</span><span class="sxs-lookup"><span data-stu-id="897df-221">[Previous](understanding-partial-page-updates-with-asp-net-ajax.md)
[Next](understanding-asp-net-ajax-authentication-and-profile-application-services.md)</span></span>
