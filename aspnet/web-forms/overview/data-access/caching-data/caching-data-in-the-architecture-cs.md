---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: 缓存的体系结构 (C#) 中的数据 |Microsoft 文档
author: rick-anderson
description: 在以前的教程，我们学习了如何应用缓存，在表示层上。 在本教程中，我们将了解如何充分利用我们分层 architectu...
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 9ca91ecdaed536fe69196e0f726138590d7a9b77
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2018
ms.locfileid: "30879210"
---
<a name="caching-data-in-the-architecture-c"></a><span data-ttu-id="903d7-104">缓存的体系结构 (C#) 中的数据</span><span class="sxs-lookup"><span data-stu-id="903d7-104">Caching Data in the Architecture (C#)</span></span>
====================
<span data-ttu-id="903d7-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="903d7-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="903d7-106">[下载示例应用程序](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe)或[下载 PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="903d7-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) or [Download PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span></span>

> <span data-ttu-id="903d7-107">在以前的教程，我们学习了如何应用缓存，在表示层上。</span><span class="sxs-lookup"><span data-stu-id="903d7-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="903d7-108">在本教程中，我们将了解如何利用我们分层体系结构在业务逻辑层的缓存数据。</span><span class="sxs-lookup"><span data-stu-id="903d7-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="903d7-109">我们执行此操作通过扩展体系结构来容纳缓存层。</span><span class="sxs-lookup"><span data-stu-id="903d7-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="903d7-110">介绍</span><span class="sxs-lookup"><span data-stu-id="903d7-110">Introduction</span></span>

<span data-ttu-id="903d7-111">正如我们看到在前面的教程，缓存 ObjectDataSource 的数据非常简单，设置几个属性。</span><span class="sxs-lookup"><span data-stu-id="903d7-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="903d7-112">遗憾的是，ObjectDataSource 适用缓存，在表示层，这紧密的缓存策略与 ASP.NET 页上。</span><span class="sxs-lookup"><span data-stu-id="903d7-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="903d7-113">创建分层体系结构的原因之一是允许此类 couplings 中断。</span><span class="sxs-lookup"><span data-stu-id="903d7-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="903d7-114">数据访问层分离数据访问的详细信息时，业务逻辑层，例如，将从 ASP.NET 页的业务逻辑脱耦。</span><span class="sxs-lookup"><span data-stu-id="903d7-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="903d7-115">业务逻辑和数据访问详细信息这种分离是首选方法，在某种，因为它使系统，可读性更强、 更易于维护，并更灵活地更改。</span><span class="sxs-lookup"><span data-stu-id="903d7-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="903d7-116">它还允许域知识和的表示层不 t 上的开发人员需要是熟悉数据库 s 详细信息，才能完成其工作的工作划分。</span><span class="sxs-lookup"><span data-stu-id="903d7-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="903d7-117">分离与表示层的缓存策略提供类似的好处。</span><span class="sxs-lookup"><span data-stu-id="903d7-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="903d7-118">在本教程中，我们将增加我们体系结构来容纳*缓存层*（或简称 CL） 使用我们的缓存策略。</span><span class="sxs-lookup"><span data-stu-id="903d7-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="903d7-119">缓存层将包括`ProductsCL`提供等方法访问产品信息的类`GetProducts()`， `GetProductsByCategoryID(categoryID)`，依此类推，调用时，该，将从缓存中检索数据的第一次尝试。</span><span class="sxs-lookup"><span data-stu-id="903d7-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="903d7-120">如果缓存为空，则这些方法将调用相应`ProductsBLL`BLL，反过来将从 DAL 获取数据中的方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="903d7-121">`ProductsCL`方法缓存然后再返回它从 BLL 检索的数据。</span><span class="sxs-lookup"><span data-stu-id="903d7-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="903d7-122">如图 1 所示，CL 驻留的演示文稿和业务逻辑层之间。</span><span class="sxs-lookup"><span data-stu-id="903d7-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![缓存层 (CL) 是我们的体系结构中的另一个层](caching-data-in-the-architecture-cs/_static/image1.png)

<span data-ttu-id="903d7-124">**图 1**: 缓存层 (CL) 是我们的体系结构中的另一个层</span><span class="sxs-lookup"><span data-stu-id="903d7-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="903d7-125">步骤 1： 创建缓存层类</span><span class="sxs-lookup"><span data-stu-id="903d7-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="903d7-126">在本教程中我们将创建单个类具有非常简单 CL`ProductsCL`具有只有几种方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="903d7-127">为整个应用程序将需要创建生成完整的缓存层`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`类，并提供每个数据访问或修改方法中 BLL 这些缓存层类中的方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="903d7-128">与 BLL 和 DAL 中，缓存层应理想情况下实现为单独的类库项目;但是，我们将它作为实现中的类`App_Code`文件夹。</span><span class="sxs-lookup"><span data-stu-id="903d7-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="903d7-129">从 DAL 和 BLL 类的多个完全单独 CL 类，让 s 创建新的子文件夹中`App_Code`文件夹。</span><span class="sxs-lookup"><span data-stu-id="903d7-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="903d7-130">右键单击`App_Code`文件夹在解决方案资源管理器，选择新文件夹，并将新文件夹命名`CL`。</span><span class="sxs-lookup"><span data-stu-id="903d7-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="903d7-131">创建此文件夹后, 添加到该新类名为`ProductsCL.cs`。</span><span class="sxs-lookup"><span data-stu-id="903d7-131">After creating this folder, add to it a new class named `ProductsCL.cs`.</span></span>


![添加新的文件夹名为 CL 和一个名为 ProductsCL.cs 类](caching-data-in-the-architecture-cs/_static/image2.png)

<span data-ttu-id="903d7-133">**图 2**： 添加一个名为的新文件夹`CL`和一个名为类 `ProductsCL.cs`</span><span class="sxs-lookup"><span data-stu-id="903d7-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.cs`</span></span>


<span data-ttu-id="903d7-134">`ProductsCL`类应包含相同的数据访问和修改方法，如在其相应的业务逻辑层类集 (`ProductsBLL`)。</span><span class="sxs-lookup"><span data-stu-id="903d7-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="903d7-135">而不是创建所有这些方法，让的 s 只需几个此处以针对的模式感受使用的生成按 CL。</span><span class="sxs-lookup"><span data-stu-id="903d7-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="903d7-136">具体而言，我们将添加`GetProducts()`和`GetProductsByCategoryID(categoryID)`步骤 3 中的方法和`UpdateProduct`重载在步骤 4 中。</span><span class="sxs-lookup"><span data-stu-id="903d7-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="903d7-137">你可以添加剩余`ProductsCL`方法和`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`类在方便的时候。</span><span class="sxs-lookup"><span data-stu-id="903d7-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="903d7-138">步骤 2： 读取和写入数据缓存</span><span class="sxs-lookup"><span data-stu-id="903d7-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="903d7-139">缓存功能内部探讨在前面的教程，ObjectDataSource 使用 ASP.NET 数据缓存来存储从 BLL 检索的数据。</span><span class="sxs-lookup"><span data-stu-id="903d7-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="903d7-140">数据缓存在从 ASP.NET 页代码隐藏类或从 web 应用程序 s 体系结构中的类也可以以编程方式访问。</span><span class="sxs-lookup"><span data-stu-id="903d7-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="903d7-141">若要对读取和写入数据缓存从 ASP.NET 页的代码隐藏类，使用以下模式：</span><span class="sxs-lookup"><span data-stu-id="903d7-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

<span data-ttu-id="903d7-142">[ `Cache`类](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)s [ `Insert`方法](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)具有大量重载。</span><span class="sxs-lookup"><span data-stu-id="903d7-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="903d7-143">`Cache["key"] = value` 和`Cache.Insert(key, value)`是同义词并同时添加到缓存中使用指定的密钥，而无需定义到期的一个项。</span><span class="sxs-lookup"><span data-stu-id="903d7-143">`Cache["key"] = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="903d7-144">通常情况下，我们想要时将项添加到缓存中，作为依赖关系和 / 或基于时间的过期时间指定到期时间。</span><span class="sxs-lookup"><span data-stu-id="903d7-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="903d7-145">使用的其他`Insert`方法的重载，可提供基于依赖项或时间的过期信息。</span><span class="sxs-lookup"><span data-stu-id="903d7-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="903d7-146">S 方法需要先检查所请求的数据是否在缓存中，如果是，缓存层会将其返回从该处中。</span><span class="sxs-lookup"><span data-stu-id="903d7-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="903d7-147">如果请求的数据不在缓存中，相应的 BLL 方法需要调用。</span><span class="sxs-lookup"><span data-stu-id="903d7-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="903d7-148">其返回值应缓存，则返回的值，如下面的序列图所示。</span><span class="sxs-lookup"><span data-stu-id="903d7-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![缓存层的方法在如果从缓存返回数据它 s 可用](caching-data-in-the-architecture-cs/_static/image3.png)

<span data-ttu-id="903d7-150">**图 3**: 缓存层的方法在如果从缓存返回数据它 s 可用</span><span class="sxs-lookup"><span data-stu-id="903d7-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="903d7-151">图 3 所示的顺序是使用以下模式 CL 类中实现的：</span><span class="sxs-lookup"><span data-stu-id="903d7-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

<span data-ttu-id="903d7-152">在这里，*类型*是存储在缓存中的数据类型`Northwind.ProductsDataTable`，例如时*密钥*是用于唯一标识的缓存项键。</span><span class="sxs-lookup"><span data-stu-id="903d7-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="903d7-153">如果具有指定的项*密钥*不在缓存中，然后*实例*将`null`同时将从相应的 BLL 方法检索的数据，并将其添加到缓存。</span><span class="sxs-lookup"><span data-stu-id="903d7-153">If the item with the specified *key* is not in the cache, then *instance* will be `null` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="903d7-154">按时间`return instance`为止，*实例*包含数据，从缓存的引用，或从 BLL 请求。</span><span class="sxs-lookup"><span data-stu-id="903d7-154">By the time `return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="903d7-155">请务必从缓存访问数据时使用上面的模式。</span><span class="sxs-lookup"><span data-stu-id="903d7-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="903d7-156">下面的模式，该从表面看，链接的外观等效，包含引入了争用条件细微差别。</span><span class="sxs-lookup"><span data-stu-id="903d7-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="903d7-157">争用条件很难调试，因为它们偶尔揭示本身，并且难以重现。</span><span class="sxs-lookup"><span data-stu-id="903d7-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

<span data-ttu-id="903d7-158">第二个中的差异，不正确的代码段是，而不是在本地变量中存储对缓存项的引用，在条件语句中直接访问数据缓存*和*中`return`。</span><span class="sxs-lookup"><span data-stu-id="903d7-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `return`.</span></span> <span data-ttu-id="903d7-159">当达到此代码时，假设，`Cache["key"]`为非`null`，但之前`return`达到语句、 系统逐出*密钥*从缓存。</span><span class="sxs-lookup"><span data-stu-id="903d7-159">Imagine that when this code is reached, `Cache["key"]` is non-`null`, but before the `return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="903d7-160">在此罕见情况下，代码将返回`null`值而不是预期类型的对象。</span><span class="sxs-lookup"><span data-stu-id="903d7-160">In this rare case, the code will return a `null` value rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="903d7-161">数据缓存是线程安全的因此您不需要访问进行同步线程对于简单的读 / 写。</span><span class="sxs-lookup"><span data-stu-id="903d7-161">The data cache is thread-safe, so you don t need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="903d7-162">但是，如果需要多个对数据执行操作需要以保证不可分割的缓存中，你负责实现锁或某种其他机制来确保线程安全。</span><span class="sxs-lookup"><span data-stu-id="903d7-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="903d7-163">请参阅[同步访问 ASP.NET 缓存](http://www.ddj.com/184406369)有关详细信息。</span><span class="sxs-lookup"><span data-stu-id="903d7-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="903d7-164">项可以以编程方式从使用数据缓存逐出[`Remove`方法](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)如下所示：</span><span class="sxs-lookup"><span data-stu-id="903d7-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="903d7-165">步骤 3： 返回产品信息从`ProductsCL`类</span><span class="sxs-lookup"><span data-stu-id="903d7-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="903d7-166">本教程让实现两种方法来返回中的产品信息的 s`ProductsCL`类：`GetProducts()`和`GetProductsByCategoryID(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="903d7-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="903d7-167">与类似`ProductsBL`业务逻辑层中的类`GetProducts()`中 CL 方法返回有关所有作为产品信息`Northwind.ProductsDataTable`对象，而`GetProductsByCategoryID(categoryID)`返回指定类别中所有产品。</span><span class="sxs-lookup"><span data-stu-id="903d7-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="903d7-168">下面的代码演示中的方法的一部分`ProductsCL`类：</span><span class="sxs-lookup"><span data-stu-id="903d7-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

<span data-ttu-id="903d7-169">首先，请注意`DataObject`和`DataObjectMethodAttribute`特性应用于类和方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="903d7-170">这些特性向 ObjectDataSource 的向导中，指示类和方法应显示的内容在向导的 s 步骤中提供信息。</span><span class="sxs-lookup"><span data-stu-id="903d7-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="903d7-171">因为将从 ObjectDataSource 在表示层访问 CL 类和方法，所以我中添加这些属性以增强的设计时体验。</span><span class="sxs-lookup"><span data-stu-id="903d7-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="903d7-172">将回指[创建业务逻辑层](../introduction/creating-a-business-logic-layer-cs.md)教程有关这些属性和其效果的更全面说明。</span><span class="sxs-lookup"><span data-stu-id="903d7-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-cs.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="903d7-173">在`GetProducts()`和`GetProductsByCategoryID(categoryID)`方法、 从返回的数据`GetCacheItem(key)`方法分配给本地变量。</span><span class="sxs-lookup"><span data-stu-id="903d7-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="903d7-174">`GetCacheItem(key)`方法，我们将很快检查，从缓存根据指定返回特定项*密钥*。</span><span class="sxs-lookup"><span data-stu-id="903d7-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="903d7-175">如果在缓存中未不找到任何此类数据，则将它检索从相应`ProductsBLL`类方法，并随后添加到缓存使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="903d7-176">`GetCacheItem(key)`和`AddCacheItem(key, value)`方法分别接口使用数据缓存、 读取和写入值。</span><span class="sxs-lookup"><span data-stu-id="903d7-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="903d7-177">`GetCacheItem(key)`方法是更简单的两个。</span><span class="sxs-lookup"><span data-stu-id="903d7-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="903d7-178">它只需返回的值从传入的使用缓存的类*密钥*:</span><span class="sxs-lookup"><span data-stu-id="903d7-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

<span data-ttu-id="903d7-179">`GetCacheItem(key)` 不使用*密钥*值提供，而是调用`GetCacheKey(key)`方法，它返回*密钥*前面带有 ProductsCache-。</span><span class="sxs-lookup"><span data-stu-id="903d7-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="903d7-180">`MasterCacheKeyArray`，其中包含的字符串 ProductsCache，也可由`AddCacheItem(key, value)`方法，如我们所见短暂出现。</span><span class="sxs-lookup"><span data-stu-id="903d7-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="903d7-181">从 ASP.NET 页的代码隐藏类，则数据可以访问缓存使用`Page`类 s [ `Cache`属性](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)，并允许进行这样的语法`Cache["key"] = value`，在步骤 2 中所述。</span><span class="sxs-lookup"><span data-stu-id="903d7-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache["key"] = value`, as discussed in Step 2.</span></span> <span data-ttu-id="903d7-182">从体系结构中的类，则数据可以访问缓存使用`HttpRuntime.Cache`或`HttpContext.Current.Cache`。</span><span class="sxs-lookup"><span data-stu-id="903d7-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="903d7-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)的博客文章[HttpRuntime.Cache vs。HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)说明中使用的略微的性能优点`HttpRuntime`而不是`HttpContext.Current`; 因此，`ProductsCL`使用`HttpRuntime`。</span><span class="sxs-lookup"><span data-stu-id="903d7-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="903d7-184">如果使用类库项目实现你的体系结构，则将需要添加对的引用`System.Web`若要使用的程序集[HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)和[HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)类。</span><span class="sxs-lookup"><span data-stu-id="903d7-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="903d7-185">如果在缓存中，未找到该项目`ProductsCL`类的方法从 BLL 获取数据并将其添加到缓存使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="903d7-186">若要添加*值*到缓存中，我们可以使用下面的代码，使用 60 秒的时间到期：</span><span class="sxs-lookup"><span data-stu-id="903d7-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

<span data-ttu-id="903d7-187">`DateTime.Now.AddSeconds(CacheDuration)` 在将来的段中指定的基于时间的到期时间 60 秒[ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)指示没有 s 不会滑动过期。</span><span class="sxs-lookup"><span data-stu-id="903d7-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="903d7-188">虽然这`Insert`方法重载具有输入参数的这两个绝对，滑动到期，你可以仅提供两种状态之一。</span><span class="sxs-lookup"><span data-stu-id="903d7-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="903d7-189">如果你尝试指定一个绝对时间和时间跨度，`Insert`方法会引发`ArgumentException`异常。</span><span class="sxs-lookup"><span data-stu-id="903d7-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="903d7-190">此实现的`AddCacheItem(key, value)`方法当前存在一些不足。</span><span class="sxs-lookup"><span data-stu-id="903d7-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="903d7-191">我们解决，克服在步骤 4 中的这些问题。</span><span class="sxs-lookup"><span data-stu-id="903d7-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="903d7-192">步骤 4： 失效缓存时数据是修改通过体系结构</span><span class="sxs-lookup"><span data-stu-id="903d7-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="903d7-193">数据检索方法，以及缓存层需要提供相同的方法中，同时作为 BLL 插入、 更新和删除数据。</span><span class="sxs-lookup"><span data-stu-id="903d7-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="903d7-194">CL 的数据修改方法不需要修改缓存的数据，而是调用 BLL s 相应数据修改方法但然后使缓存失效的。</span><span class="sxs-lookup"><span data-stu-id="903d7-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="903d7-195">正如我们看到在前面的教程，这是相同的行为时启用其缓存功能 ObjectDataSource 应用并将其`Insert`， `Update`，或`Delete`调用方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="903d7-196">以下`UpdateProduct`重载演示如何在 CL 中实现数据修改方法：</span><span class="sxs-lookup"><span data-stu-id="903d7-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

<span data-ttu-id="903d7-197">调用适当的数据修改业务逻辑层方法时，但返回其响应之前，我们需要使缓存失效的。</span><span class="sxs-lookup"><span data-stu-id="903d7-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="903d7-198">遗憾的是，从而导致无效缓存不是简单直接因为`ProductsCL`类 s`GetProducts()`和`GetProductsByCategoryID(categoryID)`方法每个项向缓存添加具有不同键和`GetProductsByCategoryID(categoryID)`方法将不同的缓存项添加每个唯一*categoryID*。</span><span class="sxs-lookup"><span data-stu-id="903d7-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="903d7-199">当使缓存失效，我们需要删除*所有*已通过添加的项`ProductsCL`类。</span><span class="sxs-lookup"><span data-stu-id="903d7-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="903d7-200">这可以通过将相关联来实现*缓存依赖项*与每个项添加到缓存中`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="903d7-201">通常情况下，缓存依赖项可以是缓存、 文件系统或 Microsoft SQL Server 数据库中的数据上的文件中的另一个项。</span><span class="sxs-lookup"><span data-stu-id="903d7-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="903d7-202">依赖项更改或是时从缓存中删除，与之关联的缓存项将自动从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="903d7-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="903d7-203">对于本教程，我们想要创建可用作所有项的缓存依赖项添加到缓存中的附加项`ProductsCL`类。</span><span class="sxs-lookup"><span data-stu-id="903d7-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="903d7-204">这样一来，所有这些项可以是从缓存中删除通过只需删除缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="903d7-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="903d7-205">让的 s 更新`AddCacheItem(key, value)`方法，以便每个项通过此方法添加到缓存是单个缓存依赖项与相关联：</span><span class="sxs-lookup"><span data-stu-id="903d7-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

<span data-ttu-id="903d7-206">`MasterCacheKeyArray` 是一个字符串数组，包含单个值，ProductsCache。</span><span class="sxs-lookup"><span data-stu-id="903d7-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="903d7-207">首先，缓存项添加到缓存中并分配的当前日期和时间。</span><span class="sxs-lookup"><span data-stu-id="903d7-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="903d7-208">如果缓存项已存在，则它更新内容。</span><span class="sxs-lookup"><span data-stu-id="903d7-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="903d7-209">接下来，创建缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="903d7-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="903d7-210">[ `CacheDependency`类](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)s 构造函数具有大量的重载，但在此处中正在使用需要两个`string`数组输入。</span><span class="sxs-lookup"><span data-stu-id="903d7-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `string` array inputs.</span></span> <span data-ttu-id="903d7-211">第一个指定要用作依赖项的文件集。</span><span class="sxs-lookup"><span data-stu-id="903d7-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="903d7-212">由于我们不希望使用任何基于文件的依赖关系，值为 t`null`用于第一个输入参数。</span><span class="sxs-lookup"><span data-stu-id="903d7-212">Since we don t want to use any file-based dependencies, a value of `null` is used for the first input parameter.</span></span> <span data-ttu-id="903d7-213">第二个输入的参数指定缓存密钥要用作依赖项的集。</span><span class="sxs-lookup"><span data-stu-id="903d7-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="903d7-214">在这里，我们指定我们依赖项， `MasterCacheKeyArray`。</span><span class="sxs-lookup"><span data-stu-id="903d7-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="903d7-215">`CacheDependency`然后传递到`Insert`方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="903d7-216">在此修改`AddCacheItem(key, value)`、 invaliding 缓存非常简单，只删除的依赖关系。</span><span class="sxs-lookup"><span data-stu-id="903d7-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="903d7-217">步骤 5： 从表示层调用缓存层</span><span class="sxs-lookup"><span data-stu-id="903d7-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="903d7-218">缓存层的类和方法可以用于处理数据使用的技术我们已检查整个这些教程。</span><span class="sxs-lookup"><span data-stu-id="903d7-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="903d7-219">为了说明使用缓存数据，你将更改保存至`ProductsCL`类，然后打开`FromTheArchitecture.aspx`页面`Caching`文件夹并添加一个 GridView。</span><span class="sxs-lookup"><span data-stu-id="903d7-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="903d7-220">从 GridView s 智能标记，创建新对象数据源。</span><span class="sxs-lookup"><span data-stu-id="903d7-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="903d7-221">在向导 s 第一步，你应看到`ProductsCL`类作为一个下拉列表中的选项。</span><span class="sxs-lookup"><span data-stu-id="903d7-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="903d7-222">[![ProductsCL 类包含在业务对象下拉列表](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="903d7-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span></span>

<span data-ttu-id="903d7-223">**图 4**:`ProductsCL`类包括在业务对象下拉列表中 ([单击以查看实际尺寸的图像](caching-data-in-the-architecture-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="903d7-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image6.png))</span></span>


<span data-ttu-id="903d7-224">选择后`ProductsCL`，单击下一步。</span><span class="sxs-lookup"><span data-stu-id="903d7-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="903d7-225">下拉列表中选择的选项卡上有两项-`GetProducts()`和`GetProductsByCategoryID(categoryID)`和更新选项卡具有唯一`UpdateProduct`重载。</span><span class="sxs-lookup"><span data-stu-id="903d7-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="903d7-226">选择`GetProducts()`从选择的选项卡上的方法和`UpdateProducts`方法从该更新选项卡，然后单击完成。</span><span class="sxs-lookup"><span data-stu-id="903d7-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="903d7-227">[![下拉列表中列出了 ProductsCL 类的方法](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="903d7-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span></span>

<span data-ttu-id="903d7-228">**图 5**:`ProductsCL`下拉列表中列出了类的方法 ([单击以查看实际尺寸的图像](caching-data-in-the-architecture-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="903d7-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image9.png))</span></span>


<span data-ttu-id="903d7-229">完成向导后，Visual Studio 将设置 ObjectDataSource s`OldValuesParameterFormatString`属性`original_{0}`并将相应的字段添加到 GridView。</span><span class="sxs-lookup"><span data-stu-id="903d7-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="903d7-230">更改`OldValuesParameterFormatString`回其默认值，属性`{0}`，和配置以支持分页、 排序和编辑 GridView。</span><span class="sxs-lookup"><span data-stu-id="903d7-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="903d7-231">由于`UploadProducts`重载使用 CL 接受编辑的产品的名称和价格，限制 GridView，以便仅这些字段是可编辑。</span><span class="sxs-lookup"><span data-stu-id="903d7-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="903d7-232">在前面的教程，我们定义一个 GridView，若要包含的字段`ProductName`， `CategoryName`，和`UnitPrice`字段。</span><span class="sxs-lookup"><span data-stu-id="903d7-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="903d7-233">请尝试复制此格式设置和结构，在这种情况下声明性你 GridView 和 ObjectDataSource 的标记应类似于以下：</span><span class="sxs-lookup"><span data-stu-id="903d7-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

<span data-ttu-id="903d7-234">此时我们有一个使用缓存层的页面。</span><span class="sxs-lookup"><span data-stu-id="903d7-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="903d7-235">若要查看操作中的缓存，在中设置断点`ProductsCL`类 s`GetProducts()`和`UpdateProduct`方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="903d7-236">当从缓存中提取排序和分页才能查看的数据时，请访问浏览器和逐句通过代码中的页。</span><span class="sxs-lookup"><span data-stu-id="903d7-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="903d7-237">然后更新的记录，并请注意，缓存失效，因此，它从 BLL 时检索数据重新绑定到 GridView。</span><span class="sxs-lookup"><span data-stu-id="903d7-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="903d7-238">下载伴随这篇文章中提供了缓存层不完整。</span><span class="sxs-lookup"><span data-stu-id="903d7-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="903d7-239">它包含只有一个类， `ProductsCL`，其中仅运动少量的方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="903d7-240">此外，仅将一个 ASP.NET 页面使用 CL (`~/Caching/FromTheArchitecture.aspx`) 所有其他用户仍 BLL 直接引用。</span><span class="sxs-lookup"><span data-stu-id="903d7-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="903d7-241">如果你计划在你的应用程序中使用 CL，与表示层的所有调用都应都发送到 CL，将要求 CL 的类和方法涵盖这些类和 BLL 当前使用的表示层中的方法。</span><span class="sxs-lookup"><span data-stu-id="903d7-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="903d7-242">总结</span><span class="sxs-lookup"><span data-stu-id="903d7-242">Summary</span></span>

<span data-ttu-id="903d7-243">时可在表示层为 ASP.NET 2.0 的 SqlDataSource 和 ObjectDataSource 控件应用缓存，理想情况下缓存职责会将委派给一个单独的层体系结构中。</span><span class="sxs-lookup"><span data-stu-id="903d7-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="903d7-244">在本教程中我们创建一个表示层和业务逻辑层之间驻留的缓存层。</span><span class="sxs-lookup"><span data-stu-id="903d7-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="903d7-245">需要提供一组相同的类和方法中 BLL 存在并从表示层调用缓存层。</span><span class="sxs-lookup"><span data-stu-id="903d7-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="903d7-246">我们探讨了在此示例和前面教程的缓存层示例表现出*反应加载*。</span><span class="sxs-lookup"><span data-stu-id="903d7-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="903d7-247">反应加载数据加载到缓存，仅当发出数据请求，该数据是从缓存缺少时。</span><span class="sxs-lookup"><span data-stu-id="903d7-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="903d7-248">也可以是数据*主动加载*到缓存中，一种技术，将数据加载到缓存之前实际需要。</span><span class="sxs-lookup"><span data-stu-id="903d7-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="903d7-249">在下一教程中我们将看到举例说明主动加载我们查看如何将静态值存储到缓存在应用程序启动时。</span><span class="sxs-lookup"><span data-stu-id="903d7-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="903d7-250">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="903d7-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="903d7-251">关于作者</span><span class="sxs-lookup"><span data-stu-id="903d7-251">About the Author</span></span>

<span data-ttu-id="903d7-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="903d7-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="903d7-253">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="903d7-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="903d7-254">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="903d7-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="903d7-255">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="903d7-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="903d7-256">特别感谢</span><span class="sxs-lookup"><span data-stu-id="903d7-256">Special Thanks To</span></span>

<span data-ttu-id="903d7-257">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="903d7-257">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="903d7-258">本教程中的前导审阅者已 Teresa Murph。</span><span class="sxs-lookup"><span data-stu-id="903d7-258">Lead reviewer for this tutorial was Teresa Murph.</span></span> <span data-ttu-id="903d7-259">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="903d7-259">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="903d7-260">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="903d7-260">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="903d7-261">[上一页](caching-data-with-the-objectdatasource-cs.md)
> [下一页](caching-data-at-application-startup-cs.md)</span><span class="sxs-lookup"><span data-stu-id="903d7-261">[Previous](caching-data-with-the-objectdatasource-cs.md)
[Next](caching-data-at-application-startup-cs.md)</span></span>
