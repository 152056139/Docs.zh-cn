---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: "缓存数据在应用程序启动 (C#) |Microsoft 文档"
author: rick-anderson
description: "在任何 Web 应用程序中的某些数据将经常使用，并将不常使用的某些数据。 我们可以改进我们的 ASP.NET 应用程序 b 的性能..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: ccf22f9e72777242ca0239aee69045ab03d56960
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="caching-data-at-application-startup-c"></a><span data-ttu-id="a3403-104">缓存数据在应用程序启动 (C#)</span><span class="sxs-lookup"><span data-stu-id="a3403-104">Caching Data at Application Startup (C#)</span></span>
====================
<span data-ttu-id="a3403-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="a3403-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="a3403-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="a3403-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="a3403-107">在任何 Web 应用程序中的某些数据将经常使用，并将不常使用的某些数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="a3403-108">我们可以通过提前加载经常使用的数据，称为的方法来改进我们的 ASP.NET 应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="a3403-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as.</span></span> <span data-ttu-id="a3403-109">本教程演示主动加载，这是将数据加载到缓存在应用程序启动的一种方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>


## <a name="introduction"></a><span data-ttu-id="a3403-110">介绍</span><span class="sxs-lookup"><span data-stu-id="a3403-110">Introduction</span></span>

<span data-ttu-id="a3403-111">缓存中的演示文稿和缓存层的数据看两个前面的教程。</span><span class="sxs-lookup"><span data-stu-id="a3403-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="a3403-112">在[缓存数据与 ObjectDataSource](caching-data-with-the-objectdatasource-cs.md)，我们看使用缓存在表示层中缓存数据的功能的 ObjectDataSource s。</span><span class="sxs-lookup"><span data-stu-id="a3403-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource s caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="a3403-113">[缓存体系结构中的数据](caching-data-in-the-architecture-cs.md)检查在缓存中新的、 独立缓存层。</span><span class="sxs-lookup"><span data-stu-id="a3403-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="a3403-114">这两个使用这些教程*反应加载*中使用数据缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="a3403-115">反应加载，每次请求数据时，系统会首先检查如果它在缓存中的 s。</span><span class="sxs-lookup"><span data-stu-id="a3403-115">With reactive loading, each time the data is requested, the system first checks if it s in the cache.</span></span> <span data-ttu-id="a3403-116">如果没有，它获取原始的源，例如数据库中的数据，然后将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="a3403-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="a3403-117">反应加载的主要优点是它易于实现。</span><span class="sxs-lookup"><span data-stu-id="a3403-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="a3403-118">其缺点之一跨请求是其不均匀的性能。</span><span class="sxs-lookup"><span data-stu-id="a3403-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="a3403-119">假设使用前面教程中的缓存层来显示产品信息页。</span><span class="sxs-lookup"><span data-stu-id="a3403-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="a3403-120">当此页是首次访问或访问第一次缓存的数据已逐出由于内存约束或具有已达到指定的到期后时，必须从数据库检索的数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="a3403-121">因此，这些用户请求将由缓存需要超过可提供的用户请求。</span><span class="sxs-lookup"><span data-stu-id="a3403-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="a3403-122">*主动加载*通过备用缓存管理策略性能平滑处理跨请求加载需要的才将其缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it s needed.</span></span> <span data-ttu-id="a3403-123">通常情况下，主动加载使用某些进程，可定期检查或时已对基础数据的更新通知。</span><span class="sxs-lookup"><span data-stu-id="a3403-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="a3403-124">然后，此进程会更新要保持最新的缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="a3403-125">主动加载是基础的数据来自慢速数据库连接、 Web 服务或某些其他特别缓慢的数据源尤其有用。</span><span class="sxs-lookup"><span data-stu-id="a3403-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="a3403-126">但主动加载此方法是更难实现，因为它需要创建、 管理和部署一个过程来检查更改并更新缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="a3403-127">另一个风格的主动加载和我们将在本教程中，浏览的类型将数据加载到缓存在应用程序启动。</span><span class="sxs-lookup"><span data-stu-id="a3403-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="a3403-128">此方法非常适合缓存静态数据，如数据库查找表中的记录。</span><span class="sxs-lookup"><span data-stu-id="a3403-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="a3403-129">有关了解主动式和反应式加载以及专业人员、 利弊和实现建议的列表之间的差异的更深入信息，请参阅[管理缓存的内容](https://msdn.microsoft.com/en-us/library/ms978503.aspx)部分[缓存.NET Framework 应用程序的体系结构指南](https://msdn.microsoft.com/en-us/library/ms978498.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a3403-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/en-us/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/en-us/library/ms978498.aspx).</span></span>


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="a3403-130">步骤 1： 确定哪些数据缓存在应用程序启动</span><span class="sxs-lookup"><span data-stu-id="a3403-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="a3403-131">在将以前的两个教程工作很好地与数据，可能会定期更改才会 exorbitantly 长以便生成我们检查缓存的示例使用反应加载。</span><span class="sxs-lookup"><span data-stu-id="a3403-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="a3403-132">但如果缓存的数据永远不会更改，使用反应加载的到期时间是多余。</span><span class="sxs-lookup"><span data-stu-id="a3403-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="a3403-133">同样，如果正在缓存的数据所需生成极其长时间，则检索这些用户其请求查找缓存空需要 endure 基础数据时等待较长时间。</span><span class="sxs-lookup"><span data-stu-id="a3403-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="a3403-134">请考虑缓存静态数据和需要极长的时间才能生成在应用程序启动的数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="a3403-135">虽然数据库有许多动态，频繁地更改值，但大多数还具有相当大的静态数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="a3403-136">例如，几乎所有的数据模型具有包含一组固定的选择的特定值的一个或多个列。</span><span class="sxs-lookup"><span data-stu-id="a3403-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="a3403-137">A`Patients`数据库表中可能有`PrimaryLanguage`列，其组的值可能是英语、 西班牙语、 法语、 俄语、 日语和等等。</span><span class="sxs-lookup"><span data-stu-id="a3403-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="a3403-138">通常，使用实现这些类型的列*查找表*。</span><span class="sxs-lookup"><span data-stu-id="a3403-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="a3403-139">而不是存储的字符串英语或法语中的`Patients`，第二个表创建表，通常情况下，具有两个列中的唯一标识符和字符串说明-与每个可能值的记录。</span><span class="sxs-lookup"><span data-stu-id="a3403-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="a3403-140">`PrimaryLanguage`中的列`Patients`表查找表中存储的相应的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="a3403-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="a3403-141">图 1 中患者 John Doe s 主要语言是英语，Ed Johnson s 俄语时。</span><span class="sxs-lookup"><span data-stu-id="a3403-141">In Figure 1, patient John Doe s primary language is English, while Ed Johnson s is Russian.</span></span>


![语言表是通过 Patients 表使用查找表](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="a3403-143">**图 1**:`Languages`表是通过使用查找表`Patients`表</span><span class="sxs-lookup"><span data-stu-id="a3403-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>


<span data-ttu-id="a3403-144">编辑或创建一个新患者的用户界面将包括允许的语言中的记录由填充的下拉列表`Languages`表。</span><span class="sxs-lookup"><span data-stu-id="a3403-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="a3403-145">不使用缓存功能，此接口是每次访问系统必须查询`Languages`表。</span><span class="sxs-lookup"><span data-stu-id="a3403-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="a3403-146">这是浪费和不必要因为查找表值进行更改很少，如果有。</span><span class="sxs-lookup"><span data-stu-id="a3403-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="a3403-147">我们无法缓存`Languages`使用相同反应加载技术来检查前面的教程中的数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="a3403-148">反应加载，但是，使用基于时间的到期，就不必要的静态查找表数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="a3403-149">虽然缓存使用反应加载将无缓存根本更好，最好的方法将主动将查找表数据加载到缓存在应用程序启动。</span><span class="sxs-lookup"><span data-stu-id="a3403-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="a3403-150">在本教程中我们将查看如何缓存查找表数据和其他静态信息。</span><span class="sxs-lookup"><span data-stu-id="a3403-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="a3403-151">第 2 步： 检查缓存数据的不同方式</span><span class="sxs-lookup"><span data-stu-id="a3403-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="a3403-152">可以使用各种方法的 ASP.NET 应用程序中以编程方式缓存信息。</span><span class="sxs-lookup"><span data-stu-id="a3403-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="a3403-153">我们已介绍了如何在前面的教程中使用数据缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="a3403-154">或者，对象可以以编程方式缓存使用*静态成员*或*应用程序状态*。</span><span class="sxs-lookup"><span data-stu-id="a3403-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="a3403-155">在使用类，通常必须首先为类实例化之前可以访问其成员。</span><span class="sxs-lookup"><span data-stu-id="a3403-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="a3403-156">例如，若要调用我们的业务逻辑层中的类的一个方法，我们必须先创建类的实例：</span><span class="sxs-lookup"><span data-stu-id="a3403-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="a3403-157">我们可以调用之前*SomeMethod*或使用*SomeProperty*，我们必须先创建类使用的实例`new`关键字。</span><span class="sxs-lookup"><span data-stu-id="a3403-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="a3403-158">*SomeMethod*和*SomeProperty*与特定实例相关联。</span><span class="sxs-lookup"><span data-stu-id="a3403-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="a3403-159">这些成员的生存期取决于其关联的对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="a3403-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="a3403-160">*静态成员*，另一方面，是变量、 属性和方法之间共享*所有*类的实例，因此，具有与类一样长的生存期。</span><span class="sxs-lookup"><span data-stu-id="a3403-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="a3403-161">静态成员表示由关键字`static`。</span><span class="sxs-lookup"><span data-stu-id="a3403-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="a3403-162">除了静态成员，可以使用应用程序状态缓存数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="a3403-163">每个 ASP.NET 应用程序保持一个名称/值集合内所有用户和应用程序页共享该 s。</span><span class="sxs-lookup"><span data-stu-id="a3403-163">Each ASP.NET application maintains a name/value collection that s shared across all users and pages of the application.</span></span> <span data-ttu-id="a3403-164">可以使用访问此集合[`HttpContext`类](https://msdn.microsoft.com/en-us/library/system.web.httpcontext.aspx)s [ `Application`属性](https://msdn.microsoft.com/en-us/library/system.web.httpcontext.application.aspx)，并且从 ASP.NET 页的代码隐藏类使用，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a3403-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/en-us/library/system.web.httpcontext.aspx) s [`Application` property](https://msdn.microsoft.com/en-us/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page s code-behind class like so:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="a3403-165">数据缓存的缓存数据，对于基于时间和依赖项的满、 缓存项属性的更多信息，其含义提供机制提供一个多更丰富的 API。</span><span class="sxs-lookup"><span data-stu-id="a3403-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="a3403-166">使用静态成员和应用程序状态，此类功能必须手动添加页面开发人员。</span><span class="sxs-lookup"><span data-stu-id="a3403-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="a3403-167">当应用程序的生存期内缓存在应用程序启动的数据，但是，数据缓存的优点是毫无意义。</span><span class="sxs-lookup"><span data-stu-id="a3403-167">When caching data at application startup for the lifetime of the application, however, the data cache s advantages are moot.</span></span> <span data-ttu-id="a3403-168">在本教程中我们将查看有关缓存静态数据使用所有这三种技术的代码。</span><span class="sxs-lookup"><span data-stu-id="a3403-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="a3403-169">步骤 3： 缓存`Suppliers`表数据</span><span class="sxs-lookup"><span data-stu-id="a3403-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="a3403-170">Northwind 数据库表我们已实施方法与日期不包括任何传统的查找表。</span><span class="sxs-lookup"><span data-stu-id="a3403-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="a3403-171">实现四个数据表中我们 DAL 其值是非静态的所有模型表。</span><span class="sxs-lookup"><span data-stu-id="a3403-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="a3403-172">而不是花费时间来将新数据表添加到 DAL，然后新类和方法为 BLL，本教程只需让 s 假设，`Suppliers`表的数据是静态的。</span><span class="sxs-lookup"><span data-stu-id="a3403-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let s just pretend that the `Suppliers` table s data is static.</span></span> <span data-ttu-id="a3403-173">因此，我们无法缓存此数据在应用程序启动。</span><span class="sxs-lookup"><span data-stu-id="a3403-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="a3403-174">若要开始，创建一个名为的新类`StaticCache.cs`中`CL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="a3403-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>


![在 CL 文件夹中创建 StaticCache.cs 类](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="a3403-176">**图 2**： 创建`StaticCache.cs`类`CL`文件夹</span><span class="sxs-lookup"><span data-stu-id="a3403-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>


<span data-ttu-id="a3403-177">我们需要添加将在启动数据加载到合适的缓存存储中，一个方法，以及从此缓存中返回数据的方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="a3403-178">上面的代码中使用静态成员变量， `suppliers`、 保存的结果从`SuppliersBLL`类 s`GetSuppliers()`方法，从调用`LoadStaticCache()`方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class s `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="a3403-179">`LoadStaticCache()`方法旨在在应用程序的启动过程中调用。</span><span class="sxs-lookup"><span data-stu-id="a3403-179">The `LoadStaticCache()` method is meant to be called during the application s start.</span></span> <span data-ttu-id="a3403-180">需要使用供应商数据的任何页面后已在应用程序启动时加载此数据，可以调用`StaticCache`类的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class s `GetSuppliers()` method.</span></span> <span data-ttu-id="a3403-181">因此，对数据库的调用，以获取供应商只出现一次，启动应用程序时。</span><span class="sxs-lookup"><span data-stu-id="a3403-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="a3403-182">而不是作为缓存存储区中使用的静态成员变量，我们本来也可以或者使用应用程序状态或数据缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="a3403-183">下面的代码演示重组使用应用程序状态的类：</span><span class="sxs-lookup"><span data-stu-id="a3403-183">The following code shows the class retooled to use application state:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="a3403-184">在`LoadStaticCache()`，供应商信息存储到应用程序变量*密钥*。</span><span class="sxs-lookup"><span data-stu-id="a3403-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="a3403-185">它返回以适合的类型 (`Northwind.SuppliersDataTable`) 从`GetSuppliers()`。</span><span class="sxs-lookup"><span data-stu-id="a3403-185">It s returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="a3403-186">虽然可在 ASP.NET 页使用的代码隐藏类访问应用程序状态`Application["key"]`，我们必须使用的体系结构中`HttpContext.Current.Application["key"]`以获取当前`HttpContext`。</span><span class="sxs-lookup"><span data-stu-id="a3403-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="a3403-187">同样，数据缓存可以用作缓存存储区中，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="a3403-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="a3403-188">若要将项添加到数据缓存的任何基于时间的到期，使用`System.Web.Caching.Cache.NoAbsoluteExpiration`和`System.Web.Caching.Cache.NoSlidingExpiration`作为输入参数的值。</span><span class="sxs-lookup"><span data-stu-id="a3403-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="a3403-189">数据缓存 s 此特定重载`Insert`已选择方法，因此，我们还可以指定*优先级*的缓存项。</span><span class="sxs-lookup"><span data-stu-id="a3403-189">This particular overload of the data cache s `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="a3403-190">优先级用于确定要清除从缓存中，当可用内存不足时哪些项。</span><span class="sxs-lookup"><span data-stu-id="a3403-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="a3403-191">我们在此处使用优先级`NotRemovable`，这可确保此缓存项获胜 t 清理。</span><span class="sxs-lookup"><span data-stu-id="a3403-191">Here we use the priority `NotRemovable`, which ensures that this cache item won t be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="a3403-192">此教程的下载实现`StaticCache`类使用的静态成员变量的方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-192">This tutorial s download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="a3403-193">中的类文件中的注释提供了应用程序状态和数据缓存技术的代码。</span><span class="sxs-lookup"><span data-stu-id="a3403-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>


## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="a3403-194">步骤 4： 执行在应用程序启动代码</span><span class="sxs-lookup"><span data-stu-id="a3403-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="a3403-195">若要执行代码，web 应用程序首次启动时，我们需要创建一个名为的特殊文件`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="a3403-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="a3403-196">此文件可以包含事件处理程序应用程序-，会话，并且请求级事件，也是如此此处我们可在其中添加每当应用程序启动时将执行的代码。</span><span class="sxs-lookup"><span data-stu-id="a3403-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="a3403-197">添加`Global.asax`到 web 应用程序的根目录通过右键单击 Visual Studio 的解决方案资源管理器中的网站项目名称并选择添加新项的文件。</span><span class="sxs-lookup"><span data-stu-id="a3403-197">Add the `Global.asax` file to your web application s root directory by right-clicking on the website project name in Visual Studio s Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="a3403-198">从添加新项对话框中，选择全局应用程序类项目类型，然后单击添加按钮。</span><span class="sxs-lookup"><span data-stu-id="a3403-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="a3403-199">如果你已有`Global.asax`文件在项目中，全局项类型将不会列出在添加新项对话框中的应用程序类。</span><span class="sxs-lookup"><span data-stu-id="a3403-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>


<span data-ttu-id="a3403-200">[![将 Global.asax 文件添加到 Web 应用程序的根目录](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="a3403-200">[![Add the Global.asax File to Your Web Application s Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="a3403-201">**图 3**： 添加`Global.asax`到你的 Web 应用程序 s 根目录的文件 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="a3403-201">**Figure 3**: Add the `Global.asax` File to Your Web Application s Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>


<span data-ttu-id="a3403-202">默认值`Global.asax`文件模板包括服务器端中的五个方法`<script>`标记：</span><span class="sxs-lookup"><span data-stu-id="a3403-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="a3403-203">**`Application_Start`**在 web 应用程序第一次启动时执行</span><span class="sxs-lookup"><span data-stu-id="a3403-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="a3403-204">**`Application_End`**在应用程序关闭时运行</span><span class="sxs-lookup"><span data-stu-id="a3403-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="a3403-205">**`Application_Error`**执行时未处理的异常到达应用程序</span><span class="sxs-lookup"><span data-stu-id="a3403-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="a3403-206">**`Session_Start`**在创建新的会话时执行</span><span class="sxs-lookup"><span data-stu-id="a3403-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="a3403-207">**`Session_End`**运行时会话已过期或已放弃</span><span class="sxs-lookup"><span data-stu-id="a3403-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="a3403-208">`Application_Start` S 应用程序生命周期内仅一次调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a3403-208">The `Application_Start` event handler is called only once during an application s life cycle.</span></span> <span data-ttu-id="a3403-209">在应用程序启动第一次 ASP.NET 资源从应用程序请求，继续运行，直到重新启动应用程序时，这可以通过修改内容的情况可能发生`/Bin`文件夹中，修改`Global.asax`，修改在内容`App_Code`文件夹，或修改`Web.config`文件，在其他原因。</span><span class="sxs-lookup"><span data-stu-id="a3403-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="a3403-210">请参阅[ASP.NET 应用程序生命周期概述](https://msdn.microsoft.com/en-us/library/ms178473.aspx)有关应用程序生命周期的更多详细讨论。</span><span class="sxs-lookup"><span data-stu-id="a3403-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/en-us/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="a3403-211">在本系列教程我们只需将代码添加到`Application_Start`方法，因此随意删除其他。</span><span class="sxs-lookup"><span data-stu-id="a3403-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="a3403-212">在`Application_Start`，只需调用`StaticCache`类的`LoadStaticCache()`方法，它将加载并缓存供应商信息：</span><span class="sxs-lookup"><span data-stu-id="a3403-212">In `Application_Start`, simply call the `StaticCache` class s `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="a3403-213">该 s 就是它 ！</span><span class="sxs-lookup"><span data-stu-id="a3403-213">That s all there is to it!</span></span> <span data-ttu-id="a3403-214">在应用程序启动`LoadStaticCache()`方法将获取供应商信息从 BLL，并将其存储在静态成员变量 (或任何缓存存储区中使用结束`StaticCache`类)。</span><span class="sxs-lookup"><span data-stu-id="a3403-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="a3403-215">若要验证此行为中, 设置断点`Application_Start`方法并运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="a3403-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="a3403-216">请注意，在应用程序启动时命中断点。</span><span class="sxs-lookup"><span data-stu-id="a3403-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="a3403-217">后续请求，但是，不会导致`Application_Start`要执行的方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>


<span data-ttu-id="a3403-218">[![使用验证 Application_Start 事件处理程序正在执行的断点](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="a3403-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="a3403-219">**图 4**： 使用验证断点，`Application_Start`事件处理程序是正在执行 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="a3403-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>


> [!NOTE]
> <span data-ttu-id="a3403-220">如果你不会命中`Application_Start`断点首次启动调试时，这是因为已经启动了你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a3403-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="a3403-221">强制应用程序重新启动通过修改你`Global.asax`或`Web.config`文件，然后重试。</span><span class="sxs-lookup"><span data-stu-id="a3403-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="a3403-222">你可以只需添加 （或删除） 空行末尾的这些文件之一来快速重新启动应用程序。</span><span class="sxs-lookup"><span data-stu-id="a3403-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>


## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="a3403-223">步骤 5： 显示缓存的数据</span><span class="sxs-lookup"><span data-stu-id="a3403-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="a3403-224">此时`StaticCache`类具有在应用程序启动，可以通过访问缓存的供应商数据的版本其`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="a3403-225">若要使用此数据与表示层，我们可以使用对象数据源，或以编程方式调用`StaticCache`类的`GetSuppliers()`从 ASP.NET 页的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class s `GetSuppliers()` method from an ASP.NET page s code-behind class.</span></span> <span data-ttu-id="a3403-226">让我们来看如何使用对象数据源和 GridView 控件以显示缓存供应商信息。</span><span class="sxs-lookup"><span data-stu-id="a3403-226">Let s look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="a3403-227">首先打开`AtApplicationStartup.aspx`页面`Caching`文件夹。</span><span class="sxs-lookup"><span data-stu-id="a3403-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="a3403-228">将 GridView 拖动从工具箱中拖动到设计器中，设置其`ID`属性`Suppliers`。</span><span class="sxs-lookup"><span data-stu-id="a3403-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="a3403-229">接下来，从 GridView s 智能标记选择创建名为新 ObjectDataSource `SuppliersCachedDataSource`。</span><span class="sxs-lookup"><span data-stu-id="a3403-229">Next, from the GridView s smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="a3403-230">配置对象数据源以使用`StaticCache`类的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="a3403-230">Configure the ObjectDataSource to use the `StaticCache` class s `GetSuppliers()` method.</span></span>


<span data-ttu-id="a3403-231">[![配置对象数据源以使用 StaticCache 类](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="a3403-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="a3403-232">**图 5**： 配置对象数据源以使用`StaticCache`类 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="a3403-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>


<span data-ttu-id="a3403-233">[![使用 GetSuppliers() 方法来检索缓存的供应商数据](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="a3403-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="a3403-234">**图 6**： 使用`GetSuppliers()`方法来检索缓存供应商数据 ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="a3403-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>


<span data-ttu-id="a3403-235">完成向导后，Visual Studio 将自动添加 BoundFields 中的数据字段的每个`SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="a3403-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="a3403-236">GridView 和 ObjectDataSource s 声明性标记应类似于以下形式：</span><span class="sxs-lookup"><span data-stu-id="a3403-236">Your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="a3403-237">图 7 显示通过浏览器查看时的页。</span><span class="sxs-lookup"><span data-stu-id="a3403-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="a3403-238">输出都是相同我们具有请求的数据来自 BLL s`SuppliersBLL`类，但使用`StaticCache`类返回作为缓存在应用程序启动的供应商数据。</span><span class="sxs-lookup"><span data-stu-id="a3403-238">The output is the same had we pulled the data from the BLL s `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="a3403-239">你可以在设置断点`StaticCache`类的`GetSuppliers()`方法以验证此行为。</span><span class="sxs-lookup"><span data-stu-id="a3403-239">You can set breakpoints in the `StaticCache` class s `GetSuppliers()` method to verify this behavior.</span></span>


<span data-ttu-id="a3403-240">[![缓存供应商数据显示在一个 GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="a3403-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="a3403-241">**图 7**: 缓存供应商数据将显示在一个 GridView ([单击以查看实际尺寸的图像](caching-data-at-application-startup-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="a3403-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>


## <a name="summary"></a><span data-ttu-id="a3403-242">摘要</span><span class="sxs-lookup"><span data-stu-id="a3403-242">Summary</span></span>

<span data-ttu-id="a3403-243">大多数每个数据模型包含大量的静态数据，在查找表的形式中通常实现。</span><span class="sxs-lookup"><span data-stu-id="a3403-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="a3403-244">由于此信息是静态的那里 s 没有理由不断地访问数据库每次需要显示此信息。</span><span class="sxs-lookup"><span data-stu-id="a3403-244">Since this information is static, there s no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="a3403-245">此外，由于其静态性质，缓存数据时那里 s 无需到期时间。</span><span class="sxs-lookup"><span data-stu-id="a3403-245">Furthermore, due to its static nature, when caching the data there s no need for an expiry.</span></span> <span data-ttu-id="a3403-246">在本教程中我们已了解如何执行此类数据并将数据缓存，应用程序状态，或通过静态成员变量对其进行缓存。</span><span class="sxs-lookup"><span data-stu-id="a3403-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="a3403-247">此信息缓存在应用程序启动，并保留在缓存在应用程序 s 整个生存期内。</span><span class="sxs-lookup"><span data-stu-id="a3403-247">This information is cached at application startup and remains in the cache throughout the application s lifetime.</span></span>

<span data-ttu-id="a3403-248">在本教程和过去两个，我们已讨论过的应用程序 s 有效期限的持续时间内缓存数据，以及使用基于时间的满。</span><span class="sxs-lookup"><span data-stu-id="a3403-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application s lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="a3403-249">当缓存数据库的数据，不过，基于时间的到期可能并不理想。</span><span class="sxs-lookup"><span data-stu-id="a3403-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="a3403-250">而不是定期刷新缓存，则可以仅逐出缓存的项，修改基础数据库数据时的最佳。</span><span class="sxs-lookup"><span data-stu-id="a3403-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="a3403-251">这种理想状态是可能通过 SQL 缓存的依赖项，我们将查看我们的下一教程中使用。</span><span class="sxs-lookup"><span data-stu-id="a3403-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="a3403-252">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="a3403-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="a3403-253">关于作者</span><span class="sxs-lookup"><span data-stu-id="a3403-253">About the Author</span></span>

<span data-ttu-id="a3403-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="a3403-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="a3403-255">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="a3403-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="a3403-256">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="a3403-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="a3403-257">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="a3403-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="a3403-258">特别感谢</span><span class="sxs-lookup"><span data-stu-id="a3403-258">Special Thanks To</span></span>

<span data-ttu-id="a3403-259">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="a3403-259">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="a3403-260">本教程中的前导审阅者已 Teresa 墨和 Zack Jones。</span><span class="sxs-lookup"><span data-stu-id="a3403-260">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="a3403-261">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="a3403-261">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="a3403-262">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="a3403-262">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a3403-263">[上一页](caching-data-in-the-architecture-cs.md)
[下一页](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="a3403-263">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
