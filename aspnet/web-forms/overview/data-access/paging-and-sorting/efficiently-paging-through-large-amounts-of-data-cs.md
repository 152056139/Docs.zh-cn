---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: "有效地分页大量的数据 (C#) |Microsoft 文档"
author: rick-anderson
description: "使用大量的数据，作为其基础数据源控件 retriev 时，数据的显示控件的默认分页选项不合适，则..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: ac16cc79f2ed6b62bf676553a374180cd0165632
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/24/2018
---
<a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="e3160-103">有效地分页大量的数据 (C#)</span><span class="sxs-lookup"><span data-stu-id="e3160-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>
====================
<span data-ttu-id="e3160-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e3160-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e3160-105">[下载示例应用程序](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe)或[下载 PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e3160-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="e3160-106">数据呈现控件的默认分页选项不合适，则在使用大量的数据，因为其基础数据源控件检索所有记录，即使显示数据的一个子集。</span><span class="sxs-lookup"><span data-stu-id="e3160-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="e3160-107">在这种情况下，我们必须打开的自定义分页。</span><span class="sxs-lookup"><span data-stu-id="e3160-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="e3160-108">介绍</span><span class="sxs-lookup"><span data-stu-id="e3160-108">Introduction</span></span>

<span data-ttu-id="e3160-109">如我们在前面的教程所述，可以采用两种方式之一实现分页：</span><span class="sxs-lookup"><span data-stu-id="e3160-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="e3160-110">**默认分页**可以通过只需选中启用分页选项中的数据的 Web 控件 s 智能标记; 但是，只要查看一页数据，ObjectDataSource 检索*所有*的记录，即使但在页中显示它们的子集</span><span class="sxs-lookup"><span data-stu-id="e3160-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="e3160-111">**自定义分页**提高了默认的性能通过从需要为用户; 请求的数据的特定页显示的数据库中检索只有这些记录分页但是，自定义分页涉及有点更多工作来实现比默认分页</span><span class="sxs-lookup"><span data-stu-id="e3160-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="e3160-112">因为实现只检查一个复选框，并重新易于完成 ！</span><span class="sxs-lookup"><span data-stu-id="e3160-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="e3160-113">默认分页是一个不错的选择。</span><span class="sxs-lookup"><span data-stu-id="e3160-113">default paging is an attractive option.</span></span> <span data-ttu-id="e3160-114">其 na 遇到做法中检索的所有记录，不过，使 implausible 选择时与许多并发用户分页的数据或站点足够大的量。</span><span class="sxs-lookup"><span data-stu-id="e3160-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="e3160-115">在这种情况下，我们必须打开的自定义分页以便提供响应系统。</span><span class="sxs-lookup"><span data-stu-id="e3160-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="e3160-116">自定义分页的挑战在于能够编写返回精确的所需的数据的特定页的记录集的查询。</span><span class="sxs-lookup"><span data-stu-id="e3160-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="e3160-117">幸运的是，Microsoft SQL Server 2005 提供一个新的关键字为排名结果，这使我们能够编写可以高效地检索记录的正确子集的查询。</span><span class="sxs-lookup"><span data-stu-id="e3160-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="e3160-118">在本教程中我们将了解如何使用此新的 SQL Server 2005 关键字 GridView 控件中实现自定义分页。</span><span class="sxs-lookup"><span data-stu-id="e3160-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="e3160-119">自定义分页的用户界面时同样默认分页，请单步执行从一页下一步使用适用于自定义分页可以比默认分页是几个数量级。</span><span class="sxs-lookup"><span data-stu-id="e3160-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="e3160-120">通过自定义分页表现出确切的性能提升取决于记录正在通过寻呼发送到和放置在数据库服务器上的负载的总数。</span><span class="sxs-lookup"><span data-stu-id="e3160-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="e3160-121">在本教程末尾中，我们将查看展示通过自定义分页获得的性能好处一些粗略度量值。</span><span class="sxs-lookup"><span data-stu-id="e3160-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="e3160-122">步骤 1： 了解自定义分页过程</span><span class="sxs-lookup"><span data-stu-id="e3160-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="e3160-123">当数据进行分页时, 在页上显示的精确记录取决于所请求的数据的页和每页显示的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="e3160-124">例如，假设我们想要通过 81 产品页上显示每页包含 10 种产品。</span><span class="sxs-lookup"><span data-stu-id="e3160-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="e3160-125">查看时的第一页，d 我们希望产品 1 到 10;查看的第二页时 d 我们感兴趣产品 11 到 20，依次类推。</span><span class="sxs-lookup"><span data-stu-id="e3160-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="e3160-126">有规定需要检索的记录和分页接口的呈现方式的三个变量：</span><span class="sxs-lookup"><span data-stu-id="e3160-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="e3160-127">**启动行索引**要显示的数据页中的第一行的索引; 通过页索引乘以每页显示的记录并添加一个计算此索引可以。</span><span class="sxs-lookup"><span data-stu-id="e3160-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="e3160-128">例如，如果通过记录 10 一次 （其页索引为 0） 的第一页的分页时, 启动行索引为 0 \* 10 + 1 或 1 个; 第二页 （其页索引为 1），启动行索引为 1 \* 10 + 1或 11。</span><span class="sxs-lookup"><span data-stu-id="e3160-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="e3160-129">**最大行数**最大每页显示的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="e3160-130">此变量称为最大行数，因为最后页有可能是较少的页大小比返回的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="e3160-131">例如，在查看 81 产品 10 记录每页的分页，第九个和最后一个页面将必须仅一条记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="e3160-132">不过，任何页，将不显示更多记录比最大行数的值。</span><span class="sxs-lookup"><span data-stu-id="e3160-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="e3160-133">**总计记录计数**总正在通过寻呼发送到的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="e3160-134">确定要为给定页检索的记录所需的此变量不是 t，尽管它未规定分页接口。</span><span class="sxs-lookup"><span data-stu-id="e3160-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="e3160-135">例如，如果有正在通过寻呼发送通过 81 产品，分页接口知道在分页用户界面中显示九个页号。</span><span class="sxs-lookup"><span data-stu-id="e3160-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="e3160-136">使用默认分页启动行索引将计算为产品的页索引和页面大小加 1，而最大行数是只需的页大小。</span><span class="sxs-lookup"><span data-stu-id="e3160-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="e3160-137">由于默认分页检索所有从记录为已知呈现任何数据页中，每一行的索引时的数据库，从而使移动到开始的行索引行一项重要任务。</span><span class="sxs-lookup"><span data-stu-id="e3160-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="e3160-138">此外，总计记录计数是易于使用，因为它 s 只需在 DataTable （或任何对象用于保存数据库结果） 的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="e3160-139">给定的开始的行索引和最大行数变量，自定义分页实现必须仅返回后，启动启动行索引处和最多的记录的最大行数的记录的精确的子集。</span><span class="sxs-lookup"><span data-stu-id="e3160-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="e3160-140">自定义分页提供两个难题：</span><span class="sxs-lookup"><span data-stu-id="e3160-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="e3160-141">我们必须能够高效地将行索引正在通过寻呼发送通过，以便我们可以开始返回指定的开始的行索引处的记录的整个数据中的每个行与相关联</span><span class="sxs-lookup"><span data-stu-id="e3160-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="e3160-142">我们需要提供的记录正在通过寻呼发送通过总数</span><span class="sxs-lookup"><span data-stu-id="e3160-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="e3160-143">在随后两个步骤中，我们将检查这些两个质询响应所需的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="e3160-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="e3160-144">除了 SQL 脚本中，我们还需要在 DAL 和 BLL 实现方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="e3160-145">步骤 2： 返回记录正在通过寻呼发送通过的总数</span><span class="sxs-lookup"><span data-stu-id="e3160-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="e3160-146">我们将研究如何检索正在显示的页面的记录的精确子集之前，让我们来首先看一下如何返回的记录正在通过寻呼发送通过总数。</span><span class="sxs-lookup"><span data-stu-id="e3160-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="e3160-147">为了正确配置的分页用户界面需要这些信息。</span><span class="sxs-lookup"><span data-stu-id="e3160-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="e3160-148">使用可以获取的特定 SQL 查询返回的记录总数[`COUNT`聚合函数](https://msdn.microsoft.com/library/ms175997.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e3160-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="e3160-149">例如，若要确定中的记录总数`Products`表，我们可以使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="e3160-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="e3160-150">让我们来将方法添加到我们 DAL 返回此信息。</span><span class="sxs-lookup"><span data-stu-id="e3160-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="e3160-151">具体而言，我们将创建名为 DAL 方法`TotalNumberOfProducts()`执行`SELECT`上面所示语句。</span><span class="sxs-lookup"><span data-stu-id="e3160-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="e3160-152">首先打开`Northwind.xsd`中的类型化数据集文件`App_Code/DAL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="e3160-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="e3160-153">接下来，右键单击`ProductsTableAdapter`设计器中，选择添加查询。</span><span class="sxs-lookup"><span data-stu-id="e3160-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="e3160-154">正如我们在前面的教程中看到的遇到这将使我们能够与 DAL 添加新方法，调用时，将执行特定的 SQL 语句或存储的过程。</span><span class="sxs-lookup"><span data-stu-id="e3160-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="e3160-155">与前面的教程中我们 TableAdapter 方法，在此选择使用的临时 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="e3160-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![使用临时 SQL 语句](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="e3160-157">**图 1**： 使用临时 SQL 语句</span><span class="sxs-lookup"><span data-stu-id="e3160-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="e3160-158">在下一个屏幕中，我们可以指定哪种类型的查询以创建。</span><span class="sxs-lookup"><span data-stu-id="e3160-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="e3160-159">因为此查询将返回单个标量值中的记录总数`Products`表选择`SELECT`它返回单个值选项。</span><span class="sxs-lookup"><span data-stu-id="e3160-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![配置要使用返回单个值的 SELECT 语句的查询](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="e3160-161">**图 2**： 配置要使用返回单个值的 SELECT 语句的查询</span><span class="sxs-lookup"><span data-stu-id="e3160-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="e3160-162">后，该值指示要使用的查询的类型，我们接下来必须指定查询。</span><span class="sxs-lookup"><span data-stu-id="e3160-162">After indicating the type of query to use, we must next specify the query.</span></span>


![使用从产品查询选择 COUNT(\*)](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="e3160-164">**图 3**： 使用选择的计数 (\*) FROM 产品查询</span><span class="sxs-lookup"><span data-stu-id="e3160-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="e3160-165">最后，指定方法的名称。</span><span class="sxs-lookup"><span data-stu-id="e3160-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="e3160-166">为前面提到，但仍使 s 使用`TotalNumberOfProducts`。</span><span class="sxs-lookup"><span data-stu-id="e3160-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![命名为 DAL 方法 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="e3160-168">**图 4**： 命名 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="e3160-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="e3160-169">单击完成，后，该向导将添加`TotalNumberOfProducts`与 DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="e3160-170">DAL 中的标量返回方法返回可以为 null 的类型，如果 SQL 查询的结果是`NULL`。</span><span class="sxs-lookup"><span data-stu-id="e3160-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="e3160-171">我们`COUNT`查询，但是，将始终返回非`NULL`值; 而不考虑，DAL 方法将返回为 null 的整数。</span><span class="sxs-lookup"><span data-stu-id="e3160-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="e3160-172">除了 DAL 方法中，我们还需要 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="e3160-173">打开`ProductsBLL`类文件，并添加`TotalNumberOfProducts`方法只需调用 DAL s`TotalNumberOfProducts`方法：</span><span class="sxs-lookup"><span data-stu-id="e3160-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="e3160-174">DAL s`TotalNumberOfProducts`方法返回为 null 的整数; 但是，我们已创建`ProductsBLL`类的`TotalNumberOfProducts`方法，以便它返回一个标准的整数。</span><span class="sxs-lookup"><span data-stu-id="e3160-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="e3160-175">因此，我们需要将`ProductsBLL`类 s`TotalNumberOfProducts`方法返回为 null 返回 DAL s 的整数的值部分`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="e3160-176">调用`GetValueOrDefault()`返回的值可以为 null 的整数，如果它存在，则可以为 null 的整数是否`null`，但是，它将返回默认整数值为 0。</span><span class="sxs-lookup"><span data-stu-id="e3160-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="e3160-177">步骤 3： 返回记录的精确的子集</span><span class="sxs-lookup"><span data-stu-id="e3160-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="e3160-178">我们的下一个任务是在 DAL 和接受启动行索引的 BLL 创建方法和最大行数变量前面所述，并返回相应的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="e3160-179">我们在此之前，让 s 先来看一下所需的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="e3160-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="e3160-180">我们面临的挑战是，我们必须要高效地将索引分配到整个结果正在通过寻呼发送通过，以便我们可以返回启动启动行索引处 （和最多的记录的最大记录数） 仅对这些记录中的每个行。</span><span class="sxs-lookup"><span data-stu-id="e3160-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="e3160-181">如果已存在列用作行索引的数据库表中，这不是一个难题。</span><span class="sxs-lookup"><span data-stu-id="e3160-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="e3160-182">第一次看到我们可能会认为`Products`表 s`ProductID`字段即可满足要求，因为第一个产品具有`ProductID`为 1，2，第二个，依此类推。</span><span class="sxs-lookup"><span data-stu-id="e3160-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="e3160-183">但是，删除产品会使序列，使这种方法中的存在间隔。</span><span class="sxs-lookup"><span data-stu-id="e3160-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="e3160-184">有两种常规技术用于有效地将行索引相关联的数据，能够分页浏览，从而支持记录要检索的精确子集：</span><span class="sxs-lookup"><span data-stu-id="e3160-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="e3160-185">**使用 SQL Server 2005 s`ROW_NUMBER()`关键字**到 SQL Server 2005 中，新`ROW_NUMBER()`关键字将排名的某些排序基于每个返回的记录与相关联。</span><span class="sxs-lookup"><span data-stu-id="e3160-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="e3160-186">此排名可以用作每个行的行索引。</span><span class="sxs-lookup"><span data-stu-id="e3160-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="e3160-187">**使用表变量和`SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT`语句](https://msdn.microsoft.com/library/ms188774.aspx)可以用于指定查询应终止; 之前处理的总记录数[表变量](http://www.sqlteam.com/item.asp?ItemID=9454)是本地的 T-SQL 的变量，可以容纳 akin 到表格数据、[临时表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="e3160-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="e3160-188">此方法适用于 Microsoft SQL Server 2005 和 SQL Server 2000 (而`ROW_NUMBER()`方法仅适用于 SQL Server 2005)。</span><span class="sxs-lookup"><span data-stu-id="e3160-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
 <span data-ttu-id="e3160-189">本指南旨在创建具有的表变量`IDENTITY`列和列的主键的表的数据通过正在通过寻呼发送。</span><span class="sxs-lookup"><span data-stu-id="e3160-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="e3160-190">接下来，将其数据通过正在通过寻呼发送表的内容转储到表变量中，从而将连续的行索引相关联 (通过`IDENTITY`列) 为表中每个记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="e3160-191">已填充的表变量之后,`SELECT`表变量中，语句与基础表联接，可以将执行拉出特定的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="e3160-192">`SET ROWCOUNT`语句用于智能地限制需要转储到表变量的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
 <span data-ttu-id="e3160-193">此方法的效率取决于所请求的页号作为`SET ROWCOUNT`值分配的值开始的行索引以及最大行数。</span><span class="sxs-lookup"><span data-stu-id="e3160-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="e3160-194">当通过： 编号较低的页面，例如第一个分页的数据的几个页面时这种方法是非常高效。</span><span class="sxs-lookup"><span data-stu-id="e3160-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="e3160-195">但是，它展示默认分页类似的性能，检索在其结尾附近的页时。</span><span class="sxs-lookup"><span data-stu-id="e3160-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="e3160-196">本教程通过实现自定义分页使用`ROW_NUMBER()`关键字。</span><span class="sxs-lookup"><span data-stu-id="e3160-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="e3160-197">有关使用表变量的详细信息和`SET ROWCOUNT`技术，请参阅[分页通过大型结果集的多个有效方法](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="e3160-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="e3160-198">`ROW_NUMBER()`关键字与通过使用以下语法执行特定排序返回每个记录关联排名：</span><span class="sxs-lookup"><span data-stu-id="e3160-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="e3160-199">`ROW_NUMBER()`返回一个数字值，指定每个记录方面指示排序的秩。</span><span class="sxs-lookup"><span data-stu-id="e3160-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="e3160-200">例如，若要查看每个产品按从最顺序排列的秩最少的成本较低我们无法使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="e3160-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="e3160-201">图 5 显示此查询的结果通过 Visual Studio 中的查询窗口运行时。</span><span class="sxs-lookup"><span data-stu-id="e3160-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="e3160-202">请注意，按价格，以及每个行的价格排名订购的产品。</span><span class="sxs-lookup"><span data-stu-id="e3160-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![价格级别所包含的每个返回的记录](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="e3160-204">**图 5**: 价格级别所包含的每个返回的记录</span><span class="sxs-lookup"><span data-stu-id="e3160-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="e3160-205">`ROW_NUMBER()`只是其中之一的许多新排名函数是在 SQL Server 2005 中可用。</span><span class="sxs-lookup"><span data-stu-id="e3160-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="e3160-206">有关的更全面讨论`ROW_NUMBER()`，以及其他排名函数，如读取[Microsoft SQL Server 2005 返回排名结果](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="e3160-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="e3160-207">当指定排名结果`ORDER BY`中的列`OVER`子句 (`UnitPrice`，在上面的示例)，SQL Server 必须将对结果进行排序。</span><span class="sxs-lookup"><span data-stu-id="e3160-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="e3160-208">这是快速操作，如果通过对结果进行，正在排序的列没有聚集的索引，或者如果没有覆盖索引，但会否则成本较高。</span><span class="sxs-lookup"><span data-stu-id="e3160-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="e3160-209">帮助改进足够大，查询的性能，请考虑添加按对结果排序所依据的列的非聚集索引。</span><span class="sxs-lookup"><span data-stu-id="e3160-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="e3160-210">请参阅[排名函数和 SQL Server 2005 中的性能](http://www.sql-server-performance.com/ak_ranking_functions.asp)了解性能注意事项的详细信息。</span><span class="sxs-lookup"><span data-stu-id="e3160-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="e3160-211">返回的排名信息`ROW_NUMBER()`中不能直接`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="e3160-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="e3160-212">但是，派生的表可以用于返回`ROW_NUMBER()`结果，然后可以出现在`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="e3160-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="e3160-213">例如，以下查询使用派生的表一起返回 ProductName 和 UnitPrice 列中，`ROW_NUMBER()`结果，然后使用`WHERE`子句，以便只返回这些产品价格排名为 11 到 20 之间：</span><span class="sxs-lookup"><span data-stu-id="e3160-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="e3160-214">扩展此得更深入的概念，我们可以利用这种方法来检索给定的所需的开始的行索引和最大行数值数据的某个特定页：</span><span class="sxs-lookup"><span data-stu-id="e3160-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="e3160-215">在本教程中，我们将会看到在更高版本上 *`StartRowIndex`* 提供 ObjectDataSource 编制了索引从零开始，启动而`ROW_NUMBER()`SQL Server 2005 返回值索引从 1 开始。</span><span class="sxs-lookup"><span data-stu-id="e3160-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="e3160-216">因此，`WHERE`子句将返回这些记录其中`PriceRank`完全大于 *`StartRowIndex`* 且小于或等于 *`StartRowIndex`*   + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="e3160-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="e3160-217">现在我们已讨论如何`ROW_NUMBER()`可以是用于检索给定的开始的行索引和最大行数值数据的特定页，我们现在需要实现此逻辑作为方法的 DAL 和 BLL。</span><span class="sxs-lookup"><span data-stu-id="e3160-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="e3160-218">创建我们必须决定排序此查询时所依据的结果将进行排名;让我们来按其名称按字母顺序排序的产品。</span><span class="sxs-lookup"><span data-stu-id="e3160-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="e3160-219">这意味着，如果使用自定义分页实现在本教程中我们将不是能够创建自定义分页的报表，不是还可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="e3160-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="e3160-220">在下一步的教程中，不过，我们将了解如何可以提供此类功能。</span><span class="sxs-lookup"><span data-stu-id="e3160-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="e3160-221">上一节中我们创建 DAL 方法作为临时 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="e3160-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="e3160-222">遗憾的是，使用 TableAdapter 向导不等的 Visual Studio 中的 T-SQL 的分析器`OVER`语法使用`ROW_NUMBER()`函数。</span><span class="sxs-lookup"><span data-stu-id="e3160-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="e3160-223">因此，我们必须为存储过程来创建此 DAL 方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="e3160-224">选择从视图菜单 （或命中的 Ctrl + Alt + S） 的服务器资源管理器，然后展开`NORTHWND.MDF`节点。</span><span class="sxs-lookup"><span data-stu-id="e3160-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="e3160-225">若要添加新的存储的过程，右键单击存储过程节点，并选择添加新的存储过程 （请参阅图 6）。</span><span class="sxs-lookup"><span data-stu-id="e3160-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![将新的存储的过程添加到产品分页](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="e3160-227">**图 6**： 将新的存储的过程添加到产品分页</span><span class="sxs-lookup"><span data-stu-id="e3160-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="e3160-228">此存储的过程应接受两个整数输入的参数-`@startRowIndex`和`@maximumRows`并用`ROW_NUMBER()`函数按排序`ProductName`字段，只返回这些行大于指定`@startRowIndex`和小于或等于`@startRowIndex`  +  `@maximumRow` s。</span><span class="sxs-lookup"><span data-stu-id="e3160-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="e3160-229">为新的存储过程中输入以下脚本，然后单击保存图标，将该存储的过程添加到数据库。</span><span class="sxs-lookup"><span data-stu-id="e3160-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="e3160-230">在创建后的存储的过程，花些时间对它进行测试。右键单击`GetProductsPaged`存储的过程中服务器资源管理器的名称并选择执行选项。</span><span class="sxs-lookup"><span data-stu-id="e3160-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="e3160-231">Visual Studio 随后将提示您为输入参数，`@startRowIndex`和`@maximumRow`s （请参阅图 7）。</span><span class="sxs-lookup"><span data-stu-id="e3160-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="e3160-232">请尝试不同的值，并检查结果。</span><span class="sxs-lookup"><span data-stu-id="e3160-232">Try different values and examine the results.</span></span>


![输入一个值@startRowIndex和@maximumRows参数](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="e3160-234">**图 7**： 输入一个值@startRowIndex和@maximumRows参数</span><span class="sxs-lookup"><span data-stu-id="e3160-234">**Figure 7**: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="e3160-235">后选择这些输入参数值，输出窗口中会显示结果。</span><span class="sxs-lookup"><span data-stu-id="e3160-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="e3160-236">图 8 显示结果时两个传入 10`@startRowIndex`和`@maximumRows`参数。</span><span class="sxs-lookup"><span data-stu-id="e3160-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="e3160-237">[![返回记录，将出现在第二个数据页](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="e3160-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="e3160-238">**图 8**: 记录，将出现在第二个数据页中返回 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="e3160-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>


<span data-ttu-id="e3160-239">与此存储过程创建，我们已准备好创建 re`ProductsTableAdapter`方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="e3160-240">打开`Northwind.xsd`类型化数据集，右键单击在`ProductsTableAdapter`，然后选择添加查询选项。</span><span class="sxs-lookup"><span data-stu-id="e3160-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="e3160-241">而不是创建使用临时 SQL 语句中的查询创建使用现有存储的过程。</span><span class="sxs-lookup"><span data-stu-id="e3160-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![创建使用现有存储的过程的 DAL 方法](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="e3160-243">**图 9**： 创建使用现有存储的过程的 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="e3160-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="e3160-244">接下来，我们将提示您选择要调用的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="e3160-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="e3160-245">选取`GetProductsPaged`从下拉列表的存储过程。</span><span class="sxs-lookup"><span data-stu-id="e3160-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![选择 GetProductsPaged 从下拉列表的存储过程](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="e3160-247">**图 10**： 选择 GetProductsPaged 从下拉列表的存储过程</span><span class="sxs-lookup"><span data-stu-id="e3160-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="e3160-248">下一个屏幕然后询问什么类型的数据返回的存储过程： 表格数据、 单个值或没有值。</span><span class="sxs-lookup"><span data-stu-id="e3160-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="e3160-249">由于`GetProductsPaged`存储的过程可以返回多个记录，指示它返回表格数据。</span><span class="sxs-lookup"><span data-stu-id="e3160-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![指示存储的过程返回表格数据](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="e3160-251">**图 11**： 指示存储的过程返回表格数据</span><span class="sxs-lookup"><span data-stu-id="e3160-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="e3160-252">最后，指示你想要创建的方法的名称。</span><span class="sxs-lookup"><span data-stu-id="e3160-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="e3160-253">与我们前面的教程，请继续并创建方法使用这两个填充 DataTable 返回 DataTable。</span><span class="sxs-lookup"><span data-stu-id="e3160-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="e3160-254">将第一个方法`FillPaged`和第二个`GetProductsPaged`。</span><span class="sxs-lookup"><span data-stu-id="e3160-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![名称方法 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="e3160-256">**图 12**： 名称方法 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="e3160-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="e3160-257">除了创建 DAL 方法返回产品的特定页，我们还需要提供 BLL 中的此类功能。</span><span class="sxs-lookup"><span data-stu-id="e3160-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="e3160-258">DAL 像方法一样，BLL 的 GetProductsPaged 方法必须接受用于指定开始的行索引和最大行数的两个整数输入，并且必须返回只在指定范围内的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="e3160-259">创建这样的 BLL 方法，只需调用下 DAL 的 GetProductsPaged 方法，如下所示 ProductsBLL 类中：</span><span class="sxs-lookup"><span data-stu-id="e3160-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="e3160-260">你可以使用任何名称为 BLL 方法 s 输入参数，但是，我们将会看到很快，选择使用`startRowIndex`和`maximumRows`保存我们从一个额外的配置对象数据源以使用此方法时的工作的位。</span><span class="sxs-lookup"><span data-stu-id="e3160-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="e3160-261">步骤 4： 配置对象数据源以使用自定义分页</span><span class="sxs-lookup"><span data-stu-id="e3160-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="e3160-262">使用用于访问完整的记录的特定子集的 BLL 和 DAL 方法，我们已准备好创建 GridView 重新控制通过使用自定义分页其基础记录该页面。</span><span class="sxs-lookup"><span data-stu-id="e3160-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="e3160-263">首先打开`EfficientPaging.aspx`页面`PagingAndSorting`文件夹中，将一个 GridView 添加到页上，并将其配置为使用新的 ObjectDataSource 控件。</span><span class="sxs-lookup"><span data-stu-id="e3160-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="e3160-264">在过去的教程中，我们通常必须配置为使用 ObjectDataSource`ProductsBLL`类的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="e3160-265">这一次，但是，我们想要使用`GetProductsPaged`方法相反，因为`GetProducts`方法返回*所有*的数据库中的产品而`GetProductsPaged`返回只记录的特定子集。</span><span class="sxs-lookup"><span data-stu-id="e3160-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![配置对象数据源以使用 ProductsBLL 类的 GetProductsPaged 方法](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="e3160-267">**图 13**： 配置对象数据源以使用 ProductsBLL 类的 GetProductsPaged 方法</span><span class="sxs-lookup"><span data-stu-id="e3160-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="e3160-268">自从我们重新创建一个只读的 GridView，花些时间在 INSERT、 UPDATE、 中设置的方法下拉列表并删除选项卡添加到 （无）。</span><span class="sxs-lookup"><span data-stu-id="e3160-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="e3160-269">接下来，该对象数据源向导会提示我们的源`GetProductsPaged`方法 s`startRowIndex`和`maximumRows`输入参数值。</span><span class="sxs-lookup"><span data-stu-id="e3160-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="e3160-270">这些输入的参数将实际的 GridView 自动设置，因此只需将源设置保留为无并单击完成。</span><span class="sxs-lookup"><span data-stu-id="e3160-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![将保留为 None 的输入的参数源](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="e3160-272">**图 14**： 保留为 None 的输入的参数源</span><span class="sxs-lookup"><span data-stu-id="e3160-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="e3160-273">完成对象数据源向导后，命令将 BoundField 或 CheckBoxField 为每个产品数据字段包含 GridView。</span><span class="sxs-lookup"><span data-stu-id="e3160-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="e3160-274">随意认为适合定制 GridView 的外观。</span><span class="sxs-lookup"><span data-stu-id="e3160-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="e3160-275">我已选择仅显示`ProductName`， `CategoryName`， `SupplierName`， `QuantityPerUnit`，和`UnitPrice`BoundFields。</span><span class="sxs-lookup"><span data-stu-id="e3160-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="e3160-276">此外，配置 GridView 支持分页，通过检查其智能标记中的分页启用复选框。</span><span class="sxs-lookup"><span data-stu-id="e3160-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="e3160-277">这些更改后的 GridView 和对象数据源的声明性标记应看起来类似以下：</span><span class="sxs-lookup"><span data-stu-id="e3160-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="e3160-278">如果访问通过浏览器页，但是，GridView 是没有任何地方要查找。</span><span class="sxs-lookup"><span data-stu-id="e3160-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView 是不显示](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="e3160-280">**图 15**: GridView 是不显示</span><span class="sxs-lookup"><span data-stu-id="e3160-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="e3160-281">缺少 GridView，因为对象数据源当前使用 0 的值为这两个`GetProductsPaged``startRowIndex`和`maximumRows`输入参数。</span><span class="sxs-lookup"><span data-stu-id="e3160-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="e3160-282">因此，生成的 SQL 查询返回的任何记录，因此 GridView 不会显示。</span><span class="sxs-lookup"><span data-stu-id="e3160-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="e3160-283">若要解决此问题，我们需要配置对象数据源以使用自定义分页。</span><span class="sxs-lookup"><span data-stu-id="e3160-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="e3160-284">这可以通过以下步骤完成：</span><span class="sxs-lookup"><span data-stu-id="e3160-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="e3160-285">**设置 ObjectDataSource s`EnablePaging`属性`true`**这将指示必须将传递给 ObjectDataSource`SelectMethod`两个其他参数： 一个用于指定开始的行索引 ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))，，另一个用于指定最大行数 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="e3160-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="e3160-286">**设置 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`属性相应地**`StartRowIndexParameterName`和`MaximumRowsParameterName`属性指示传入的输入参数的名称`SelectMethod`用于自定义分页用途.</span><span class="sxs-lookup"><span data-stu-id="e3160-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="e3160-287">默认情况下，这些参数名称是`startIndexRow`和`maximumRows`，这是正因如此，在创建时`GetProductsPaged`方法在 BLL，我使用了这些值为输入参数。</span><span class="sxs-lookup"><span data-stu-id="e3160-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="e3160-288">如果选择了使用不同的参数名称 BLL s`GetProductsPaged`如方法`startIndex`和`maxRows`，对于你需要的示例设置 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`属性相应地 （例如为 startIndex`StartRowIndexParameterName`和最大行数为`MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="e3160-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="e3160-289">**设置 ObjectDataSource s [ `SelectCountMethod`属性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)总数量的记录正在分页通过返回的方法的名称 (`TotalNumberOfProducts`)**回想一下，`ProductsBLL`类的`TotalNumberOfProducts`方法返回的记录正在通过寻呼发送通过使用执行 DAL 方法总数`SELECT COUNT(*) FROM Products`查询。</span><span class="sxs-lookup"><span data-stu-id="e3160-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="e3160-290">为正确呈现的分页界面情况下，此信息所需的对象数据源。</span><span class="sxs-lookup"><span data-stu-id="e3160-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="e3160-291">**删除`startRowIndex`和`maximumRows``<asp:Parameter>`从 ObjectDataSource s 声明性标记元素**配置时通过向导 ObjectDataSource，Visual Studio 自动添加两个`<asp:Parameter>`元素`GetProductsPaged`方法 s 输入参数。</span><span class="sxs-lookup"><span data-stu-id="e3160-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="e3160-292">通过设置`EnablePaging`到`true`，将自动传递这些参数; 如果他们还出现在声明性语法，ObjectDataSource 将尝试传递*四个*参数`GetProductsPaged`方法和两个参数`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="e3160-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="e3160-293">如果你忘记了以删除这些`<asp:Parameter>`元素，在访问通过浏览器，您将收到错误消息的页时： *ObjectDataSource ObjectDataSource1 找不到非泛型方法 TotalNumberOfProducts 具有参数： 值，值*。</span><span class="sxs-lookup"><span data-stu-id="e3160-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="e3160-294">进行这些更改后，ObjectDataSource s 声明性语法应如下所示：</span><span class="sxs-lookup"><span data-stu-id="e3160-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="e3160-295">请注意，`EnablePaging`和`SelectCountMethod`已经设置了属性和`<asp:Parameter>`已删除元素。</span><span class="sxs-lookup"><span data-stu-id="e3160-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="e3160-296">进行这些更改之后，图 16 将显示属性窗口的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="e3160-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![若要使用自定义分页，配置 ObjectDataSource 控件](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="e3160-298">**图 16**： 若要使用自定义分页，配置 ObjectDataSource 控件</span><span class="sxs-lookup"><span data-stu-id="e3160-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="e3160-299">进行这些更改后，请访问此页通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="e3160-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="e3160-300">你应看到列出，10 种产品按字母顺序排列。</span><span class="sxs-lookup"><span data-stu-id="e3160-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="e3160-301">花一些时间来单步执行一页数据一次。</span><span class="sxs-lookup"><span data-stu-id="e3160-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="e3160-302">因为它仅检索需要显示为给定页的记录，而不没有默认分页和自定义分页之间任何 visual 区别从最终用户 s 角度来看，自定义分页更有效地页面通过大量的数据。</span><span class="sxs-lookup"><span data-stu-id="e3160-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="e3160-303">[![数据、 Ordered 按产品名称，是分页使用自定义分页](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="e3160-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="e3160-304">**图 17**: Data、 Ordered 按产品名称，是分页使用自定义分页 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="e3160-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="e3160-305">使用自定义分页页计数值返回 ObjectDataSource 的`SelectCountMethod`GridView 的视图状态中存储。</span><span class="sxs-lookup"><span data-stu-id="e3160-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="e3160-306">其他 GridView 变量`PageIndex`， `EditIndex`， `SelectedIndex`，`DataKeys`集合中，依次类推存储在*控制状态*，这保留无论 GridView s 的值如何`EnableViewState`属性。</span><span class="sxs-lookup"><span data-stu-id="e3160-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="e3160-307">由于`PageCount`值保存在回发期间使用的视图状态，当使用分页接口，其中包含链接，使你转到的最后一页时，它是命令性 GridView 的视图状态为已启用。</span><span class="sxs-lookup"><span data-stu-id="e3160-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="e3160-308">（如果你分页的接口不包括的直接链接到最后一页上，然后你可以禁用视图状态。）</span><span class="sxs-lookup"><span data-stu-id="e3160-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="e3160-309">单击最后一页链接导致回发，并指示 GridView 以更新其`PageIndex`属性。</span><span class="sxs-lookup"><span data-stu-id="e3160-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="e3160-310">如果单击最后一页链接时，赋给变量 GridView 其`PageIndex`属性之一的值小于其`PageCount`属性。</span><span class="sxs-lookup"><span data-stu-id="e3160-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="e3160-311">与视图状态已禁用，`PageCount`值丢失在回发期间和`PageIndex`改为分配的最大整数值。</span><span class="sxs-lookup"><span data-stu-id="e3160-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="e3160-312">接下来，尝试确定的起始行索引乘以 GridView`PageSize`和`PageCount`属性。</span><span class="sxs-lookup"><span data-stu-id="e3160-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="e3160-313">这会导致`OverflowException`由于产品超出了允许的最大整数大小。</span><span class="sxs-lookup"><span data-stu-id="e3160-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="e3160-314">实现自定义分页和排序</span><span class="sxs-lookup"><span data-stu-id="e3160-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="e3160-315">我们当前的自定义分页实现需要在创建时，静态指定通过调数据时所依据的顺序`GetProductsPaged`存储过程。</span><span class="sxs-lookup"><span data-stu-id="e3160-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="e3160-316">但是，你可能记录 GridView s 智能标记包含除了启用分页选项启用排序复选框。</span><span class="sxs-lookup"><span data-stu-id="e3160-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="e3160-317">遗憾的是，将排序支持添加到使用了当前的自定义分页实现 GridView 仅将排序数据的当前查看页上的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="e3160-318">例如，如果你配置 GridView 还支持分页，并按产品名称的降序顺序查看数据，第一页时的排序然后，它将于第 1 页反向产品的顺序。</span><span class="sxs-lookup"><span data-stu-id="e3160-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="e3160-319">如图 18 所示，如墨鱼时显示为第一个产品按反向字母顺序，将忽略的 71 其他产品按字母顺序; 晚墨鱼，排序只有第一页上的那些记录中计入的排序。</span><span class="sxs-lookup"><span data-stu-id="e3160-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="e3160-320">[![仅数据显示在当前页面上进行排序](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="e3160-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="e3160-321">**图 18**： 仅显示数据在当前页面上进行排序 ([单击以查看实际尺寸的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="e3160-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>


<span data-ttu-id="e3160-322">排序仅适用于数据的当前页因为后已从 BLL s 检索的数据排序发生`GetProductsPaged`，因此该方法仅返回的特定页中的记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="e3160-323">若要实现正确进行排序，我们需要传递到排序表达式`GetProductsPaged`方法，以便可以在返回的数据的特定页之前适当排名数据。</span><span class="sxs-lookup"><span data-stu-id="e3160-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="e3160-324">我们将了解如何实现此目的在我们的下一步教程。</span><span class="sxs-lookup"><span data-stu-id="e3160-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="e3160-325">实现自定义分页和删除</span><span class="sxs-lookup"><span data-stu-id="e3160-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="e3160-326">如果你启用删除功能中使用自定义分页技术，您会发现从的最后一页中删除最后一条记录时分页其数据 GridView，GridView 消失而不是适当递减 GridView 的`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="e3160-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="e3160-327">若要重现此 bug，启用删除可能导致，本教程只是我们刚刚创建。</span><span class="sxs-lookup"><span data-stu-id="e3160-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="e3160-328">转到的最后一页 （页 9），其中你应看到一个产品，因为我们分页 81 产品，一次 10 种产品。</span><span class="sxs-lookup"><span data-stu-id="e3160-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="e3160-329">删除此产品。</span><span class="sxs-lookup"><span data-stu-id="e3160-329">Delete this product.</span></span>

<span data-ttu-id="e3160-330">一旦删除最后一个产品，GridView*应*自动转到第八个页上，并使用默认分页展现这样的功能。</span><span class="sxs-lookup"><span data-stu-id="e3160-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="e3160-331">使用自定义分页，但是，删除最后一页中，于最后一个产品后 GridView 只需从屏幕上消失完全。</span><span class="sxs-lookup"><span data-stu-id="e3160-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="e3160-332">确切原因*为什么*发生这种情况均超出了本教程的范围的一个位; 请参阅[从使用自定义分页 GridView 删除最后一页上的最后一个记录](http://scottonwriting.net/sowblog/posts/7326.aspx)并与来源的数据的低级别的详细信息此问题。</span><span class="sxs-lookup"><span data-stu-id="e3160-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="e3160-333">在摘要它由于下面的 GridView 时单击删除按钮执行的步骤序列的 s:</span><span class="sxs-lookup"><span data-stu-id="e3160-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="e3160-334">删除的记录</span><span class="sxs-lookup"><span data-stu-id="e3160-334">Delete the record</span></span>
2. <span data-ttu-id="e3160-335">获取相应的记录，若要显示有关指定`PageIndex`和`PageSize`</span><span class="sxs-lookup"><span data-stu-id="e3160-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="e3160-336">检查以确保`PageIndex`不超过数据源; 中的数据的页面数，如果它存在，自动递减 GridView 的`PageIndex`属性</span><span class="sxs-lookup"><span data-stu-id="e3160-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="e3160-337">将合适的页面的数据绑定到 GridView 使用在步骤 2 中获取的记录</span><span class="sxs-lookup"><span data-stu-id="e3160-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="e3160-338">此问题，是因为该在步骤 2`PageIndex`时仍抓取要显示的记录是使用`PageIndex`只需删除其唯一记录的最后一页。</span><span class="sxs-lookup"><span data-stu-id="e3160-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="e3160-339">因此，在步骤 2 中，*没有*返回记录的因为数据的最后一页不再包含任何记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="e3160-340">然后，在步骤 3 中，GridView 认识到其`PageIndex`属性大于数据源中的页的总数 （自我们已删除的最后一页中的最后一个记录），因此递减其`PageIndex`属性。</span><span class="sxs-lookup"><span data-stu-id="e3160-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="e3160-341">在步骤 4 中 GridView 尝试将本身绑定到在步骤 2; 中检索数据但是，在步骤 2 中未返回任何记录，因此导致空 GridView。</span><span class="sxs-lookup"><span data-stu-id="e3160-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="e3160-342">使用默认分页，此问题没有 t 外围因为在步骤 2 中*所有*从数据源中检索记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="e3160-343">若要解决此问题，我们具有两个选项。</span><span class="sxs-lookup"><span data-stu-id="e3160-343">To fix this we have two options.</span></span> <span data-ttu-id="e3160-344">第一种是创建的事件处理程序 GridView 的`RowDeleted`确定只需删除页中显示多少条记录的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e3160-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="e3160-345">如果存在只有一条记录，则只需删除的记录必须已被最后一个，并且我们需要递减 GridView 的`PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="e3160-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="e3160-346">当然，我们只想更新`PageIndex`如果删除操作实际上已成功时，这就可以确定通过确保`e.Exception`属性是`null`。</span><span class="sxs-lookup"><span data-stu-id="e3160-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="e3160-347">此方法很有效，因为它会更新`PageIndex`步骤 1 之后但在步骤 2 之前。</span><span class="sxs-lookup"><span data-stu-id="e3160-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="e3160-348">因此，在步骤 2 中，相应的记录集将返回。</span><span class="sxs-lookup"><span data-stu-id="e3160-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="e3160-349">若要实现此目的，使用代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="e3160-349">To accomplish this, use code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="e3160-350">备用解决方法是创建的事件处理程序 ObjectDataSource s`RowDeleted`事件并设置`AffectedRows`属性的值为 1。</span><span class="sxs-lookup"><span data-stu-id="e3160-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="e3160-351">删除在步骤 1 中 （但之前重新检索步骤 2 中的数据） 的记录后, GridView 更新其`PageIndex`属性，如果一个或多个行受该操作。</span><span class="sxs-lookup"><span data-stu-id="e3160-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="e3160-352">但是， `AffectedRows` ObjectDataSource 未设置属性，并且因此忽略了此步骤。</span><span class="sxs-lookup"><span data-stu-id="e3160-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="e3160-353">一种方法具有执行此步骤是手动设置`AffectedRows`属性，如果删除操作成功完成。</span><span class="sxs-lookup"><span data-stu-id="e3160-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="e3160-354">这可以实现使用代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="e3160-354">This can be accomplished using code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="e3160-355">这两个这些事件处理程序的代码可在代码隐藏类的`EfficientPaging.aspx`示例。</span><span class="sxs-lookup"><span data-stu-id="e3160-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="e3160-356">比较默认和自定义分页的性能</span><span class="sxs-lookup"><span data-stu-id="e3160-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="e3160-357">由于自定义分页仅检索所需的记录，而默认分页返回*所有*的查看，每一页的记录它 s 清除自定义分页是比默认分页更高效。</span><span class="sxs-lookup"><span data-stu-id="e3160-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="e3160-358">但是仅多少更高效是自定义分页？</span><span class="sxs-lookup"><span data-stu-id="e3160-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="e3160-359">可以看到什么样的性能提升，将从默认分页移动到自定义分页？</span><span class="sxs-lookup"><span data-stu-id="e3160-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="e3160-360">遗憾的是，在该处 s 没有一个适合大小所有此处回答。</span><span class="sxs-lookup"><span data-stu-id="e3160-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="e3160-361">性能提升取决于许多因素影响，最卓越两个正在数量的记录正在通过寻呼发送通过负载置于 web 服务器和数据库服务器之间的数据库服务器和通信通道。</span><span class="sxs-lookup"><span data-stu-id="e3160-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="e3160-362">对于只需少量几十个记录的小型表，性能差异可能可以忽略不计。</span><span class="sxs-lookup"><span data-stu-id="e3160-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="e3160-363">不过，对于具有数千到成千上万的行的大型表的性能差异是很严重的。</span><span class="sxs-lookup"><span data-stu-id="e3160-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="e3160-364">项目的挖掘， [ASP.NET 2.0 与 SQL Server 2005 中的自定义分页](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)，包含所运行的用于展示之间这两项分页技术分页通过与数据库表时的性能差异某些性能测试50,000 个记录。</span><span class="sxs-lookup"><span data-stu-id="e3160-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="e3160-365">这些测试在我检查这两个执行 SQL Server 级别的查询的时间 (使用[SQL 事件探查器](https://msdn.microsoft.com/library/ms173757.aspx)) 和 ASP.NET 页使用[ASP.NET 的跟踪功能](https://msdn.microsoft.com/library/y13fw6we.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e3160-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="e3160-366">请记住，这些测试已在具有单个活动用户，我开发框上运行，并因此是科学并不模拟典型的网站的负载模式。</span><span class="sxs-lookup"><span data-stu-id="e3160-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="e3160-367">无论如何，结果说明中的默认实例和自定义分页的执行时间的相对差异时使用的数据量非常大。</span><span class="sxs-lookup"><span data-stu-id="e3160-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="e3160-368">**Avg.持续时间 （秒）**</span><span class="sxs-lookup"><span data-stu-id="e3160-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="e3160-369">**读取**</span><span class="sxs-lookup"><span data-stu-id="e3160-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="e3160-370">**默认分页 SQL 事件探查器**</span><span class="sxs-lookup"><span data-stu-id="e3160-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="e3160-371">1.411</span><span class="sxs-lookup"><span data-stu-id="e3160-371">1.411</span></span> | <span data-ttu-id="e3160-372">383</span><span class="sxs-lookup"><span data-stu-id="e3160-372">383</span></span> |
| <span data-ttu-id="e3160-373">**自定义分页 SQL 事件探查器**</span><span class="sxs-lookup"><span data-stu-id="e3160-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="e3160-374">0.002</span><span class="sxs-lookup"><span data-stu-id="e3160-374">0.002</span></span> | <span data-ttu-id="e3160-375">29</span><span class="sxs-lookup"><span data-stu-id="e3160-375">29</span></span> |
| <span data-ttu-id="e3160-376">**默认分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="e3160-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="e3160-377">2.379</span><span class="sxs-lookup"><span data-stu-id="e3160-377">2.379</span></span> | <span data-ttu-id="e3160-378">*不适用*</span><span class="sxs-lookup"><span data-stu-id="e3160-378">*N/A*</span></span> |
| <span data-ttu-id="e3160-379">**自定义分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="e3160-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="e3160-380">0.029</span><span class="sxs-lookup"><span data-stu-id="e3160-380">0.029</span></span> | <span data-ttu-id="e3160-381">*不适用*</span><span class="sxs-lookup"><span data-stu-id="e3160-381">*N/A*</span></span> |


<span data-ttu-id="e3160-382">如你所见，检索数据的特定页平均需要小于读取 354 和很短的时间内完成。</span><span class="sxs-lookup"><span data-stu-id="e3160-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="e3160-383">在 ASP.NET 页上，自定义的页面是能够在呈现接近于 1/100<sup>th</sup>它所花时间的使用默认分页时。</span><span class="sxs-lookup"><span data-stu-id="e3160-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="e3160-384">请参阅[我文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)对于这些结果以及代码和数据库的详细信息，可以下载重现这些测试在你自己的环境中。</span><span class="sxs-lookup"><span data-stu-id="e3160-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="e3160-385">摘要</span><span class="sxs-lookup"><span data-stu-id="e3160-385">Summary</span></span>

<span data-ttu-id="e3160-386">默认分页很容易做到以实现数据 Web 控件 s 智能标记只检查启用分页的复选框，但这种简单的代价是性能。</span><span class="sxs-lookup"><span data-stu-id="e3160-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="e3160-387">使用默认分页，当用户请求数据的任何页*所有*返回记录，即使仅有极小一部分其中可能会显示。</span><span class="sxs-lookup"><span data-stu-id="e3160-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="e3160-388">为了应对这项性能开销，ObjectDataSource 提供替代的分页选项自定义分页。</span><span class="sxs-lookup"><span data-stu-id="e3160-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="e3160-389">自定义分页改进了默认通过检索需要要显示的那些记录分页 s 性能问题时它更为复杂，若要实现自定义分页的 s。</span><span class="sxs-lookup"><span data-stu-id="e3160-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="e3160-390">首先，必须编写查询，用于正确 （和有效地） 访问请求的记录的特定子集。</span><span class="sxs-lookup"><span data-stu-id="e3160-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="e3160-391">这可以实现多种方式;在本教程中，我们探讨的一个是使用 SQL Server 2005 s 新`ROW_NUMBER()`为级别函数结果，然后返回不仅仅是导致其排名是否在指定的范围内。</span><span class="sxs-lookup"><span data-stu-id="e3160-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="e3160-392">此外，我们需要添加一种方式来确定总正在通过寻呼发送到的记录数。</span><span class="sxs-lookup"><span data-stu-id="e3160-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="e3160-393">在创建后这些 DAL 和 BLL 方法，我们还需要配置对象数据源，以便它可以确定总记录数通过正在通过寻呼发送，并可以正确传递给 BLL 启动行索引和最大行数的值。</span><span class="sxs-lookup"><span data-stu-id="e3160-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="e3160-394">实现自定义分页需要大量的步骤并不几乎与默认分页一样简单，而自定义分页时，需要这么足够大，大量数据进行分页。</span><span class="sxs-lookup"><span data-stu-id="e3160-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="e3160-395">结果检查作为显示、 自定义分页可以舍弃从 ASP.NET 页呈现时间 （秒），并可通过一个或多个数量级的淡化数据库服务器上的负载。</span><span class="sxs-lookup"><span data-stu-id="e3160-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="e3160-396">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="e3160-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="e3160-397">关于作者</span><span class="sxs-lookup"><span data-stu-id="e3160-397">About the Author</span></span>

<span data-ttu-id="e3160-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="e3160-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e3160-399">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="e3160-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e3160-400">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="e3160-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="e3160-401">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="e3160-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="e3160-402">[上一页](paging-and-sorting-report-data-cs.md)
[下一页](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="e3160-402">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
