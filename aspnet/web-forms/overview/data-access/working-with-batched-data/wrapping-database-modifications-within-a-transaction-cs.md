---
uid: web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
title: 包装在一个事务 (C#) 内的数据库修改 |Microsoft 文档
author: rick-anderson
description: 本教程是 4 的倍数考察更新、 删除和插入的数据批的第一个。 在本教程中我们了解如何允许数据库事务...
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/26/2007
ms.topic: article
ms.assetid: b45fede3-c53a-4ea1-824b-20200808dbae
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
msc.type: authoredcontent
ms.openlocfilehash: a3f8ec2de7b9259e4bb83f4346bde8abfd643fb4
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2018
ms.locfileid: "30888950"
---
<a name="wrapping-database-modifications-within-a-transaction-c"></a><span data-ttu-id="7d016-104">在一个事务 (C#) 内的包装数据库修改</span><span class="sxs-lookup"><span data-stu-id="7d016-104">Wrapping Database Modifications within a Transaction (C#)</span></span>
====================
<span data-ttu-id="7d016-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="7d016-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="7d016-106">[下载代码](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_CS.zip)或[下载 PDF](wrapping-database-modifications-within-a-transaction-cs/_static/datatutorial63cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="7d016-106">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_CS.zip) or [Download PDF](wrapping-database-modifications-within-a-transaction-cs/_static/datatutorial63cs1.pdf)</span></span>

> <span data-ttu-id="7d016-107">本教程是 4 的倍数考察更新、 删除和插入的数据批的第一个。</span><span class="sxs-lookup"><span data-stu-id="7d016-107">This tutorial is the first of four that looks at updating, deleting, and inserting batches of data.</span></span> <span data-ttu-id="7d016-108">在本教程中我们了解如何数据库事务允许批处理的修改就可以执行以原子操作，这将确保所有步骤都成功或所有步骤都失败。</span><span class="sxs-lookup"><span data-stu-id="7d016-108">In this tutorial we learn how database transactions allow batch modifications to be carried out as an atomic operation, which ensures that either all steps succeed or all steps fail.</span></span>


## <a name="introduction"></a><span data-ttu-id="7d016-109">介绍</span><span class="sxs-lookup"><span data-stu-id="7d016-109">Introduction</span></span>

<span data-ttu-id="7d016-110">正如我们所看到开头[概述的插入、 更新和删除数据](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md)教程中，GridView 提供内置支持行级编辑和删除。</span><span class="sxs-lookup"><span data-stu-id="7d016-110">As we saw starting with the [An Overview of Inserting, Updating, and Deleting Data](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) tutorial, the GridView provides built-in support for row-level editing and deleting.</span></span> <span data-ttu-id="7d016-111">只需单击几下鼠标就可以处理程序，但前提是要进行编辑和删除行数基于内容，而无需编写一行代码，创建丰富的数据修改接口。</span><span class="sxs-lookup"><span data-stu-id="7d016-111">With a few clicks of the mouse it is possible to create a rich data modification interface without writing a line of code, so long as you are content with editing and deleting on a per-row basis.</span></span> <span data-ttu-id="7d016-112">但是，在某些情况下，这是不足，我们需要先向用户提供编辑或删除的记录批的能力。</span><span class="sxs-lookup"><span data-stu-id="7d016-112">However, in certain scenarios this is insufficient and we need to provide users with the ability to edit or delete a batch of records.</span></span>

<span data-ttu-id="7d016-113">例如，最基于 web 的电子邮件客户端使用网格列出每条消息，每个行中包含的电子邮件的 s 信息 （主题、 发件人，等） 以及一个复选框。</span><span class="sxs-lookup"><span data-stu-id="7d016-113">For example, most web-based email clients use a grid to list each message where each row includes a checkbox along with the email s information (subject, sender, and so forth).</span></span> <span data-ttu-id="7d016-114">此接口允许用户通过检查它们，然后单击删除所选消息按钮删除多个消息。</span><span class="sxs-lookup"><span data-stu-id="7d016-114">This interface permits the user to delete multiple messages by checking them and then clicking a Delete Selected Messages button.</span></span> <span data-ttu-id="7d016-115">编辑接口批处理非常适合在用户通常编辑许多不同记录的情况下。</span><span class="sxs-lookup"><span data-stu-id="7d016-115">A batch editing interface is ideal in situations where users commonly edit many different records.</span></span> <span data-ttu-id="7d016-116">而不强制用户通过单击编辑、 其更改，然后单击更新为需要修改每个记录，编辑接口一批呈现具有其编辑界面每个行。</span><span class="sxs-lookup"><span data-stu-id="7d016-116">Rather than forcing the user to click Edit, make their change, and then click Update for each record that needs to be modified, a batch editing interface renders each row with its editing interface.</span></span> <span data-ttu-id="7d016-117">用户可以快速修改组的需要更改的行，单击全部更新按钮，然后将保存这些更改。</span><span class="sxs-lookup"><span data-stu-id="7d016-117">The user can quickly modify the set of rows that need to be changed and then save these changes by clicking an Update All button.</span></span> <span data-ttu-id="7d016-118">在此系列教程中，我们将查看如何创建用于插入、 编辑和删除数据批的接口。</span><span class="sxs-lookup"><span data-stu-id="7d016-118">In this set of tutorials we'll examine how to create interfaces for inserting, editing, and deleting batches of data.</span></span>

<span data-ttu-id="7d016-119">执行批处理操作时它非常重要，以确定是否应当可以为某些中批处理成功的操作而其他失败。</span><span class="sxs-lookup"><span data-stu-id="7d016-119">When performing batch operations it s important to determine whether it should be possible for some of the operations in the batch to succeed while others fail.</span></span> <span data-ttu-id="7d016-120">请考虑一批删除接口-如果成功，删除所选的第一个记录，但第二个失败，例如，由于外键约束冲突，应该发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="7d016-120">Consider a batch deleting interface - what should happen if the first selected record is deleted successfully, but the second one fails, say, because of a foreign key constraint violation?</span></span> <span data-ttu-id="7d016-121">应该第一个记录的删除回滚或是否保持已删除的第一个记录可以接受？</span><span class="sxs-lookup"><span data-stu-id="7d016-121">Should the first record s delete be rolled back or is it acceptable for the first record to remain deleted?</span></span>

<span data-ttu-id="7d016-122">如果你想要被视为的批处理操作[原子操作](http://en.wikipedia.org/wiki/Atomic_operation)，一个是其中的所有步骤成功或失败的所有步骤，则数据访问层需要进行扩充以包括对支持[数据库事务](http://en.wikipedia.org/wiki/Database_transaction)。</span><span class="sxs-lookup"><span data-stu-id="7d016-122">If you want the batch operation to be treated as an [atomic operation](http://en.wikipedia.org/wiki/Atomic_operation), one where either all of the steps succeed or all of the steps fail, then the Data Access Layer needs to be augmented to include support for [database transactions](http://en.wikipedia.org/wiki/Database_transaction).</span></span> <span data-ttu-id="7d016-123">数据库事务保证的一套的原子性`INSERT`， `UPDATE`，和`DELETE`语句在事务的保护伞下执行，并且是所有的大多数现代数据库系统支持的功能。</span><span class="sxs-lookup"><span data-stu-id="7d016-123">Database transactions guarantee atomicity for the set of `INSERT`, `UPDATE`, and `DELETE` statements executed under the umbrella of the transaction and are a feature supported by most all modern database systems.</span></span>

<span data-ttu-id="7d016-124">在本教程中我们将查看如何扩展 DAL 使用数据库事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-124">In this tutorial we'll look at how to extend the DAL to use database transactions.</span></span> <span data-ttu-id="7d016-125">后续教程将检查批处理插入、 更新和删除接口的实现 web 页。</span><span class="sxs-lookup"><span data-stu-id="7d016-125">Subsequent tutorials will examine implementing web pages for batch inserting, updating, and deleting interfaces.</span></span> <span data-ttu-id="7d016-126">让我们来开始 ！</span><span class="sxs-lookup"><span data-stu-id="7d016-126">Let s get started!</span></span>

> [!NOTE]
> <span data-ttu-id="7d016-127">在修改批事务中的数据时，不始终需要原子性。</span><span class="sxs-lookup"><span data-stu-id="7d016-127">When modifying data in a batch transaction, atomicity is not always needed.</span></span> <span data-ttu-id="7d016-128">在某些情况下，它可能是可以接受的成功一些数据修改和其他人在同一个批处理中失败，例如，当从基于 web 的电子邮件客户端中删除一组的电子邮件。</span><span class="sxs-lookup"><span data-stu-id="7d016-128">In some scenarios, it may be acceptable to have some data modifications succeed and others in the same batch fail, such as when deleting a set of emails from a web-based email client.</span></span> <span data-ttu-id="7d016-129">如果存在 s 数据库错误会中途删除处理，它可能可接受的正常处理这些记录保留已删除的 s。</span><span class="sxs-lookup"><span data-stu-id="7d016-129">If there s a database error midway through the deletion process, it s probably acceptable that those records processed without error remain deleted.</span></span> <span data-ttu-id="7d016-130">在这种情况下，不需要修改以支持数据库事务 DAL。</span><span class="sxs-lookup"><span data-stu-id="7d016-130">In such cases, the DAL does not need to be modified to support database transactions.</span></span> <span data-ttu-id="7d016-131">有其他批处理操作方案中，但是，原子性至关重要。</span><span class="sxs-lookup"><span data-stu-id="7d016-131">There are other batch operation scenarios, however, where atomicity is vital.</span></span> <span data-ttu-id="7d016-132">当客户将她资金从一个银行帐户移到另一个中时，必须执行两个操作： 必须从第一个帐户中扣除并随后将添加到第二个中涉及的金额。</span><span class="sxs-lookup"><span data-stu-id="7d016-132">When a customer moves her funds from one bank account to another, two operations must be performed: the funds must be deducted from the first account and then added to the second.</span></span> <span data-ttu-id="7d016-133">银行可能不介意成功的第一步，但第二个步骤失败，其客户可能不难理解会满意。</span><span class="sxs-lookup"><span data-stu-id="7d016-133">While the bank may not mind having the first step succeed but the second step fail, its customers would understandably be upset.</span></span> <span data-ttu-id="7d016-134">我建议你完成本教程中，并实现与 DAL 以支持数据库事务，即使你不计划上使用它们在批处理插入、 更新和删除我们将在以下三个教程中生成的接口的增强功能。</span><span class="sxs-lookup"><span data-stu-id="7d016-134">I encourage you to work through this tutorial and implement the enhancements to the DAL to support database transactions even if you do not plan on using them in the batch inserting, updating, and deleting interfaces we'll be building in the following three tutorials.</span></span>


## <a name="an-overview-of-transactions"></a><span data-ttu-id="7d016-135">事务的概述</span><span class="sxs-lookup"><span data-stu-id="7d016-135">An Overview of Transactions</span></span>

<span data-ttu-id="7d016-136">大多数数据库包括对支持*事务*，它实现了多个数据库命令，分组到单个逻辑单元的工作。</span><span class="sxs-lookup"><span data-stu-id="7d016-136">Most databases include support for *transactions*, which enable multiple database commands to be grouped into a single logical unit of work.</span></span> <span data-ttu-id="7d016-137">保证构成事务的数据库命令都是原子性的这意味着所有命令将都失败，或所有将会成功。</span><span class="sxs-lookup"><span data-stu-id="7d016-137">The database commands that comprise a transaction are guaranteed to be atomic, meaning that either all commands will fail or all will succeed.</span></span>

<span data-ttu-id="7d016-138">一般情况下，通过使用以下模式的 SQL 语句实现事务：</span><span class="sxs-lookup"><span data-stu-id="7d016-138">In general, transactions are implemented through SQL statements using the following pattern:</span></span>

1. <span data-ttu-id="7d016-139">指示启动事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-139">Indicate the start of a transaction.</span></span>
2. <span data-ttu-id="7d016-140">执行构成事务的 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="7d016-140">Execute the SQL statements that comprise the transaction.</span></span>
3. <span data-ttu-id="7d016-141">如果没有在步骤 2，回滚事务中的语句之一时出错。</span><span class="sxs-lookup"><span data-stu-id="7d016-141">If there is an error in one of the statements from Step 2, rollback the transaction.</span></span>
4. <span data-ttu-id="7d016-142">如果所有步骤 2 中的语句完成而未出现错误，则提交事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-142">If all of the statements from Step 2 complete without error, commit the transaction.</span></span>

<span data-ttu-id="7d016-143">SQL 语句用于创建、 提交和回滚事务时，可以输入手动编写 SQL 脚本或创建存储过程，或通过编程意味着要使用 ADO.NET 或中的类[ `System.Transactions`命名空间](https://msdn.microsoft.com/library/system.transactions.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7d016-143">The SQL statements used to create, commit, and roll back the transaction can be entered manually when writing SQL scripts or creating stored procedures, or through programmatic means using either ADO.NET or the classes in the [`System.Transactions` namespace](https://msdn.microsoft.com/library/system.transactions.aspx).</span></span> <span data-ttu-id="7d016-144">在本教程中我们将仅检查管理使用 ADO.NET 的事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-144">In this tutorial we will only examine managing transactions using ADO.NET.</span></span> <span data-ttu-id="7d016-145">在将来的教程我们将了解如何在数据访问层，在这段时间中，我们将探讨用于创建、 回滚，和提交事务的 SQL 语句中使用存储的过程。</span><span class="sxs-lookup"><span data-stu-id="7d016-145">In a future tutorial we will look at how to use stored procedures in the Data Access Layer, at which time we'll explore the SQL statements for creating, rolling back, and committing transactions.</span></span> <span data-ttu-id="7d016-146">在此期间，请查阅[在 SQL Server 存储过程中管理事务](http://www.4guysfromrolla.com/webtech/080305-1.shtml)有关详细信息。</span><span class="sxs-lookup"><span data-stu-id="7d016-146">In the meantime, consult [Managing Transactions in SQL Server Stored Procedures](http://www.4guysfromrolla.com/webtech/080305-1.shtml) for more information.</span></span>

> [!NOTE]
> <span data-ttu-id="7d016-147">[ `TransactionScope`类](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx)中`System.Transactions`命名空间使开发人员能够以编程方式在事务范围内换行一系列语句并包含对，则涉及多个复杂事务支持两个不同的数据库或甚至异类类型的数据存储，如 Microsoft SQL Server 数据库、 Oracle 数据库和 Web 服务等源。</span><span class="sxs-lookup"><span data-stu-id="7d016-147">The [`TransactionScope` class](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx) in the `System.Transactions` namespace enables developers to programmatically wrap a series of statements within the scope of a transaction and includes support for complex transactions that involve multiple sources, such as two different databases or even heterogeneous types of data stores, such as a Microsoft SQL Server database, an Oracle database, and a Web service.</span></span> <span data-ttu-id="7d016-148">我已确定而不是本教程使用 ADO.NET 事务`TransactionScope`类，因为 ADO.NET 是更具体的数据库事务，并在许多情况下，是小得多占用大量的资源。</span><span class="sxs-lookup"><span data-stu-id="7d016-148">I ve decided to use ADO.NET transactions for this tutorial instead of the `TransactionScope` class because ADO.NET is more specific for database transactions and, in many cases, is far less resource intensive.</span></span> <span data-ttu-id="7d016-149">此外，在某些情况下`TransactionScope`类使用 Microsoft 分布式事务处理协调器 (MSDTC)。</span><span class="sxs-lookup"><span data-stu-id="7d016-149">In addition, under certain scenarios the `TransactionScope` class uses the Microsoft Distributed Transaction Coordinator (MSDTC).</span></span> <span data-ttu-id="7d016-150">配置、 实施和性能问题周围 MSDTC 使它而是专用的高级主题和超出范围的这些教程。</span><span class="sxs-lookup"><span data-stu-id="7d016-150">The configuration, implementation, and performance issues surrounding MSDTC makes it a rather specialized and advanced topic and beyond the scope of these tutorials.</span></span>


<span data-ttu-id="7d016-151">在使用 SqlClient 提供程序在 ADO.NET 中，通过调用启动事务[`SqlConnection`类](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx)s [ `BeginTransaction`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx)，它将返回[ `SqlTransaction`对象](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7d016-151">When working with the SqlClient provider in ADO.NET, transactions are initiated through a call to the [`SqlConnection` class](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) s [`BeginTransaction` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx), which returns a [`SqlTransaction` object](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx).</span></span> <span data-ttu-id="7d016-152">中放入了构成事务的数据修改语句`try...catch`块。</span><span class="sxs-lookup"><span data-stu-id="7d016-152">The data modification statements that makeup the transaction are placed within a `try...catch` block.</span></span> <span data-ttu-id="7d016-153">如果错误发生在中的语句`try`一直阻止，请执行传输至`catch`块其中事务可以回滚通过`SqlTransaction`对象 s [ `Rollback`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx)。</span><span class="sxs-lookup"><span data-stu-id="7d016-153">If an error occurs in a statement in the `try` block, execution transfers to the `catch` block where the transaction can be rolled back via the `SqlTransaction` object s [`Rollback` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx).</span></span> <span data-ttu-id="7d016-154">如果所有这些语句成功，完成调用`SqlTransaction`对象 s [ `Commit`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx)末尾`try`块提交事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-154">If all of the statements complete successfully, a call to the `SqlTransaction` object s [`Commit` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx) at the end of the `try` block commits the transaction.</span></span> <span data-ttu-id="7d016-155">下面的代码段演示此模式。</span><span class="sxs-lookup"><span data-stu-id="7d016-155">The following code snippet illustrates this pattern.</span></span> <span data-ttu-id="7d016-156">请参阅[维护与事务的数据库一致性](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)有关额外的语法和示例的 ADO.NET 中使用事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-156">See [Maintaining Database Consistency with Transactions](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx) for additional syntax and examples of using transactions with ADO.NET.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample1.cs)]

<span data-ttu-id="7d016-157">默认情况下，类型化数据集中 Tableadapter 不使用事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-157">By default, the TableAdapters in a Typed DataSet do not use transactions.</span></span> <span data-ttu-id="7d016-158">若要为事务提供支持，我们需要增加要包括的其他方法，使用上面的模式来执行一系列的范围内的事务数据修改语句的 TableAdapter 类。</span><span class="sxs-lookup"><span data-stu-id="7d016-158">To provide support for transactions we need to augment the TableAdapter classes to include additional methods that use the above pattern to perform a series of data modification statements within the scope of a transaction.</span></span> <span data-ttu-id="7d016-159">在步骤 2 中，我们将了解如何使用分部类来添加这些方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-159">In Step 2 we'll see how to use partial classes to add these methods.</span></span>

## <a name="step-1-creating-the-working-with-batched-data-web-pages"></a><span data-ttu-id="7d016-160">步骤 1： 使用批处理的数据 Web 页创建工作</span><span class="sxs-lookup"><span data-stu-id="7d016-160">Step 1: Creating the Working with Batched Data Web Pages</span></span>

<span data-ttu-id="7d016-161">我们开始浏览如何增加 DAL 以支持数据库事务之前，让我们来首先花一些时间创建本教程中我们将需要的 ASP.NET web 页面，并且按照的三个。</span><span class="sxs-lookup"><span data-stu-id="7d016-161">Before we start exploring how to augment the DAL to support database transactions, let s first take a moment to create the ASP.NET web pages that we will need for this tutorial and the three that follow.</span></span> <span data-ttu-id="7d016-162">首先，通过添加一个名为的新文件夹`BatchData`，然后添加以下将与每个页面相关联的 ASP.NET 页`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="7d016-162">Start by adding a new folder named `BatchData` and then add the following ASP.NET pages, associating each page with the `Site.master` master page.</span></span>

- `Default.aspx`
- `Transactions.aspx`
- `BatchUpdate.aspx`
- `BatchDelete.aspx`
- `BatchInsert.aspx`


![SqlDataSource 相关教程添加的 ASP.NET 页面](wrapping-database-modifications-within-a-transaction-cs/_static/image1.gif)

<span data-ttu-id="7d016-164">**图 1**： 添加 ASP.NET 页 SqlDataSource 相关教程</span><span class="sxs-lookup"><span data-stu-id="7d016-164">**Figure 1**: Add the ASP.NET Pages for the SqlDataSource-Related Tutorials</span></span>


<span data-ttu-id="7d016-165">与其他文件夹，`Default.aspx`将使用`SectionLevelTutorialListing.ascx`用户控件，若要列出其部分中的教程。</span><span class="sxs-lookup"><span data-stu-id="7d016-165">As with the other folders, `Default.aspx` will use the `SectionLevelTutorialListing.ascx` User Control to list the tutorials within its section.</span></span> <span data-ttu-id="7d016-166">因此，此用户将控件添加到`Default.aspx`通过从解决方案资源管理器拖到页面上的设计视图拖动。</span><span class="sxs-lookup"><span data-stu-id="7d016-166">Therefore, add this User Control to `Default.aspx` by dragging it from the Solution Explorer onto the page s Design view.</span></span>


<span data-ttu-id="7d016-167">[![SectionLevelTutorialListing.ascx 用户控件添加到 Default.aspx](wrapping-database-modifications-within-a-transaction-cs/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-167">[![Add the SectionLevelTutorialListing.ascx User Control to Default.aspx](wrapping-database-modifications-within-a-transaction-cs/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image1.png)</span></span>

<span data-ttu-id="7d016-168">**图 2**： 添加`SectionLevelTutorialListing.ascx`用户控件`Default.aspx`([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-168">**Figure 2**: Add the `SectionLevelTutorialListing.ascx` User Control to `Default.aspx` ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image2.png))</span></span>


<span data-ttu-id="7d016-169">最后，将这些四个页面添加到的条目为`Web.sitemap`文件。</span><span class="sxs-lookup"><span data-stu-id="7d016-169">Lastly, add these four pages as entries to the `Web.sitemap` file.</span></span> <span data-ttu-id="7d016-170">具体而言，自定义后添加以下标记站点图`<siteMapNode>`:</span><span class="sxs-lookup"><span data-stu-id="7d016-170">Specifically, add the following markup after the Customizing the Site Map `<siteMapNode>`:</span></span>


[!code-xml[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample2.xml)]

<span data-ttu-id="7d016-171">在更新后`Web.sitemap`，花些时间查看通过浏览器网站的教程。</span><span class="sxs-lookup"><span data-stu-id="7d016-171">After updating `Web.sitemap`, take a moment to view the tutorials website through a browser.</span></span> <span data-ttu-id="7d016-172">在左侧菜单现在包括批处理的数据教程使用的项。</span><span class="sxs-lookup"><span data-stu-id="7d016-172">The menu on the left now includes items for the working with batched data tutorials.</span></span>


![站点图现在包括批处理的数据教程使用的项](wrapping-database-modifications-within-a-transaction-cs/_static/image3.gif)

<span data-ttu-id="7d016-174">**图 3**： 站点图现在包括批处理的数据教程使用的项</span><span class="sxs-lookup"><span data-stu-id="7d016-174">**Figure 3**: The Site Map Now Includes Entries for the Working with Batched Data Tutorials</span></span>


## <a name="step-2-updating-the-data-access-layer-to-support-database-transactions"></a><span data-ttu-id="7d016-175">步骤 2： 更新数据访问层，以便支持数据库事务</span><span class="sxs-lookup"><span data-stu-id="7d016-175">Step 2: Updating the Data Access Layer to Support Database Transactions</span></span>

<span data-ttu-id="7d016-176">返回在第一个教程中，我们讨论[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)，我们 DAL 中的类型数据集组成数据表和 tableadapter 分离。</span><span class="sxs-lookup"><span data-stu-id="7d016-176">As we discussed back in the first tutorial, [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md), the Typed DataSet in our DAL is composed of DataTables and TableAdapters.</span></span> <span data-ttu-id="7d016-177">数据表保存数据时 Tableadapter 提供数据从数据库中读取到数据表，以更新数据库的到数据表和等的更改的功能。</span><span class="sxs-lookup"><span data-stu-id="7d016-177">The DataTables hold data while the TableAdapters provide the functionality to read data from the database into the DataTables, to update the database with changes made to the DataTables, and so forth.</span></span> <span data-ttu-id="7d016-178">回想一下 Tableadapter 用于更新数据，我称为批处理更新和 DB 直接提供两种模式。</span><span class="sxs-lookup"><span data-stu-id="7d016-178">Recall that the TableAdapters provide two patterns for updating data, which I referred to as Batch Update and DB-Direct.</span></span> <span data-ttu-id="7d016-179">使用批处理更新模式中，数据集、 数据表或返回数据行的集合传递 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="7d016-179">With the Batch Update pattern, the TableAdapter is passed a DataSet, DataTable, or collection of DataRows.</span></span> <span data-ttu-id="7d016-180">此数据枚举和每个插入、 修改或删除行， `InsertCommand`， `UpdateCommand`，或`DeleteCommand`执行。</span><span class="sxs-lookup"><span data-stu-id="7d016-180">This data is enumerated and for each inserted, modified, or deleted row, the `InsertCommand`, `UpdateCommand`, or `DeleteCommand` is executed.</span></span> <span data-ttu-id="7d016-181">使用数据库直接模式中，TableAdapter 改为传递列插入、 更新或删除单个记录所需的值。</span><span class="sxs-lookup"><span data-stu-id="7d016-181">With the DB-Direct pattern, the TableAdapter is instead passed the values of the columns necessary for inserting, updating, or deleting a single record.</span></span> <span data-ttu-id="7d016-182">DB 直接模式方法然后使用这些传入的值来执行相应`InsertCommand`， `UpdateCommand`，或`DeleteCommand`语句。</span><span class="sxs-lookup"><span data-stu-id="7d016-182">The DB Direct pattern method then uses those passed-in values to execute the appropriate `InsertCommand`, `UpdateCommand`, or `DeleteCommand` statement.</span></span>

<span data-ttu-id="7d016-183">无论所使用的更新模式，自动生成的 Tableadapter 方法不使用事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-183">Regardless of the update pattern used, the TableAdapters auto-generated methods do not use transactions.</span></span> <span data-ttu-id="7d016-184">默认情况下每个插入、 更新或删除由 TableAdapter 将被视为单个独立的操作。</span><span class="sxs-lookup"><span data-stu-id="7d016-184">By default each insert, update, or delete performed by the TableAdapter is treated as a single discrete operation.</span></span> <span data-ttu-id="7d016-185">例如，假设由 BLL 中某些代码使用 DB 直接模式是将 10 个记录插入数据库。</span><span class="sxs-lookup"><span data-stu-id="7d016-185">For instance, imagine that the DB-Direct pattern is used by some code in the BLL to insert ten records into the database.</span></span> <span data-ttu-id="7d016-186">此代码将调用 TableAdapter 的`Insert`方法十倍。</span><span class="sxs-lookup"><span data-stu-id="7d016-186">This code would call the TableAdapter s `Insert` method ten times.</span></span> <span data-ttu-id="7d016-187">如果前五个插入操作成功，但第六个一个导致异常，将在数据库中保留的前五个插入的记录。</span><span class="sxs-lookup"><span data-stu-id="7d016-187">If the first five inserts succeed, but the sixth one resulted in an exception, the first five inserted records would remain in the database.</span></span> <span data-ttu-id="7d016-188">同样，如果使用批处理更新模式执行插入、 更新和删除到插入修改，或删除数据表中的行，如果第一个多种不同的修改成功，但更高版本时出错，这些较早的修改，完成将保留在数据库中。</span><span class="sxs-lookup"><span data-stu-id="7d016-188">Similarly, if the Batch Update pattern is used to perform inserts, updates, and deletes to the inserted, modified, and deleted rows in a DataTable, if the first several modifications succeeded but a later one encountered an error, those earlier modifications that completed would remain in the database.</span></span>

<span data-ttu-id="7d016-189">在某些情况下，我们想要跨的一系列修改确保原子性。</span><span class="sxs-lookup"><span data-stu-id="7d016-189">In certain scenarios we want to ensure atomicity across a series of modifications.</span></span> <span data-ttu-id="7d016-190">若要完成此我们必须通过添加新方法的执行手动扩展 TableAdapter `InsertCommand`， `UpdateCommand`，和`DeleteCommand`s 之下的事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-190">To accomplish this we must manually extend the TableAdapter by adding new methods that execute the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s under the umbrella of a transaction.</span></span> <span data-ttu-id="7d016-191">在[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)我们看使用[分部类](http://en.wikipedia.org/wiki/Partial_type)来扩展在类型化数据集中数据表的功能。</span><span class="sxs-lookup"><span data-stu-id="7d016-191">In [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) we looked at using [partial classes](http://en.wikipedia.org/wiki/Partial_type) to extend the functionality of the DataTables within the Typed DataSet.</span></span> <span data-ttu-id="7d016-192">此方法还可以用于 Tableadapter。</span><span class="sxs-lookup"><span data-stu-id="7d016-192">This technique can also be used with TableAdapters.</span></span>

<span data-ttu-id="7d016-193">类型化数据集`Northwind.xsd`位于`App_Code`文件夹的`DAL`子文件夹。</span><span class="sxs-lookup"><span data-stu-id="7d016-193">The Typed DataSet `Northwind.xsd` is located in the `App_Code` folder s `DAL` subfolder.</span></span> <span data-ttu-id="7d016-194">创建的子文件夹中`DAL`文件夹名为`TransactionSupport`并添加名为的新类文件`ProductsTableAdapter.TransactionSupport.cs`（请参见图 4）。</span><span class="sxs-lookup"><span data-stu-id="7d016-194">Create a subfolder in the `DAL` folder named `TransactionSupport` and add a new class file named `ProductsTableAdapter.TransactionSupport.cs` (see Figure 4).</span></span> <span data-ttu-id="7d016-195">此文件将保存的部分实现`ProductsTableAdapter`，包括用于执行使用事务的数据修改的方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-195">This file will hold the partial implementation of the `ProductsTableAdapter` that includes methods for performing data modifications using a transaction.</span></span>


![添加一个名为 TransactionSupport 文件夹和一个名为 ProductsTableAdapter.TransactionSupport.cs 的类文件](wrapping-database-modifications-within-a-transaction-cs/_static/image4.gif)

<span data-ttu-id="7d016-197">**图 4**： 添加名为的文件夹`TransactionSupport`和一个名为的类文件 `ProductsTableAdapter.TransactionSupport.cs`</span><span class="sxs-lookup"><span data-stu-id="7d016-197">**Figure 4**: Add a Folder Named `TransactionSupport` and a Class File Named `ProductsTableAdapter.TransactionSupport.cs`</span></span>


<span data-ttu-id="7d016-198">输入下面的代码插入`ProductsTableAdapter.TransactionSupport.cs`文件：</span><span class="sxs-lookup"><span data-stu-id="7d016-198">Enter the following code into the `ProductsTableAdapter.TransactionSupport.cs` file:</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample3.cs)]

<span data-ttu-id="7d016-199">`partial`向中添加的成员是要添加到编译器的类声明中的关键字指示`ProductsTableAdapter`类`NorthwindTableAdapters`命名空间。</span><span class="sxs-lookup"><span data-stu-id="7d016-199">The `partial` keyword in the class declaration here indicates to the compiler that the members added within are to be added to the `ProductsTableAdapter` class in the `NorthwindTableAdapters` namespace.</span></span> <span data-ttu-id="7d016-200">请注意`using System.Data.SqlClient`语句文件的顶部。</span><span class="sxs-lookup"><span data-stu-id="7d016-200">Note the `using System.Data.SqlClient` statement at the top of the file.</span></span> <span data-ttu-id="7d016-201">TableAdapter 配置为使用 SqlClient 提供程序，因为内部它使用[ `SqlDataAdapter` ](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx)要向数据库发出其命令对象。</span><span class="sxs-lookup"><span data-stu-id="7d016-201">Since the TableAdapter was configured to use the SqlClient provider, internally it uses a [`SqlDataAdapter`](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx) object to issue its commands to the database.</span></span> <span data-ttu-id="7d016-202">因此，我们需要使用`SqlTransaction`类以开始事务，然后将其提交或回滚它。</span><span class="sxs-lookup"><span data-stu-id="7d016-202">Consequently, we need to use the `SqlTransaction` class to begin the transaction and then to commit it or roll it back.</span></span> <span data-ttu-id="7d016-203">如果你使用的 Microsoft SQL Server 之外的数据存储，你将需要使用相应的提供程序。</span><span class="sxs-lookup"><span data-stu-id="7d016-203">If you are using a data store other than Microsoft SQL Server, you'll need to use the appropriate provider.</span></span>

<span data-ttu-id="7d016-204">这些方法提供开始回滚时，所需的构建基块，并提交事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-204">These methods provide the building blocks needed to start, rollback, and commit a transaction.</span></span> <span data-ttu-id="7d016-205">它们标记`public`，使其能够从使用`ProductsTableAdapter`、 DAL 中的另一个类或结构，如 BLL 中的另一层。</span><span class="sxs-lookup"><span data-stu-id="7d016-205">They are marked `public`, enabling them to be used from within the `ProductsTableAdapter`, from another class in the DAL, or from another layer in the architecture, such as the BLL.</span></span> <span data-ttu-id="7d016-206">`BeginTransaction` 将打开 TableAdapter s 内部`SqlConnection`（如果需要），开始事务，并将它分配给`Transaction`属性，并将事务附加到内部`SqlDataAdapter`s`SqlCommand`对象。</span><span class="sxs-lookup"><span data-stu-id="7d016-206">`BeginTransaction` opens the TableAdapter s internal `SqlConnection` (if needed), begins the transaction and assigns it to the `Transaction` property, and attaches the transaction to the internal `SqlDataAdapter` s `SqlCommand` objects.</span></span> <span data-ttu-id="7d016-207">`CommitTransaction` 和`RollbackTransaction`调用`Transaction`对象 s`Commit`和`Rollback`方法，分别之前关闭内部`Connection`对象。</span><span class="sxs-lookup"><span data-stu-id="7d016-207">`CommitTransaction` and `RollbackTransaction` call the `Transaction` object s `Commit` and `Rollback` methods, respectively, before closing the internal `Connection` object.</span></span>

## <a name="step-3-adding-methods-to-update-and-delete-data-under-the-umbrella-of-a-transaction"></a><span data-ttu-id="7d016-208">步骤 3： 添加方法以更新和删除数据之下的事务</span><span class="sxs-lookup"><span data-stu-id="7d016-208">Step 3: Adding Methods to Update and Delete Data Under the Umbrella of a Transaction</span></span>

<span data-ttu-id="7d016-209">使用这些方法完成的情况下，我们重新准备好将方法添加到`ProductsDataTable`或 BLL 执行一系列之下的事务的命令。</span><span class="sxs-lookup"><span data-stu-id="7d016-209">With these methods complete, we re ready to add methods to `ProductsDataTable` or the BLL that perform a series of commands under the umbrella of a transaction.</span></span> <span data-ttu-id="7d016-210">以下方法使用批处理更新模式来更新`ProductsDataTable`实例使用事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-210">The following method uses the Batch Update pattern to update a `ProductsDataTable` instance using a transaction.</span></span> <span data-ttu-id="7d016-211">它通过调用启动事务`BeginTransaction`方法，然后使用`try...catch`用于发出数据修改语句块。</span><span class="sxs-lookup"><span data-stu-id="7d016-211">It starts a transaction by calling the `BeginTransaction` method and then uses a `try...catch` block to issue the data modification statements.</span></span> <span data-ttu-id="7d016-212">如果调用`Adapter`对象 s`Update`方法会引发异常，则执行会传输到`catch`其中将回滚事务的块和重新引发的异常。</span><span class="sxs-lookup"><span data-stu-id="7d016-212">If the call to the `Adapter` object s `Update` method results in an exception, execution will transfer to the `catch` block where the transaction will be rolled back and the exception re-thrown.</span></span> <span data-ttu-id="7d016-213">回想一下，`Update`方法通过枚举所提供的行来实现批处理更新模式`ProductsDataTable`并执行所需`InsertCommand`， `UpdateCommand`，和`DeleteCommand`s。</span><span class="sxs-lookup"><span data-stu-id="7d016-213">Recall that the `Update` method implements the Batch Update pattern by enumerating the rows of the supplied `ProductsDataTable` and performing the necessary `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s.</span></span> <span data-ttu-id="7d016-214">如果任何一个的这些命令将导致错误，事务将回滚撤消以前的事务 s 生命周期内所做的修改。</span><span class="sxs-lookup"><span data-stu-id="7d016-214">If any one of these commands results in an error, the transaction is rolled back, undoing the previous modifications made during the transaction s lifetime.</span></span> <span data-ttu-id="7d016-215">应`Update`语句完成而未出现错误，则整个提交事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-215">Should the `Update` statement complete without error, the transaction is committed in its entirety.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample4.cs)]

<span data-ttu-id="7d016-216">添加`UpdateWithTransaction`方法`ProductsTableAdapter`类中的分部类通过`ProductsTableAdapter.TransactionSupport.cs`。</span><span class="sxs-lookup"><span data-stu-id="7d016-216">Add the `UpdateWithTransaction` method to the `ProductsTableAdapter` class through the partial class in `ProductsTableAdapter.TransactionSupport.cs`.</span></span> <span data-ttu-id="7d016-217">或者，此方法无法添加到业务逻辑层的`ProductsBLL`有几个次要的语法更改的类。</span><span class="sxs-lookup"><span data-stu-id="7d016-217">Alternatively, this method could be added to the Business Logic Layer s `ProductsBLL` class with a few minor syntactical changes.</span></span> <span data-ttu-id="7d016-218">也就是说，关键字在`this.BeginTransaction()`， `this.CommitTransaction()`，和`this.RollbackTransaction()`需要替换为`Adapter`(回想一下，`Adapter`是中的属性的名称`ProductsBLL`类型的`ProductsTableAdapter`)。</span><span class="sxs-lookup"><span data-stu-id="7d016-218">Namely, the keyword this in `this.BeginTransaction()`, `this.CommitTransaction()`, and `this.RollbackTransaction()` would need to be replaced with `Adapter` (recall that `Adapter` is the name of a property in `ProductsBLL` of type `ProductsTableAdapter`).</span></span>

<span data-ttu-id="7d016-219">`UpdateWithTransaction`方法使用批处理更新模式中，但还可以在事务，如下所示方法范围内使用一系列 DB 直接调用。</span><span class="sxs-lookup"><span data-stu-id="7d016-219">The `UpdateWithTransaction` method uses the Batch Update pattern, but a series of DB-Direct calls can also be used within the scope of a transaction, as the following method shows.</span></span> <span data-ttu-id="7d016-220">`DeleteProductsWithTransaction`方法接受作为输入`List<T>`类型的`int`，这是`ProductID`s 可删除。</span><span class="sxs-lookup"><span data-stu-id="7d016-220">The `DeleteProductsWithTransaction` method accepts as input a `List<T>` of type `int`, which are the `ProductID` s to delete.</span></span> <span data-ttu-id="7d016-221">方法启动通过调用事务`BeginTransaction`，然后在`try`阻止，循环访问所提供的列表，调用 DB 直接模式`Delete`方法为每个`ProductID`值。</span><span class="sxs-lookup"><span data-stu-id="7d016-221">The method initiates the transaction via a call to `BeginTransaction` and then, in the `try` block, iterates through the supplied list calling the DB-Direct pattern `Delete` method for each `ProductID` value.</span></span> <span data-ttu-id="7d016-222">如果调用的任何`Delete`失败，将控制传输到`catch`块其中事务将回滚并重新引发的异常。</span><span class="sxs-lookup"><span data-stu-id="7d016-222">If any of the calls to `Delete` fails, control is transferred to the `catch` block where the transaction is rolled back and the exception re-thrown.</span></span> <span data-ttu-id="7d016-223">如果所有调用`Delete`成功，则会提交事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-223">If all calls to `Delete` succeed, then transaction is committed.</span></span> <span data-ttu-id="7d016-224">将以下方法添加到`ProductsBLL`类。</span><span class="sxs-lookup"><span data-stu-id="7d016-224">Add this method to the `ProductsBLL` class.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample5.cs)]

## <a name="applying-transactions-across-multiple-tableadapters"></a><span data-ttu-id="7d016-225">跨多个 Tableadapter 应用事务</span><span class="sxs-lookup"><span data-stu-id="7d016-225">Applying Transactions Across Multiple TableAdapters</span></span>

<span data-ttu-id="7d016-226">在本教程中检查与事务相关代码允许使用多个语句`ProductsTableAdapter`视为原子操作。</span><span class="sxs-lookup"><span data-stu-id="7d016-226">The transaction-related code examined in this tutorial allows for multiple statements against the `ProductsTableAdapter` to be treated as an atomic operation.</span></span> <span data-ttu-id="7d016-227">但是，如果多个不同的数据库表进行修改需要以原子方式执行？</span><span class="sxs-lookup"><span data-stu-id="7d016-227">But what if multiple modifications to different database tables need to be performed atomically?</span></span> <span data-ttu-id="7d016-228">例如，当删除某个类别时，我们可能会首先要重新分配到某些其他类别及其当前产品。</span><span class="sxs-lookup"><span data-stu-id="7d016-228">For instance, when deleting a category, we might first want to reassign its current products to some other category.</span></span> <span data-ttu-id="7d016-229">作为一个原子操作，应执行这两个步骤重新分配产品和删除类别。</span><span class="sxs-lookup"><span data-stu-id="7d016-229">These two steps reassigning the products and deleting the category should be executed as an atomic operation.</span></span> <span data-ttu-id="7d016-230">但是`ProductsTableAdapter`仅包括方法修改`Products`表和`CategoriesTableAdapter`仅包括方法修改`Categories`表。</span><span class="sxs-lookup"><span data-stu-id="7d016-230">But the `ProductsTableAdapter` includes only methods for modifying the `Products` table and the `CategoriesTableAdapter` includes only methods for modifying the `Categories` table.</span></span> <span data-ttu-id="7d016-231">那么，如何事务可以包含两个 Tableadapter</span><span class="sxs-lookup"><span data-stu-id="7d016-231">So how can a transaction encompass both TableAdapters?</span></span>

<span data-ttu-id="7d016-232">一种选择是将方法添加到`CategoriesTableAdapter`名为`DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)`然后使该方法调用存储的过程，同时重新分配产品并删除存储过程内定义的事务范围内的类别。</span><span class="sxs-lookup"><span data-stu-id="7d016-232">One option is to add a method to the `CategoriesTableAdapter` named `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` and have that method call a stored procedure that both reassigns the products and deletes the category within the scope of a transaction defined within the stored procedure.</span></span> <span data-ttu-id="7d016-233">我们将了解如何开始、 提交，以及存储过程中的回滚事务在将来的教程。</span><span class="sxs-lookup"><span data-stu-id="7d016-233">We'll look at how to begin, commit, and rollback transactions in stored procedures in a future tutorial.</span></span>

<span data-ttu-id="7d016-234">另一个选项是在包含 DAL 中创建一个帮助器类`DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-234">Another option is to create a helper class in the DAL that contains the `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` method.</span></span> <span data-ttu-id="7d016-235">此方法将创建的实例`CategoriesTableAdapter`和`ProductsTableAdapter`然后将这些设置两个 Tableadapter`Connection`属性设置为相同`SqlConnection`实例。</span><span class="sxs-lookup"><span data-stu-id="7d016-235">This method would create an instance of the `CategoriesTableAdapter` and the `ProductsTableAdapter` and then set these two TableAdapters `Connection` properties to the same `SqlConnection` instance.</span></span> <span data-ttu-id="7d016-236">在该点，两个 Tableadapter 中的任一将启动的事务，以及调用`BeginTransaction`。</span><span class="sxs-lookup"><span data-stu-id="7d016-236">At that point, either one of the two TableAdapters would initiate the transaction with a call to `BeginTransaction`.</span></span> <span data-ttu-id="7d016-237">重新分配产品和删除类别的 Tableadapter 方法将调用中`try...catch`与事务提交或回滚返回根据需要的块。</span><span class="sxs-lookup"><span data-stu-id="7d016-237">The TableAdapters methods for reassigning the products and deleting the category would be invoked in a `try...catch` block with the transaction committed or rolled back as needed.</span></span>

## <a name="step-4-adding-theupdatewithtransactionmethod-to-the-business-logic-layer"></a><span data-ttu-id="7d016-238">步骤 4： 添加`UpdateWithTransaction`业务逻辑层的方法</span><span class="sxs-lookup"><span data-stu-id="7d016-238">Step 4: Adding the`UpdateWithTransaction`Method to the Business Logic Layer</span></span>

<span data-ttu-id="7d016-239">在步骤 3 中，我们将添加`UpdateWithTransaction`方法`ProductsTableAdapter`DAL 中。</span><span class="sxs-lookup"><span data-stu-id="7d016-239">In Step 3 we added an `UpdateWithTransaction` method to the `ProductsTableAdapter` in the DAL.</span></span> <span data-ttu-id="7d016-240">我们应将相应的方法添加到 BLL。</span><span class="sxs-lookup"><span data-stu-id="7d016-240">We should add a corresponding method to the BLL.</span></span> <span data-ttu-id="7d016-241">表示层可以调用直接下 DAL 调用时`UpdateWithTransaction`方法，这些教程具有努力定义使与表示层 DAL 一个分层体系结构。</span><span class="sxs-lookup"><span data-stu-id="7d016-241">While the Presentation Layer could call directly down to the DAL to invoke the `UpdateWithTransaction` method, these tutorials have strived to define a layered architecture that insulates the DAL from the Presentation Layer.</span></span> <span data-ttu-id="7d016-242">因此，它 behooves 我们能够继续这种方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-242">Therefore, it behooves us to continue this approach.</span></span>

<span data-ttu-id="7d016-243">打开`ProductsBLL`类文件，并添加一个名为方法`UpdateWithTransaction`到相应的 DAL 方法只需调用。</span><span class="sxs-lookup"><span data-stu-id="7d016-243">Open the `ProductsBLL` class file and add a method named `UpdateWithTransaction` that simply calls down to the corresponding DAL method.</span></span> <span data-ttu-id="7d016-244">现在应该在两个新方法`ProductsBLL`: `UpdateWithTransaction`，只需添加和`DeleteProductsWithTransaction`，它被添加在步骤 3 中。</span><span class="sxs-lookup"><span data-stu-id="7d016-244">There should now be two new methods in `ProductsBLL`: `UpdateWithTransaction`, which you just added, and `DeleteProductsWithTransaction`, which was added in Step 3.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample6.cs)]

> [!NOTE]
> <span data-ttu-id="7d016-245">这些方法不包括`DataObjectMethodAttribute`分配给中的大多数其他方法特性`ProductsBLL`类，因为我们将调用这些方法直接从 ASP.NET 页代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="7d016-245">These methods do not include the `DataObjectMethodAttribute` attribute assigned to most other methods in the `ProductsBLL` class because we'll be invoking these methods directly from the ASP.NET pages code-behind classes.</span></span> <span data-ttu-id="7d016-246">回想一下，`DataObjectMethodAttribute`用于标记何种方法应出现在 ObjectDataSource 的配置数据源向导和 （选择、 更新、 插入或删除） 哪些选项卡下。</span><span class="sxs-lookup"><span data-stu-id="7d016-246">Recall that `DataObjectMethodAttribute` is used to flag what methods should appear in the ObjectDataSource s Configure Data Source wizard and under what tab (SELECT, UPDATE, INSERT, or DELETE).</span></span> <span data-ttu-id="7d016-247">因为 GridView 中没有批处理编辑或删除任何内置支持，我们将需要以编程方式调用这些方法，而不是使用无需编码的声明性方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-247">Since the GridView lacks any built-in support for batch editing or deleting, we'll have to invoke these methods programmatically rather than use the code-free declarative approach.</span></span>


## <a name="step-5-atomically-updating-database-data-from-the-presentation-layer"></a><span data-ttu-id="7d016-248">步骤 5： 以原子方式更新数据库数据的表示层</span><span class="sxs-lookup"><span data-stu-id="7d016-248">Step 5: Atomically Updating Database Data from the Presentation Layer</span></span>

<span data-ttu-id="7d016-249">若要说明的影响事务更新一批记录时，让 s 创建列出一个 GridView 中的所有产品，并包含按钮 Web 的用户界面控件，单击时，重新分配产品`CategoryID`值。</span><span class="sxs-lookup"><span data-stu-id="7d016-249">To illustrate the effect that the transaction has when updating a batch of records, let s create a user interface that lists all products in a GridView and includes a Button Web control that, when clicked, reassigns the products `CategoryID` values.</span></span> <span data-ttu-id="7d016-250">具体而言，类别重新指派将进度，以便第一个有好几种产品分配一个有效`CategoryID`分配不存在的值而有些则是有意`CategoryID`值。</span><span class="sxs-lookup"><span data-stu-id="7d016-250">In particular, the category reassignment will progress so that the first several products are assigned a valid `CategoryID` value while others are purposefully assigned a non-existent `CategoryID` value.</span></span> <span data-ttu-id="7d016-251">如果我们尝试使用产品更新数据库其`CategoryID`与现有类别 s 不匹配`CategoryID`，将发生违反外键约束，并且将引发异常。</span><span class="sxs-lookup"><span data-stu-id="7d016-251">If we attempt to update the database with a product whose `CategoryID` does not match an existing category s `CategoryID`, a foreign key constraint violation will occur and an exception will be raised.</span></span> <span data-ttu-id="7d016-252">我们将看到在此示例是，如果使用事务从外键约束冲突引发的异常将导致以前有效`CategoryID`更改将被回滚。</span><span class="sxs-lookup"><span data-stu-id="7d016-252">What we'll see in this example is that when using a transaction the exception raised from the foreign key constraint violation will cause the previous valid `CategoryID` changes to be rolled back.</span></span> <span data-ttu-id="7d016-253">当未使用事务，但是，将保持对初始类别进行修改。</span><span class="sxs-lookup"><span data-stu-id="7d016-253">When not using a transaction, however, the modifications to the initial categories will remain.</span></span>

<span data-ttu-id="7d016-254">首先打开`Transactions.aspx`页面`BatchData`文件夹，然后拖动一个 GridView 从工具箱中拖动到设计器。</span><span class="sxs-lookup"><span data-stu-id="7d016-254">Start by opening the `Transactions.aspx` page in the `BatchData` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="7d016-255">设置其`ID`到`Products`和从其智能标记，请将其绑定到名为新 ObjectDataSource `ProductsDataSource`。</span><span class="sxs-lookup"><span data-stu-id="7d016-255">Set its `ID` to `Products` and, from its smart tag, bind it to a new ObjectDataSource named `ProductsDataSource`.</span></span> <span data-ttu-id="7d016-256">配置对象数据源将从其数据拉`ProductsBLL`类的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-256">Configure the ObjectDataSource to pull its data from the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="7d016-257">这将是只读的 GridView，因此设置下拉列表在更新中，插入和删除选项卡添加到 （无） 并单击完成。</span><span class="sxs-lookup"><span data-stu-id="7d016-257">This will be a read-only GridView, so set the drop-down lists in the UPDATE, INSERT, and DELETE tabs to (None) and click Finish.</span></span>


<span data-ttu-id="7d016-258">[![图 5： 配置对象数据源以使用 ProductsBLL 类的 GetProducts 方法](wrapping-database-modifications-within-a-transaction-cs/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-258">[![Figure 5: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProducts Method](wrapping-database-modifications-within-a-transaction-cs/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image3.png)</span></span>

<span data-ttu-id="7d016-259">**图 5**： 图 5： 配置使用 ObjectDataSource`ProductsBLL`类 s`GetProducts`方法 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-259">**Figure 5**: Figure 5: Configure the ObjectDataSource to Use the `ProductsBLL` Class s `GetProducts` Method ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image4.png))</span></span>


<span data-ttu-id="7d016-260">[![在更新中，INSERT、 设置的下拉列表和删除选项卡到 （无）](wrapping-database-modifications-within-a-transaction-cs/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-260">[![Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None)](wrapping-database-modifications-within-a-transaction-cs/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image5.png)</span></span>

<span data-ttu-id="7d016-261">**图 6**： 设置的下拉列表中更新、 插入和删除选项卡为 （无） ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-261">**Figure 6**: Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None) ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image6.png))</span></span>


<span data-ttu-id="7d016-262">完成配置数据源向导后，Visual Studio 将创建 BoundFields 和产品数据字段 CheckBoxField。</span><span class="sxs-lookup"><span data-stu-id="7d016-262">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and a CheckBoxField for the product data fields.</span></span> <span data-ttu-id="7d016-263">删除所有除这些字段`ProductID`， `ProductName`， `CategoryID`，和`CategoryName`和重命名`ProductName`和`CategoryName`BoundFields`HeaderText`属性设置为产品和类别，分别。</span><span class="sxs-lookup"><span data-stu-id="7d016-263">Remove all of these fields except for `ProductID`, `ProductName`, `CategoryID`, and `CategoryName` and rename the `ProductName` and `CategoryName` BoundFields `HeaderText` properties to Product and Category, respectively.</span></span> <span data-ttu-id="7d016-264">通过智能标记中，选中启用分页选项。</span><span class="sxs-lookup"><span data-stu-id="7d016-264">From the smart tag, check the Enable Paging option.</span></span> <span data-ttu-id="7d016-265">进行这些修改后, 的 GridView 和 ObjectDataSource s 声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="7d016-265">After making these modifications, the GridView and ObjectDataSource s declarative markup should look like the following:</span></span>


[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample7.aspx)]

<span data-ttu-id="7d016-266">接下来，添加上面 GridView 的三个按钮 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="7d016-266">Next, add three Button Web controls above the GridView.</span></span> <span data-ttu-id="7d016-267">设置为刷新网格、 修改类别 （与事务），到第二个 s 和修改类别 （而无需事务） 到第三个一个 s s Text 属性的第一个按钮。</span><span class="sxs-lookup"><span data-stu-id="7d016-267">Set the first Button s Text property to Refresh Grid, the second s to Modify Categories (WITH TRANSACTION), and the third one s to Modify Categories (WITHOUT TRANSACTION) .</span></span>


[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample8.aspx)]

<span data-ttu-id="7d016-268">此时 Visual Studio 中的设计视图应类似于的屏幕快照中图 7 所示。</span><span class="sxs-lookup"><span data-stu-id="7d016-268">At this point the Design view in Visual Studio should look similar to the screen shot shown in Figure 7.</span></span>


<span data-ttu-id="7d016-269">[![页包含一个 GridView 和三个按钮 Web 控件](wrapping-database-modifications-within-a-transaction-cs/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-269">[![The Page Contains a GridView and Three Button Web Controls](wrapping-database-modifications-within-a-transaction-cs/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image7.png)</span></span>

<span data-ttu-id="7d016-270">**图 7**： 的页面包含一个 GridView 和三个按钮 Web 控件 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-270">**Figure 7**: The Page Contains a GridView and Three Button Web Controls ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image8.png))</span></span>


<span data-ttu-id="7d016-271">为每个三个按钮 s 创建事件处理程序`Click`事件并使用下面的代码：</span><span class="sxs-lookup"><span data-stu-id="7d016-271">Create event handlers for each of the three Button s `Click` events and use the following code:</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample9.cs)]

<span data-ttu-id="7d016-272">刷新按钮 s`Click`事件处理程序仅重新绑定到 GridView 数据，通过调用`Products`GridView 的`DataBind`方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-272">The refresh Button s `Click` event handler simply rebinds the data to the GridView by calling the `Products` GridView s `DataBind` method.</span></span>

<span data-ttu-id="7d016-273">第二个事件处理程序重新分配产品`CategoryID`s 并使用新的事务方法从 BLL 执行数据库更新之下的事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-273">The second event handler reassigns the products `CategoryID` s and uses the new transaction method from the BLL to perform the database updates under the umbrella of a transaction.</span></span> <span data-ttu-id="7d016-274">请注意，每个产品 s`CategoryID`任意设置相同的值为其`ProductID`。</span><span class="sxs-lookup"><span data-stu-id="7d016-274">Note that each product s `CategoryID` is arbitrarily set to the same value as its `ProductID`.</span></span> <span data-ttu-id="7d016-275">这将不错的第一个几种产品，因为这些产品具有`ProductID`碰巧将映射到有效的值`CategoryID`s。</span><span class="sxs-lookup"><span data-stu-id="7d016-275">This will work fine for the first few products, since those products have `ProductID` values that happen to map to valid `CategoryID` s.</span></span> <span data-ttu-id="7d016-276">但一次`ProductID`s 开始变得过大，这种巧合重叠的`ProductID`s 和`CategoryID`s 不再适用。</span><span class="sxs-lookup"><span data-stu-id="7d016-276">But once the `ProductID` s start getting too large, this coincidental overlap of `ProductID` s and `CategoryID` s no longer applies.</span></span>

<span data-ttu-id="7d016-277">第三个`Click`事件处理程序更新产品`CategoryID`中相同的方式，但将更新发送到数据库使用`ProductsTableAdapter`s 默认`Update`方法。</span><span class="sxs-lookup"><span data-stu-id="7d016-277">The third `Click` event handler updates the products `CategoryID` s in the same manner, but sends the update to the database using the `ProductsTableAdapter` s default `Update` method.</span></span> <span data-ttu-id="7d016-278">这`Update`方法不会包装在事务中的命令序列，以便在第一个遇到外键约束冲突错误之前进行这些更改将保持不变。</span><span class="sxs-lookup"><span data-stu-id="7d016-278">This `Update` method does not wrap the series of commands within a transaction, so those changes are made prior to the first encountered foreign key constraint violation error will persist.</span></span>

<span data-ttu-id="7d016-279">若要演示此行为，请访问此页通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="7d016-279">To demonstrate this behavior, visit this page through a browser.</span></span> <span data-ttu-id="7d016-280">最初，在图 8 所示，你应看到数据的第一页。</span><span class="sxs-lookup"><span data-stu-id="7d016-280">Initially you should see the first page of data as shown in Figure 8.</span></span> <span data-ttu-id="7d016-281">接下来，单击修改类别 （与事务） 按钮。</span><span class="sxs-lookup"><span data-stu-id="7d016-281">Next, click the Modify Categories (WITH TRANSACTION) button.</span></span> <span data-ttu-id="7d016-282">这将导致回发，尝试更新的所有产品`CategoryID`值，但将导致违反外键约束 （请参阅图 9）。</span><span class="sxs-lookup"><span data-stu-id="7d016-282">This will cause a postback and attempt to update all of the products `CategoryID` values, but will result in a foreign key constraint violation (see Figure 9).</span></span>


<span data-ttu-id="7d016-283">[![产品显示在可分页的 GridView](wrapping-database-modifications-within-a-transaction-cs/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-283">[![The Products are Displayed in a Pageable GridView](wrapping-database-modifications-within-a-transaction-cs/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image9.png)</span></span>

<span data-ttu-id="7d016-284">**图 8**: 的产品显示在可分页 GridView ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-284">**Figure 8**: The Products are Displayed in a Pageable GridView ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image10.png))</span></span>


<span data-ttu-id="7d016-285">[![重新分配类别导致违反外键约束](wrapping-database-modifications-within-a-transaction-cs/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-285">[![Reassigning the Categories Results in a Foreign Key Constraint Violation](wrapping-database-modifications-within-a-transaction-cs/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image11.png)</span></span>

<span data-ttu-id="7d016-286">**图 9**： 重新分配类别导致违反了外键约束 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-286">**Figure 9**: Reassigning the Categories Results in a Foreign Key Constraint Violation ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image12.png))</span></span>


<span data-ttu-id="7d016-287">现在命中你浏览器 s 后退按钮，然后单击刷新网格按钮。</span><span class="sxs-lookup"><span data-stu-id="7d016-287">Now hit your browser s Back button and then click the Refresh Grid button.</span></span> <span data-ttu-id="7d016-288">在刷新数据时你应看到完全相同的输出，如图 8 中所示。</span><span class="sxs-lookup"><span data-stu-id="7d016-288">Upon refreshing the data you should see the exact same output as shown in Figure 8.</span></span> <span data-ttu-id="7d016-289">也就是说，即使尽管某些产品`CategoryID`s 已更改为合法的值并在数据库中更新，它们时回滚发生外键约束冲突。</span><span class="sxs-lookup"><span data-stu-id="7d016-289">That is, even though some of the products `CategoryID` s were changed to legal values and updated in the database, they were rolled back when the foreign key constraint violation occurred.</span></span>

<span data-ttu-id="7d016-290">现在请尝试单击修改类别 （而无需事务） 按钮。</span><span class="sxs-lookup"><span data-stu-id="7d016-290">Now try clicking the Modify Categories (WITHOUT TRANSACTION) button.</span></span> <span data-ttu-id="7d016-291">这将导致相同的外键约束冲突错误 （请参阅图 9），但这次请这些产品其`CategoryID`值已更改为合法值将不会回滚。</span><span class="sxs-lookup"><span data-stu-id="7d016-291">This will result in the same foreign key constraint violation error (see Figure 9), but this time those products whose `CategoryID` values were changed to a legal value will not be rolled back.</span></span> <span data-ttu-id="7d016-292">命中你浏览器 s 后退按钮，然后刷新网格按钮。</span><span class="sxs-lookup"><span data-stu-id="7d016-292">Hit your browser s Back button and then the Refresh Grid button.</span></span> <span data-ttu-id="7d016-293">如图 10 显示， `CategoryID` s 前八个产品已被重新分配。</span><span class="sxs-lookup"><span data-stu-id="7d016-293">As Figure 10 shows, the `CategoryID` s of the first eight products have been reassigned.</span></span> <span data-ttu-id="7d016-294">例如，在图 8 中，更改必须`CategoryID`为 1，但在图 10 it s 已重新分配到 2。</span><span class="sxs-lookup"><span data-stu-id="7d016-294">For example, in Figure 8, Chang had a `CategoryID` of 1, but in Figure 10 it s been reassigned to 2.</span></span>


<span data-ttu-id="7d016-295">[![某些产品 CategoryID 值未更新而其他人已](wrapping-database-modifications-within-a-transaction-cs/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="7d016-295">[![Some Products CategoryID Values were Updated While Others Were Not](wrapping-database-modifications-within-a-transaction-cs/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image13.png)</span></span>

<span data-ttu-id="7d016-296">**图 10**： 某些产品`CategoryID`值未更新而其他人已 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="7d016-296">**Figure 10**: Some Products `CategoryID` Values were Updated While Others Were Not ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image14.png))</span></span>


## <a name="summary"></a><span data-ttu-id="7d016-297">总结</span><span class="sxs-lookup"><span data-stu-id="7d016-297">Summary</span></span>

<span data-ttu-id="7d016-298">默认情况下，TableAdapter 的方法在事务范围内未包装的执行的数据库语句，但我们可以轻而易举地添加将创建的方法、 提交和回滚事务。</span><span class="sxs-lookup"><span data-stu-id="7d016-298">By default, the TableAdapter s methods do not wrap the executed database statements within the scope of a transaction, but with a little work we can add methods that will create, commit, and rollback a transaction.</span></span> <span data-ttu-id="7d016-299">在本教程中，我们将创建三个此类方法中的`ProductsTableAdapter`类： `BeginTransaction`， `CommitTransaction`，和`RollbackTransaction`。</span><span class="sxs-lookup"><span data-stu-id="7d016-299">In this tutorial we created three such methods in the `ProductsTableAdapter` class: `BeginTransaction`, `CommitTransaction`, and `RollbackTransaction`.</span></span> <span data-ttu-id="7d016-300">我们已了解如何使用这些方法以及`try...catch`用于进行数据修改语句一系列原子块。</span><span class="sxs-lookup"><span data-stu-id="7d016-300">We saw how to use these methods along with a `try...catch` block to make a series of data modification statements atomic.</span></span> <span data-ttu-id="7d016-301">具体而言，我们创建`UpdateWithTransaction`中的方法`ProductsTableAdapter`，它用批处理更新模式来执行必要的修改提供的行`ProductsDataTable`。</span><span class="sxs-lookup"><span data-stu-id="7d016-301">In particular, we created the `UpdateWithTransaction` method in the `ProductsTableAdapter`, which uses the Batch Update pattern to perform the necessary modifications to the rows of a supplied `ProductsDataTable`.</span></span> <span data-ttu-id="7d016-302">我们还添加了`DeleteProductsWithTransaction`方法`ProductsBLL`中 BLL，它接受类`List`的`ProductID`值作为其输入并调用 DB 直接模式方法`Delete`每个`ProductID`。</span><span class="sxs-lookup"><span data-stu-id="7d016-302">We also added the `DeleteProductsWithTransaction` method to the `ProductsBLL` class in the BLL, which accepts a `List` of `ProductID` values as its input and calls the DB-Direct pattern method `Delete` for each `ProductID`.</span></span> <span data-ttu-id="7d016-303">这两种方法启动： 创建事务，然后执行内的数据修改语句`try...catch`块。</span><span class="sxs-lookup"><span data-stu-id="7d016-303">Both methods start by creating a transaction and then executing the data modification statements within a `try...catch` block.</span></span> <span data-ttu-id="7d016-304">如果发生异常，事务将回滚，否则它是已提交。</span><span class="sxs-lookup"><span data-stu-id="7d016-304">If an exception occurs, the transaction is rolled back, otherwise it is committed.</span></span>

<span data-ttu-id="7d016-305">步骤 5 所示的与批处理更新忽略使用事务的事务性批处理更新的效果。</span><span class="sxs-lookup"><span data-stu-id="7d016-305">Step 5 illustrated the effect of transactional batch updates versus batch updates that neglected to use a transaction.</span></span> <span data-ttu-id="7d016-306">接下来三个教程中我们将在本教程中的布局的基础之上构建，并创建用于执行批处理更新、 删除和插入的用户界面。</span><span class="sxs-lookup"><span data-stu-id="7d016-306">In the next three tutorials we will build upon the foundation laid in this tutorial and create user interfaces for performing batch updates, deletes, and inserts.</span></span>

<span data-ttu-id="7d016-307">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="7d016-307">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="7d016-308">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="7d016-308">Further Reading</span></span>

<span data-ttu-id="7d016-309">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="7d016-309">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="7d016-310">维护与事务的数据库一致性</span><span class="sxs-lookup"><span data-stu-id="7d016-310">Maintaining Database Consistency with Transactions</span></span>](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)
- [<span data-ttu-id="7d016-311">管理 SQL Server 中的事务存储过程</span><span class="sxs-lookup"><span data-stu-id="7d016-311">Managing Transactions in SQL Server Stored Procedures</span></span>](http://www.4guysfromrolla.com/webtech/080305-1.shtml)
- [<span data-ttu-id="7d016-312">事务变得更容易： `System.Transactions`</span><span class="sxs-lookup"><span data-stu-id="7d016-312">Transactions Made Easy: `System.Transactions`</span></span>](https://blogs.msdn.com/florinlazar/archive/2004/07/23/192239.aspx)
- [<span data-ttu-id="7d016-313">TransactionScope 和 Dataadapter</span><span class="sxs-lookup"><span data-stu-id="7d016-313">TransactionScope and DataAdapters</span></span>](http://andyclymer.blogspot.com/2007/01/transactionscope-and-dataadapters.html)
- [<span data-ttu-id="7d016-314">在.NET 中使用 Oracle 数据库事务</span><span class="sxs-lookup"><span data-stu-id="7d016-314">Using Oracle Database Transactions in .NET</span></span>](http://www.oracle.com/technology/pub/articles/price_dbtrans_dotnet.html)

## <a name="about-the-author"></a><span data-ttu-id="7d016-315">关于作者</span><span class="sxs-lookup"><span data-stu-id="7d016-315">About the Author</span></span>

<span data-ttu-id="7d016-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="7d016-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="7d016-317">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="7d016-317">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="7d016-318">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="7d016-318">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="7d016-319">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="7d016-319">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="7d016-320">特别感谢</span><span class="sxs-lookup"><span data-stu-id="7d016-320">Special Thanks To</span></span>

<span data-ttu-id="7d016-321">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="7d016-321">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="7d016-322">本教程中的前导审阅者已 Dave Gardner、 希尔顿 Giesenow 和 Teresa 墨。</span><span class="sxs-lookup"><span data-stu-id="7d016-322">Lead reviewers for this tutorial were Dave Gardner, Hilton Giesenow, and Teresa Murphy.</span></span> <span data-ttu-id="7d016-323">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="7d016-323">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="7d016-324">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="7d016-324">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="7d016-325">下一篇</span><span class="sxs-lookup"><span data-stu-id="7d016-325">Next</span></span>](batch-updating-cs.md)
