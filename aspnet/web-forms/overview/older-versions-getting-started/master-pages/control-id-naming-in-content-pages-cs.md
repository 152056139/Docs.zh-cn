---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
title: 控制在内容页 (C#) 中的 ID 命名 |Microsoft 文档
author: rick-anderson
description: 说明了如何 ContentPlaceHolder 控件充当命名容器并因此以编程方式使用控件 （通过 FindConrol) 困难...
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2008
ms.topic: article
ms.assetid: 1c7d0916-0988-4b4f-9a03-935e4b5af6af
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
msc.type: authoredcontent
ms.openlocfilehash: 1e834c38457c8477e0c81598d32f1e98473949d7
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2018
ms.locfileid: "30891342"
---
<a name="control-id-naming-in-content-pages-c"></a><span data-ttu-id="e4416-103">在内容页 (C#) 中命名的控件 ID</span><span class="sxs-lookup"><span data-stu-id="e4416-103">Control ID Naming in Content Pages (C#)</span></span>
====================
<span data-ttu-id="e4416-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e4416-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e4416-105">[下载代码](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip)或[下载 PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="e4416-105">[Download Code](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip) or [Download PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span></span>

> <span data-ttu-id="e4416-106">演示如何 ContentPlaceHolder 控件充当命名容器和因此请以编程方式使用控件 （通过 FindConrol) 困难。</span><span class="sxs-lookup"><span data-stu-id="e4416-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindConrol).</span></span> <span data-ttu-id="e4416-107">在此问题和解决方法如下所示。</span><span class="sxs-lookup"><span data-stu-id="e4416-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="e4416-108">此外讨论如何以编程方式访问生成的 ClientID 值。</span><span class="sxs-lookup"><span data-stu-id="e4416-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>


## <a name="introduction"></a><span data-ttu-id="e4416-109">介绍</span><span class="sxs-lookup"><span data-stu-id="e4416-109">Introduction</span></span>

<span data-ttu-id="e4416-110">所有 ASP.NET 服务器控件都包括`ID`属性，用于唯一标识该控件以及是依据此控件以编程方式访问中的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="e4416-111">同样，HTML 文档中的元素可能包括`id`唯一标识此元素的特性; 这些`id`值通常用于在客户端脚本中以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="e4416-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="e4416-112">鉴于此，您可能会假定的 ASP.NET 服务器控件呈现到 HTML 时其`ID`值用作`id`呈现的 HTML 元素的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="e4416-113">这不一定是这种情况因为在某些情况下一个控件替换为单个`ID`值可能在呈现标记中出现多次。</span><span class="sxs-lookup"><span data-stu-id="e4416-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="e4416-114">请考虑包括与标签 Web 控件与 TemplateField GridView 控件`ID`的产品名称的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of ProductName.</span></span> <span data-ttu-id="e4416-115">当 GridView 绑定到它在运行时的数据源时，此标签被重复一次为每个 GridView 行。</span><span class="sxs-lookup"><span data-stu-id="e4416-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="e4416-116">每个呈现标签需求唯一`id`值。</span><span class="sxs-lookup"><span data-stu-id="e4416-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="e4416-117">若要处理这种情况下，ASP.NET 允许某些控件表示为命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="e4416-118">命名容器将用作新`ID`命名空间。</span><span class="sxs-lookup"><span data-stu-id="e4416-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="e4416-119">出现在命名的容器内所有服务器控件都具有其呈现`id`value 前面带`ID`的命名的容器控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="e4416-120">例如，`GridView`和`GridViewRow`类都是命名的容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="e4416-121">因此，在与为 GridView TemplateField 中定义的标签控件`ID`ProductName 给定呈现`id`值`GridViewID_GridViewRowID_ProductName`。</span><span class="sxs-lookup"><span data-stu-id="e4416-121">Consequently, a Label control defined in a GridView TemplateField with `ID` ProductName is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="e4416-122">因为*GridViewRowID*是对于每个 GridView 一行，生成唯一`id`值是唯一的。</span><span class="sxs-lookup"><span data-stu-id="e4416-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="e4416-123">[ `INamingContainer`接口](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx)用于指示特定的 ASP.NET 服务器控件应该用作的命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="e4416-124">`INamingContainer`接口不拼写出任何服务器控件必须实现的方法; 相反，它可作为一个标记。</span><span class="sxs-lookup"><span data-stu-id="e4416-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="e4416-125">在生成的呈现的标记，如果某个控件实现此接口然后 ASP.NET 引擎自动前缀其`ID`值及其子代的呈现`id`属性值。</span><span class="sxs-lookup"><span data-stu-id="e4416-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="e4416-126">此过程将在步骤 2 中的更详细地讨论。</span><span class="sxs-lookup"><span data-stu-id="e4416-126">This process is discussed in more detail in Step 2.</span></span>


<span data-ttu-id="e4416-127">命名容器不只更改呈现`id`属性值，但也会影响如何控件可能会以编程方式引用从 ASP.NET 页的代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="e4416-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="e4416-128">`FindControl("controlID")`方法通常用于以编程方式引用 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="e4416-129">但是，`FindControl`不入侵通过命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="e4416-130">因此，不能直接使用`Page.FindControl`方法引用一个 GridView 或其他命名容器内的控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="e4416-131">如你可能具有 surmised，母版页和 ContentPlaceHolders 同时实现为命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="e4416-132">在本教程中，我们将查看如何主页面影响 HTML 元素`id`值和方法以编程方式引用在中内容页使用的 Web 控件`FindControl`。</span><span class="sxs-lookup"><span data-stu-id="e4416-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="e4416-133">步骤 1： 添加一个新的 ASP.NET 页</span><span class="sxs-lookup"><span data-stu-id="e4416-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="e4416-134">为了演示在本教程中所述的概念，让我们将新的 ASP.NET 页添加到我们的网站。</span><span class="sxs-lookup"><span data-stu-id="e4416-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="e4416-135">创建一个名为的新内容页`IDIssues.aspx`在根文件夹中，将其绑定到`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="e4416-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>


![将内容页 IDIssues.aspx 添加到根文件夹](control-id-naming-in-content-pages-cs/_static/image1.png)

<span data-ttu-id="e4416-137">**图 01**： 添加内容页`IDIssues.aspx`的根文件夹</span><span class="sxs-lookup"><span data-stu-id="e4416-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>


<span data-ttu-id="e4416-138">Visual Studio 自动为每个母版页的四个 ContentPlaceHolders 创建内容控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="e4416-139">中所述[*多个 ContentPlaceHolders 和默认内容*](multiple-contentplaceholders-and-default-content-cs.md)教程，如果内容控件不存在，而是发出主控页的默认 ContentPlaceHolder 内容。</span><span class="sxs-lookup"><span data-stu-id="e4416-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-cs.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="e4416-140">因为`QuickLoginUI`和`LeftColumnContent`ContentPlaceHolders 包含该页的合适的默认标记，请继续并删除其相应内容控件从`IDIssues.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e4416-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="e4416-141">此时，内容页的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="e4416-141">At this point, the content page's declarative markup should look like the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample1.aspx)]

<span data-ttu-id="e4416-142">在[*母版页中指定的标题、 Meta 标记和其他 HTML 标头*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md)教程中我们创建了一个自定义的基本页类 (`BasePage`)，如果它是自动配置页的标题未显式设置。</span><span class="sxs-lookup"><span data-stu-id="e4416-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="e4416-143">有关`IDIssues.aspx`页上使用此功能，该页面的代码隐藏类必须派生自`BasePage`类 (而不是`System.Web.UI.Page`)。</span><span class="sxs-lookup"><span data-stu-id="e4416-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="e4416-144">修改代码隐藏类的定义，使其类似以下所示：</span><span class="sxs-lookup"><span data-stu-id="e4416-144">Modify the code-behind class's definition so that it looks like the following:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample2.cs)]

<span data-ttu-id="e4416-145">最后，更新`Web.sitemap`文件以包含此新课适当的项。</span><span class="sxs-lookup"><span data-stu-id="e4416-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="e4416-146">添加`<siteMapNode>`元素，并设置其`title`和`url`特性以"控件 ID 命名问题"和`~/IDIssues.aspx`分别。</span><span class="sxs-lookup"><span data-stu-id="e4416-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="e4416-147">建立此添加后你`Web.sitemap`文件的标记的外观应与以下类似：</span><span class="sxs-lookup"><span data-stu-id="e4416-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>


[!code-xml[Main](control-id-naming-in-content-pages-cs/samples/sample3.xml)]

<span data-ttu-id="e4416-148">如图 2 所示，在新的站点映射条目`Web.sitemap`立即反映在左侧列中的课程部分。</span><span class="sxs-lookup"><span data-stu-id="e4416-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>


![课程部分现在包括一个指向&quot;控制命名问题的 ID&quot;](control-id-naming-in-content-pages-cs/_static/image2.png)

<span data-ttu-id="e4416-150">**图 02**： 课程部分现在包括"控件 ID 命名问题"的链接</span><span class="sxs-lookup"><span data-stu-id="e4416-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>


## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="e4416-151">第 2 步： 检查呈现`ID`更改</span><span class="sxs-lookup"><span data-stu-id="e4416-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="e4416-152">若要更好地了解修改 ASP.NET 向呈现引擎发出`id`的服务器的值控制，让我们添加到的几个 Web 控件`IDIssues.aspx`页面，然后查看发送到浏览器的呈现的标记。</span><span class="sxs-lookup"><span data-stu-id="e4416-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="e4416-153">具体而言，在文本中的类型"请输入你的年龄:"跟文本框中 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="e4416-154">进一步向下的页上添加按钮 Web 控件和标签 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="e4416-155">设置文本框的`ID`和`Columns`属性设置为`Age`和 3，分别。</span><span class="sxs-lookup"><span data-stu-id="e4416-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="e4416-156">设置按钮的`Text`和`ID`属性设置为"提交"和`SubmitButton`。</span><span class="sxs-lookup"><span data-stu-id="e4416-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="e4416-157">清理标签的`Text`属性并设置其`ID`到`Results`。</span><span class="sxs-lookup"><span data-stu-id="e4416-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="e4416-158">此时内容控件的声明性标记应类似以下：</span><span class="sxs-lookup"><span data-stu-id="e4416-158">At this point your Content control's declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample4.aspx)]

<span data-ttu-id="e4416-159">图 3 显示的页时查看通过 Visual Studio 设计器。</span><span class="sxs-lookup"><span data-stu-id="e4416-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>


<span data-ttu-id="e4416-160">[![该页面包括三个 Web 控件： 文本框、 按钮和标签](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="e4416-160">[![The Page Includes Three Web Controls: a TextBox, Button, and Label](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span></span>

<span data-ttu-id="e4416-161">**图 03**: 页面包括三个 Web 控件： 文本框、 按钮和标签 ([单击以查看实际尺寸的图像](control-id-naming-in-content-pages-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="e4416-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image5.png))</span></span>


<span data-ttu-id="e4416-162">访问通过浏览器页面，然后查看 HTML 源。</span><span class="sxs-lookup"><span data-stu-id="e4416-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="e4416-163">下面所示，标记为`id`文本框、 按钮和标签 Web 控件的 HTML 元素的有效值的组合`ID`的 Web 控件的值与`ID`页中的命名容器的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample5.html)]

<span data-ttu-id="e4416-164">本教程中前面所述，母版页和其 ContentPlaceHolders 用作命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="e4416-165">因此，同时参与呈现`ID`其嵌套的控件的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="e4416-166">需要文本框的`id`特性，例如： `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="e4416-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="e4416-167">回想一下，TextBox 控件`ID`值`Age`。</span><span class="sxs-lookup"><span data-stu-id="e4416-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="e4416-168">这其 ContentPlaceHolder 控件使用的前缀`ID`值， `MainContent`。</span><span class="sxs-lookup"><span data-stu-id="e4416-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="e4416-169">此外，此值的前面带母版页的`ID`值， `ctl00`。</span><span class="sxs-lookup"><span data-stu-id="e4416-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="e4416-170">净效果是`id`组成的属性值`ID`主控页、 ContentPlaceHolder 控件和文本框本身的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="e4416-171">图 4 显示了此行为。</span><span class="sxs-lookup"><span data-stu-id="e4416-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="e4416-172">若要确定呈现`id`的`Age`文本框中，使用启动`ID`文本框控件中，值`Age`。</span><span class="sxs-lookup"><span data-stu-id="e4416-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="e4416-173">接下来，工作沿控制层次结构。</span><span class="sxs-lookup"><span data-stu-id="e4416-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="e4416-174">在每个命名容器 （具有桃色颜色的节点），前缀呈现当前`id`与命名容器`id`。</span><span class="sxs-lookup"><span data-stu-id="e4416-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>


![Rendered id 属性是基于上 ID 值的命名容器](control-id-naming-in-content-pages-cs/_static/image6.png)

<span data-ttu-id="e4416-176">**图 04**: 呈现`id`特性都是基于`ID`的命名容器的值</span><span class="sxs-lookup"><span data-stu-id="e4416-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>


> [!NOTE]
> <span data-ttu-id="e4416-177">如我们所述，`ctl00`部分呈现`id`属性构成`ID`值的主页上，但你可能想知道如何将此`ID`在于生成的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="e4416-178">我们未指定其任何位置中我们 master 或内容的页面。</span><span class="sxs-lookup"><span data-stu-id="e4416-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="e4416-179">页面的声明性标记通过显式添加 ASP.NET 页中的大多数服务器控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="e4416-180">`MainContent` ContentPlaceHolder 控件的标记中显式指定`Site.master`;`Age`文本框中已定义`IDIssues.aspx`的标记。</span><span class="sxs-lookup"><span data-stu-id="e4416-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="e4416-181">我们可以指定`ID`控件通过属性窗口，或从声明性语法，这些类型的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="e4416-182">其他控件，如即母版页本身，未定义的声明性标记。</span><span class="sxs-lookup"><span data-stu-id="e4416-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="e4416-183">因此，其`ID`值必须为我们自动生成。</span><span class="sxs-lookup"><span data-stu-id="e4416-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="e4416-184">ASP.NET 引擎集`ID`在其 Id 具有未显式设置这些控件的运行时的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="e4416-185">它使用的命名模式`ctlXX`，其中*XX*是按顺序递增的整数值。</span><span class="sxs-lookup"><span data-stu-id="e4416-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>


<span data-ttu-id="e4416-186">主页面上本身充当作为命名的容器，因为在母版页中定义的 Web 控件还具有更改呈现`id`属性值。</span><span class="sxs-lookup"><span data-stu-id="e4416-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="e4416-187">例如，`DisplayDate`我们将添加到母版页中的标签[*母版页中使用创建站点范围布局*](creating-a-site-wide-layout-using-master-pages-cs.md)教程具有以下呈现标记：</span><span class="sxs-lookup"><span data-stu-id="e4416-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md) tutorial has the following rendered markup:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample6.html)]

<span data-ttu-id="e4416-188">请注意，`id`属性包括这两个母版页的`ID`值 (`ctl00`) 和`ID`标签 Web 控件的值 (`DateDisplay`)。</span><span class="sxs-lookup"><span data-stu-id="e4416-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="e4416-189">步骤 3： 以编程方式引用通过 Web 控件`FindControl`</span><span class="sxs-lookup"><span data-stu-id="e4416-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="e4416-190">每个 ASP.NET 服务器控件包含`FindControl("controlID")`搜索名为的控件的控件的后代方法*controlID*。</span><span class="sxs-lookup"><span data-stu-id="e4416-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="e4416-191">如果找到这样的控件，则返回;如果不找到任何匹配的控件，则`FindControl`返回`null`。</span><span class="sxs-lookup"><span data-stu-id="e4416-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `null`.</span></span>

<span data-ttu-id="e4416-192">`FindControl` 在其中你需要访问的控件，但不会获得对它的直接引用的方案很有用。</span><span class="sxs-lookup"><span data-stu-id="e4416-192">`FindControl` is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="e4416-193">使用 Web 控件，例如 GridView，例如，数据时在 GridView 的字段控件中定义了一次的声明性语法，但是在运行时控件的实例创建的每个 GridView 行。</span><span class="sxs-lookup"><span data-stu-id="e4416-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="e4416-194">因此，在运行时生成的控件存在，但我们不提供可从代码隐藏类的直接引用。</span><span class="sxs-lookup"><span data-stu-id="e4416-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="e4416-195">因此我们需要使用`FindControl`以编程方式使用特定控件在 GridView 的字段。</span><span class="sxs-lookup"><span data-stu-id="e4416-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="e4416-196">(有关详细信息使用`FindControl`若要访问的数据 Web 控件模板中的控件，请参阅[自定义格式设置基于时数据](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md)。)这同一情况下发生时动态地将 Web 控件添加到 Web 窗体，则主题所述[创建动态数据条目的用户界面](https://msdn.microsoft.com/library/aa479330.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e4416-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="e4416-197">若要演示如何使用`FindControl`方法搜索控件在内容页中，创建的事件处理程序`SubmitButton`的`Click`事件。</span><span class="sxs-lookup"><span data-stu-id="e4416-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="e4416-198">事件处理程序中，添加以下代码，即在以编程方式引用`Age`文本框中和`Results`标签使用`FindControl`方法，然后显示一条消息采用`Results`根据用户的输入。</span><span class="sxs-lookup"><span data-stu-id="e4416-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="e4416-199">当然，我们不需要使用`FindControl`以引用此示例中的标签和文本框控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="e4416-200">我们无法引用它们直接通过其`ID`属性值。</span><span class="sxs-lookup"><span data-stu-id="e4416-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="e4416-201">我使用`FindControl`此处为了说明使用时，会发生什么情况`FindControl`从内容页。</span><span class="sxs-lookup"><span data-stu-id="e4416-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample7.cs)]

<span data-ttu-id="e4416-202">尽管用于调用的语法`FindControl`方法略有不同的前两个行中`SubmitButton_Click`，它们在语义上等效。</span><span class="sxs-lookup"><span data-stu-id="e4416-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="e4416-203">回想一下，所有 ASP.NET 服务器控件都包括`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="e4416-204">这包括`Page`从哪些所有 ASP.NET 代码隐藏类必须派生自的类。</span><span class="sxs-lookup"><span data-stu-id="e4416-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="e4416-205">因此，调用`FindControl("controlID")`等效于调用`Page.FindControl("controlID")`，假定你尚未重写`FindControl`方法在你的代码隐藏类或中的自定义的基类。</span><span class="sxs-lookup"><span data-stu-id="e4416-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="e4416-206">在输入此代码，请访问`IDIssues.aspx`通过浏览器页上，输入你的年龄，然后单击"提交"按钮。</span><span class="sxs-lookup"><span data-stu-id="e4416-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="e4416-207">单击"提交"按钮时`NullReferenceException`引发 （请参见图 5）。</span><span class="sxs-lookup"><span data-stu-id="e4416-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>


<span data-ttu-id="e4416-208">[![引发 NullReferenceException](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="e4416-208">[![A NullReferenceException is Raised](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span></span>

<span data-ttu-id="e4416-209">**图 05**: A`NullReferenceException`引发 ([单击以查看实际尺寸的图像](control-id-naming-in-content-pages-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="e4416-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image9.png))</span></span>


<span data-ttu-id="e4416-210">如果在中设置断点`SubmitButton_Click`事件处理程序，你将看到同时调用`FindControl`返回`null`值。</span><span class="sxs-lookup"><span data-stu-id="e4416-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return a `null` value.</span></span> <span data-ttu-id="e4416-211">`NullReferenceException`我们尝试访问时，将引发`Age`文本框的`Text`属性。</span><span class="sxs-lookup"><span data-stu-id="e4416-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="e4416-212">问题在于`Control.FindControl`仅搜索*控件*的后代的*相同的命名容器中*。</span><span class="sxs-lookup"><span data-stu-id="e4416-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are *in the same naming container*.</span></span> <span data-ttu-id="e4416-213">因为主控页构成一个新的命名容器，调用`Page.FindControl("controlID")`永远不会 permeates 母版页对象`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="e4416-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="e4416-214">(图 4，若要查看控件层次结构，其中显示了将回指`Page`对象作为母版页对象的父级`ctl00`。)因此，`Results`标签和`Age`找不到文本框中和`ResultsLabel`和`AgeTextBox`为其赋值的`null`。</span><span class="sxs-lookup"><span data-stu-id="e4416-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `null`.</span></span>

<span data-ttu-id="e4416-215">有两个对此质询的解决方法： 我们可以向下钻取，一个命名的容器，到相应的控件; 次或者我们可以创建我们自己`FindControl`permeates 命名容器的方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="e4416-216">让我们检验其中每个选项。</span><span class="sxs-lookup"><span data-stu-id="e4416-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="e4416-217">钻取到相应的命名容器</span><span class="sxs-lookup"><span data-stu-id="e4416-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="e4416-218">若要使用`FindControl`引用`Results`标签或`Age`文本框中，我们需要先调用`FindControl`从相同的命名容器中的一个上级控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="e4416-219">如图 4 显示， `MainContent` ContentPlaceHolder 控件是唯一的祖先`Results`或`Age`，位于相同的命名容器内。</span><span class="sxs-lookup"><span data-stu-id="e4416-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="e4416-220">换而言之，调用`FindControl`方法从`MainContent`控件，如下面的代码段中所示正确返回的引用`Results`或`Age`控件。</span><span class="sxs-lookup"><span data-stu-id="e4416-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample8.cs)]

<span data-ttu-id="e4416-221">但是，我们无法使用`MainContent`ContentPlaceHolder 从使用上面的语法，因为在母版页中定义 ContentPlaceHolder 我们内容页的代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="e4416-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="e4416-222">相反，我们必须使用`FindControl`获取对引用`MainContent`。</span><span class="sxs-lookup"><span data-stu-id="e4416-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="e4416-223">中的代码替换`SubmitButton_Click`事件处理程序替换以下修改之处：</span><span class="sxs-lookup"><span data-stu-id="e4416-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample9.cs)]

<span data-ttu-id="e4416-224">如果你访问通过浏览器页面，输入你的年龄，然后单击"提交"按钮，`NullReferenceException`引发。</span><span class="sxs-lookup"><span data-stu-id="e4416-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="e4416-225">如果在中设置断点`SubmitButton_Click`你将看到尝试调用时，会发生此异常的事件处理程序`MainContent`对象的`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="e4416-226">`MainContent`对象是`null`因为`FindControl`方法找不到名为"主内容"的对象。</span><span class="sxs-lookup"><span data-stu-id="e4416-226">The `MainContent` object is `null` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="e4416-227">基础的原因是与相同`Results`标签和`Age`TextBox 控件：`FindControl`从控件层次结构的顶部启动其搜索，并且不入侵命名容器，但`MainContent`ContentPlaceHolder 是在主页上，这是命名的容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="e4416-228">我们可以使用之前`FindControl`获取对引用`MainContent`，我们首先需要对母版页控件的引用。</span><span class="sxs-lookup"><span data-stu-id="e4416-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="e4416-229">一旦我们有了对主控页的引用我们可以获取对引用`MainContent`通过 ContentPlaceHolder`FindControl`并据此，引用`Results`标签和`Age`文本框中 (同样，通过使用`FindControl`)。</span><span class="sxs-lookup"><span data-stu-id="e4416-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="e4416-230">但是，我们如何获取对主控页的引用？</span><span class="sxs-lookup"><span data-stu-id="e4416-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="e4416-231">通过检查`id`中呈现的标记的属性很显然，母版页的`ID`值是`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="e4416-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="e4416-232">因此，我们可以使用`Page.FindControl("ctl00")`若要获取对主控页的引用，然后使用该对象获取对引用`MainContent`，依次类推。</span><span class="sxs-lookup"><span data-stu-id="e4416-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="e4416-233">下面的代码段说明了此逻辑：</span><span class="sxs-lookup"><span data-stu-id="e4416-233">The following snippet illustrates this logic:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample10.cs)]

<span data-ttu-id="e4416-234">尽管此代码当然也可以生效，它假定母版页的自动生成`ID`将始终为`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="e4416-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="e4416-235">很难做出有关自动生成值的假设一个好办法。</span><span class="sxs-lookup"><span data-stu-id="e4416-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="e4416-236">幸运的是，对主控页的引用是可通过访问`Page`类的`Master`属性。</span><span class="sxs-lookup"><span data-stu-id="e4416-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="e4416-237">因此，而不必使用`FindControl("ctl00")`来获取主控页的引用，以便访问`MainContent`ContentPlaceHolder，我们可以改用`Page.Master.FindControl("MainContent")`。</span><span class="sxs-lookup"><span data-stu-id="e4416-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="e4416-238">更新`SubmitButton_Click`事件处理程序替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="e4416-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample11.cs)]

<span data-ttu-id="e4416-239">此时，访问该网页通过浏览器中，输入你的年龄，并单击"提交"按钮显示中的消息`Results`标签，按预期方式。</span><span class="sxs-lookup"><span data-stu-id="e4416-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>


<span data-ttu-id="e4416-240">[![标签中显示用户的年龄](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="e4416-240">[![The User's Age is Displayed in the Label](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span></span>

<span data-ttu-id="e4416-241">**图 06**： 标签中显示的用户的年龄 ([单击以查看实际尺寸的图像](control-id-naming-in-content-pages-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="e4416-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image12.png))</span></span>


### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="e4416-242">以递归方式搜索命名容器</span><span class="sxs-lookup"><span data-stu-id="e4416-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="e4416-243">原因引用前面的代码示例`MainContent`ContentPlaceHolder 控件从主页上，然后`Results`标签和`Age`文本框控件从`MainContent`，是因为`Control.FindControl`方法仅搜索在*控件*的命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="e4416-244">具有`FindControl`命名容器中的保持在大多数情况下有必要，因为两个不同的命名容器中的两个控件可能具有相同`ID`值。</span><span class="sxs-lookup"><span data-stu-id="e4416-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="e4416-245">请考虑一个 GridView，定义一个名为的标签 Web 控件的大小写`ProductName`在其 TemplateFields 之一中。</span><span class="sxs-lookup"><span data-stu-id="e4416-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="e4416-246">当将数据绑定到在运行时，GridView`ProductName`会为每个 GridView 行创建标签。</span><span class="sxs-lookup"><span data-stu-id="e4416-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="e4416-247">如果`FindControl`搜索通过所有命名容器，我们调用`Page.FindControl("ProductName")`，哪些标签实例应`FindControl`返回？</span><span class="sxs-lookup"><span data-stu-id="e4416-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="e4416-248">`ProductName`中第一个 GridView 行标签？</span><span class="sxs-lookup"><span data-stu-id="e4416-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="e4416-249">中的最后一行的一个？</span><span class="sxs-lookup"><span data-stu-id="e4416-249">The one in the last row?</span></span>

<span data-ttu-id="e4416-250">因此具有`Control.FindControl`只搜索*控件*的命名容器有意义在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e4416-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="e4416-251">但有其他情况下，如面向我们，我们具有一个唯一的那个`ID`所有命名容器，并且想要避免必须认真引用控件层次结构访问的控件中每个命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="e4416-252">具有`FindControl`以递归方式搜索所有命名容器使好的效果，太的变体。</span><span class="sxs-lookup"><span data-stu-id="e4416-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="e4416-253">遗憾的是，.NET Framework 不包括这样的方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="e4416-254">好消息是，我们可以创建我们自己`FindControl`方法，以递归方式搜索所有命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="e4416-255">事实上，使用*扩展方法*我们可以添加`FindControlRecursive`方法`Control`类随附其现有`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="e4416-256">扩展方法是对 C# 3.0 和 Visual Basic 9 附带的.NET Framework 版本 3.5 和 Visual Studio 2008 语言新功能。</span><span class="sxs-lookup"><span data-stu-id="e4416-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="e4416-257">简单地说，扩展方法允许开发人员可以创建一个特殊的语法通过现有的类类型的新方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="e4416-258">有关此非常有用的功能的详细信息，请参阅我文章，[的扩展方法扩展基类型的功能](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e4416-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>


<span data-ttu-id="e4416-259">若要创建扩展方法，添加新的文件与`App_Code`文件夹名为`PageExtensionMethods.cs`。</span><span class="sxs-lookup"><span data-stu-id="e4416-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.cs`.</span></span> <span data-ttu-id="e4416-260">添加名为的扩展方法`FindControlRecursive`作为输入采用`string`参数名为`controlID`。</span><span class="sxs-lookup"><span data-stu-id="e4416-260">Add an extension method named `FindControlRecursive` that takes as an input a `string` parameter named `controlID`.</span></span> <span data-ttu-id="e4416-261">若要正常工作的扩展方法，这至关重要类本身和其扩展方法来标记`static`。</span><span class="sxs-lookup"><span data-stu-id="e4416-261">For extension methods to work properly, it is vital that the class itself and its extension methods be marked `static`.</span></span> <span data-ttu-id="e4416-262">此外，必须接受所有扩展方法，如它们的扩展方法适用的类型的对象的第一个参数和此输入的参数必须前面带有关键字`this`。</span><span class="sxs-lookup"><span data-stu-id="e4416-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies, and this input parameter must be preceded with the keyword `this`.</span></span>

<span data-ttu-id="e4416-263">以下代码添加到`PageExtensionMethods.cs`类文件以定义此类与`FindControlRecursive`扩展方法：</span><span class="sxs-lookup"><span data-stu-id="e4416-263">Add the following code to the `PageExtensionMethods.cs` class file to define this class and the `FindControlRecursive` extension method:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample12.cs)]

<span data-ttu-id="e4416-264">此代码中的位置，返回到`IDIssues.aspx`页的代码隐藏类并注释掉当前`FindControl`方法调用。</span><span class="sxs-lookup"><span data-stu-id="e4416-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="e4416-265">将它们替换为对调用`Page.FindControlRecursive("controlID")`。</span><span class="sxs-lookup"><span data-stu-id="e4416-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="e4416-266">关于扩展方法是，它们显示直接内的 IntelliSense 下拉列表。</span><span class="sxs-lookup"><span data-stu-id="e4416-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="e4416-267">如图 7 所示，当你键入页，然后点击期间， `FindControlRecursive` IntelliSense 以及其他的下拉列表中包含方法`Control`类方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-267">As Figure 7 shows, when you type Page and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>


<span data-ttu-id="e4416-268">[![在 IntelliSense 下拉列表包含扩展方法](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="e4416-268">[![Extension Methods are Included in the IntelliSense Drop-Downs](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span></span>

<span data-ttu-id="e4416-269">**图 07**： 在 IntelliSense 下拉列表包含扩展方法 ([单击以查看实际尺寸的图像](control-id-naming-in-content-pages-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="e4416-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image15.png))</span></span>


<span data-ttu-id="e4416-270">输入下面的代码插入`SubmitButton_Click`事件处理程序，然后通过访问的页面，输入你的年龄，然后单击"提交"按钮对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="e4416-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="e4416-271">返回在图 6 中所示，则生成的输出将为消息，"就年龄岁 ！"</span><span class="sxs-lookup"><span data-stu-id="e4416-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample13.cs)]

> [!NOTE]
> <span data-ttu-id="e4416-272">由于扩展方法不熟悉 C# 3.0 和 Visual Basic 9，如果你使用的 Visual Studio 2005 无法使用扩展方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="e4416-273">相反，你将需要实现`FindControlRecursive`的帮助器类方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="e4416-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx)在他的博客文章，具有这样一个示例[ASP.NET 微波激射器页和`FindControl` ](http://www.west-wind.com/WebLog/posts/5127.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e4416-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>


## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="e4416-275">步骤 4： 使用正确`id`属性在客户端脚本中的值</span><span class="sxs-lookup"><span data-stu-id="e4416-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="e4416-276">本教程的简介中所述，Web 控件的呈现`id`属性通常用于在客户端脚本中以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="e4416-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="e4416-277">例如，以下 JavaScript 引用 HTML 元素由其`id`然后模式的消息框中显示其值：</span><span class="sxs-lookup"><span data-stu-id="e4416-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample14.cs)]

<span data-ttu-id="e4416-278">回想一下，在 ASP.NET 页，不包括命名容器，呈现的 HTML 元素的`id`属性等同于 Web 控件的`ID`属性值。</span><span class="sxs-lookup"><span data-stu-id="e4416-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="e4416-279">因此，很容易让人想到中的硬编码到`id`到 JavaScript 代码的属性值。</span><span class="sxs-lookup"><span data-stu-id="e4416-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="e4416-280">也就是说，如果你知道你想要访问`Age`文本框中 Web 控制通过客户端脚本，这样通过调用`document.getElementById("Age")`。</span><span class="sxs-lookup"><span data-stu-id="e4416-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="e4416-281">此方法的问题是，如果使用母版页 （或其他命名的容器控件），呈现的 HTML`id`不是同义词，Web 控件在`ID`属性。</span><span class="sxs-lookup"><span data-stu-id="e4416-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="e4416-282">第一个倾角可能访问通过浏览器页并查看源代码来确定实际`id`属性。</span><span class="sxs-lookup"><span data-stu-id="e4416-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="e4416-283">一旦你了解了呈现`id`值，你可以将其粘贴到调用`getElementById`访问需要客户端脚本通过使用 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="e4416-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="e4416-284">这种方法是不理想，因为该页面的某些更改控制层次结构或更改为`ID`命名控件的属性将 alter 生成`id`属性，就突破 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="e4416-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="e4416-285">好消息是`id`呈现的属性值是可在通过 Web 控件的服务器端代码中访问[`ClientID`属性](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e4416-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="e4416-286">你应使用此属性确定`id`属性在客户端脚本中使用的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="e4416-287">例如，若要添加到页面的 JavaScript 函数，当调用时，显示的值`Age`模式在消息框中的文本框中添加以下代码到`Page_Load`事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="e4416-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>


[!code-javascript[Main](control-id-naming-in-content-pages-cs/samples/sample15.js)]

<span data-ttu-id="e4416-288">上面的代码插入的值`Age`文本框的 ClientID 属性转换为的 JavaScript 调用成`getElementById`。</span><span class="sxs-lookup"><span data-stu-id="e4416-288">The above code injects the value of the `Age` TextBox's ClientID property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="e4416-289">如果您访问此页面，通过浏览器并查看 HTML 源，你将找到以下 JavaScript 代码：</span><span class="sxs-lookup"><span data-stu-id="e4416-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample16.html)]

<span data-ttu-id="e4416-290">请注意如何正确`id`属性值， `ctl00_MainContent_Age`，对的调用中将显示`getElementById`。</span><span class="sxs-lookup"><span data-stu-id="e4416-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="e4416-291">因为此值在运行时计算的所以它适用无论页面控件层次结构的更高版本更改。</span><span class="sxs-lookup"><span data-stu-id="e4416-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="e4416-292">此 JavaScript 示例只是演示如何添加正确引用呈现服务器控件的 HTML 元素的 JavaScript 函数。</span><span class="sxs-lookup"><span data-stu-id="e4416-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="e4416-293">若要使用此函数将需要创作其他 JavaScript 加载文档时或在某些特定用户执行任何操作调查时调用该函数。</span><span class="sxs-lookup"><span data-stu-id="e4416-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="e4416-294">有关这些详细信息和相关的主题，阅读[使用客户端脚本](https://msdn.microsoft.com/library/aa479302.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e4416-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>


## <a name="summary"></a><span data-ttu-id="e4416-295">总结</span><span class="sxs-lookup"><span data-stu-id="e4416-295">Summary</span></span>

<span data-ttu-id="e4416-296">某些 ASP.NET 服务器控件充当命名容器，这会影响呈现`id`属性及其子代控件值以及通过 canvassed 的控件的作用域`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="e4416-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="e4416-297">关于主页面，即母版页本身和其 ContentPlaceHolder 控件命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="e4416-298">因此，我们需要将放规定多做一些工作以编程方式引用内内容页使用的控件`FindControl`。</span><span class="sxs-lookup"><span data-stu-id="e4416-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="e4416-299">在本教程中，我们探讨了两种方法： 钻入 ContentPlaceHolder 控制和调用其`FindControl`方法; 和滚动我们自己`FindControl`实现该以递归方式搜索通过所有的命名容器。</span><span class="sxs-lookup"><span data-stu-id="e4416-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="e4416-300">除了命名容器引入与引用 Web 控件有关的服务器端问题，还有一些客户端问题。</span><span class="sxs-lookup"><span data-stu-id="e4416-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="e4416-301">没有命名容器，Web 控件`ID`属性值和呈现`id`属性值都是一个在同一个。</span><span class="sxs-lookup"><span data-stu-id="e4416-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="e4416-302">但命名的容器，呈现增加`id`属性同时包含`ID`的 Web 控件和在其控件层次结构的祖先命名容器的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="e4416-303">只要你使用 Web 控件的这些命名的内容不在非问题`ClientID`属性来确定呈现`id`属性在客户端脚本中的值。</span><span class="sxs-lookup"><span data-stu-id="e4416-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="e4416-304">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="e4416-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="e4416-305">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="e4416-305">Further Reading</span></span>

<span data-ttu-id="e4416-306">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="e4416-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="e4416-307">ASP.NET 母版页和 `FindControl`</span><span class="sxs-lookup"><span data-stu-id="e4416-307">ASP.NET Master Pages and `FindControl`</span></span>](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="e4416-308">创建动态数据条目的用户界面</span><span class="sxs-lookup"><span data-stu-id="e4416-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="e4416-309">扩展的扩展方法的基类型功能</span><span class="sxs-lookup"><span data-stu-id="e4416-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="e4416-310">如何： 引用 ASP.NET 母版页页内容</span><span class="sxs-lookup"><span data-stu-id="e4416-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="e4416-311">母版页页： 提示、 技巧和陷阱</span><span class="sxs-lookup"><span data-stu-id="e4416-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="e4416-312">使用客户端脚本</span><span class="sxs-lookup"><span data-stu-id="e4416-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="e4416-313">关于作者</span><span class="sxs-lookup"><span data-stu-id="e4416-313">About the Author</span></span>

<span data-ttu-id="e4416-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的多个 ASP/ASP.NET 丛书和 4GuysFromRolla.com 创始人，具有已使用 Microsoft Web 技术自 1998 年。</span><span class="sxs-lookup"><span data-stu-id="e4416-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e4416-315">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="e4416-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e4416-316">最新书籍是[ *Sam 教授自己 ASP.NET 3.5 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="e4416-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="e4416-317">可以在达到 Scott [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)或通过在其博客地址[ http://ScottOnWriting.NET ](http://scottonwriting.net/)。</span><span class="sxs-lookup"><span data-stu-id="e4416-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="e4416-318">特别感谢</span><span class="sxs-lookup"><span data-stu-id="e4416-318">Special Thanks To</span></span>

<span data-ttu-id="e4416-319">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="e4416-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="e4416-320">本教程中的前导审阅者已 Zack Jones 和 Suchi Barnerjee。</span><span class="sxs-lookup"><span data-stu-id="e4416-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="e4416-321">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="e4416-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="e4416-322">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)。</span><span class="sxs-lookup"><span data-stu-id="e4416-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="e4416-323">[上一页](urls-in-master-pages-cs.md)
> [下一页](interacting-with-the-master-page-from-the-content-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="e4416-323">[Previous](urls-in-master-pages-cs.md)
[Next](interacting-with-the-master-page-from-the-content-page-cs.md)</span></span>
