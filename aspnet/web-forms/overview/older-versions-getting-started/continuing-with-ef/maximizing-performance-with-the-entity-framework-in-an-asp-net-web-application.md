---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
title: 最大程度地使用实体框架 4.0 ASP.NET 4 Web 应用程序中的性能 |Microsoft 文档
author: tdykstra
description: 本教程系列上的 Contoso 大学 web 应用程序创建的 Getting Started with 实体 Framework 4.0 教程系列生成。 I...
ms.author: aspnetcontent
manager: wpickett
ms.date: 01/26/2011
ms.topic: article
ms.assetid: 4e43455e-dfa1-42db-83cb-c987703f04b5
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: b85645eebf2822b33df944692736ea9d9b69b9aa
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2018
---
<a name="maximizing-performance-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a><span data-ttu-id="dbf4f-104">最大程度地使用实体框架 4.0 ASP.NET 4 Web 应用程序中的性能</span><span class="sxs-lookup"><span data-stu-id="dbf4f-104">Maximizing Performance with the Entity Framework 4.0 in an ASP.NET 4 Web Application</span></span>
====================
<span data-ttu-id="dbf4f-105">通过[Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-105">by [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="dbf4f-106">本教程系列上的 Contoso 大学 web 应用程序创建的生成[Getting Started with 实体 Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started)教程系列。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-106">This tutorial series builds on the Contoso University web application that is created by the [Getting Started with the Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) tutorial series.</span></span> <span data-ttu-id="dbf4f-107">如果未完成前面的教程，作为一个起始点本教程，你可以[下载应用程序](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a)，你应已创建。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-107">If you didn't complete the earlier tutorials, as a starting point for this tutorial you can [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) that you would have created.</span></span> <span data-ttu-id="dbf4f-108">你还可以[下载应用程序](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa)，它由完整教程系列创建。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-108">You can also [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) that is created by the complete tutorial series.</span></span> <span data-ttu-id="dbf4f-109">如果你有疑问的教程，你可以发布到[ASP.NET 实体框架论坛](https://forums.asp.net/1227.aspx)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-109">If you have questions about the tutorials, you can post them to the [ASP.NET Entity Framework forum](https://forums.asp.net/1227.aspx).</span></span>


<span data-ttu-id="dbf4f-110">在前面的教程，您将了解如何处理并发冲突。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-110">In the previous tutorial, you saw how to handle concurrency conflicts.</span></span> <span data-ttu-id="dbf4f-111">本教程演示了用于改进性能的 ASP.NET web 应用程序使用实体框架的选项。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-111">This tutorial shows options for improving the performance of an ASP.NET web application that uses the Entity Framework.</span></span> <span data-ttu-id="dbf4f-112">你将了解几种方法最大化性能或诊断性能问题。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-112">You'll learn several methods for maximizing performance or for diagnosing performance problems.</span></span>

<span data-ttu-id="dbf4f-113">显示在以下部分中的信息可在各种方案中很有用：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-113">Information presented in the following sections is likely to be useful in a broad variety of scenarios:</span></span>

- <span data-ttu-id="dbf4f-114">有效地加载相关的数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-114">Efficiently load related data.</span></span>
- <span data-ttu-id="dbf4f-115">管理视图状态。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-115">Manage view state.</span></span>

<span data-ttu-id="dbf4f-116">显示在以下部分中的信息可能非常有用如果单个查询该存在性能问题：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-116">Information presented in the following sections might be useful if you have individual queries that present performance problems:</span></span>

- <span data-ttu-id="dbf4f-117">使用`NoTracking`合并选项。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-117">Use the `NoTracking` merge option.</span></span>
- <span data-ttu-id="dbf4f-118">预编译的 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-118">Pre-compile LINQ queries.</span></span>
- <span data-ttu-id="dbf4f-119">检查查询命令发送到数据库。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-119">Examine query commands sent to the database.</span></span>

<span data-ttu-id="dbf4f-120">以下部分中显示的信息是可能适用于应用程序具有过大的数据模型：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-120">Information presented in the following section is potentially useful for applications that have extremely large data models:</span></span>

- <span data-ttu-id="dbf4f-121">预生成视图。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-121">Pre-generate views.</span></span>

> [!NOTE]
> <span data-ttu-id="dbf4f-122">Web 应用程序性能受许多因素，包括如请求和响应数据的大小、 数据库查询、 多少个请求服务器可以排入队列和如何快速它就可以处理它们，并甚至任一提高效率的速度你可能正在使用的客户端脚本库。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-122">Web application performance is affected by many factors, including things like the size of request and response data, the speed of database queries, how many requests the server can queue and how quickly it can service them, and even the efficiency of any client-script libraries you might be using.</span></span> <span data-ttu-id="dbf4f-123">如果性能非常重要中你的应用程序，或如果测试或体验显示，应用程序性能并不令人满意时，应遵循有关性能调整正常协议。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-123">If performance is critical in your application, or if testing or experience shows that application performance isn't satisfactory, you should follow normal protocol for performance tuning.</span></span> <span data-ttu-id="dbf4f-124">度量值来确定性能瓶颈的发生位置，然后解决将对应用程序总体性能的影响最大的区域。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-124">Measure to determine where performance bottlenecks are occurring, and then address the areas that will have the greatest impact on overall application performance.</span></span>
> 
> <span data-ttu-id="dbf4f-125">本主题主要侧重于在其中可以潜在地提高 ASP.NET 中的实体框架专门的性能的方式。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-125">This topic focuses mainly on ways in which you can potentially improve the performance specifically of the Entity Framework in ASP.NET.</span></span> <span data-ttu-id="dbf4f-126">建议此处非常有用，如果您确定数据访问不在你的应用程序的性能瓶颈之一。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-126">The suggestions here are useful if you determine that data access is one of the performance bottlenecks in your application.</span></span> <span data-ttu-id="dbf4f-127">但如前所述，此处所述的方法不应视为&quot;最佳实践&quot;通常-其中的许多应该仅在异常的情况下或地址非常特定的一种性能瓶颈。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-127">Except as noted, the methods explained here shouldn't be considered &quot;best practices&quot; in general — many of them are appropriate only in exceptional situations or to address very specific kinds of performance bottlenecks.</span></span>


<span data-ttu-id="dbf4f-128">若要开始本教程，请启动 Visual Studio 并打开与你共事中以前的教程，Contoso 大学 web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-128">To start the tutorial, start Visual Studio and open the Contoso University web application that you were working with in the previous tutorial.</span></span>

## <a name="efficiently-loading-related-data"></a><span data-ttu-id="dbf4f-129">有效地加载相关的数据</span><span class="sxs-lookup"><span data-stu-id="dbf4f-129">Efficiently Loading Related Data</span></span>

<span data-ttu-id="dbf4f-130">有多种实体框架可以加载到实体的导航属性的相关的数据：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-130">There are several ways that the Entity Framework can load related data into the navigation properties of an entity:</span></span>

- <span data-ttu-id="dbf4f-131">*延迟加载*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-131">*Lazy loading*.</span></span> <span data-ttu-id="dbf4f-132">第一次读取实体时，不检索相关数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-132">When the entity is first read, related data isn't retrieved.</span></span> <span data-ttu-id="dbf4f-133">但是，第一次尝试访问导航属性时，将自动检索该导航属性所需的数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-133">However, the first time you attempt to access a navigation property, the data required for that navigation property is automatically retrieved.</span></span> <span data-ttu-id="dbf4f-134">这会导致发送到数据库的多个查询 — 一个用于在实体自身，一个必须检索每个相关实体的数据的时间。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-134">This results in multiple queries sent to the database — one for the entity itself and one each time that related data for the entity must be retrieved.</span></span> 

    <span data-ttu-id="dbf4f-135">[![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-135">[![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span></span>

<span data-ttu-id="dbf4f-136">*预先加载*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-136">*Eager loading*.</span></span> <span data-ttu-id="dbf4f-137">读取实体时，会检索与之相关的数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-137">When the entity is read, related data is retrieved along with it.</span></span> <span data-ttu-id="dbf4f-138">这通常会导致执行一个检索所有必需数据的联接查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-138">This typically results in a single join query that retrieves all of the data that's needed.</span></span> <span data-ttu-id="dbf4f-139">使用指定预先加载`Include`方法，当你已看到这些教程中。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-139">You specify eager loading by using the `Include` method, as you've seen already in these tutorials.</span></span>

<span data-ttu-id="dbf4f-140">[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-140">[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span></span>

- <span data-ttu-id="dbf4f-141">*显式加载*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-141">*Explicit loading*.</span></span> <span data-ttu-id="dbf4f-142">这是类似于延迟加载的只不过显式检索代码; 中的相关的数据它不会发生自动访问导航属性时。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-142">This is similar to lazy loading, except that you explicitly retrieve the related data in code; it doesn't happen automatically when you access a navigation property.</span></span> <span data-ttu-id="dbf4f-143">使用手动的相关的数据加载`Load`方法的导航属性的集合，或者你使用`Load`保存单个对象的属性引用属性的方法。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-143">You load related data manually using the `Load` method of the navigation property for collections, or you use the `Load` method of the reference property for properties that hold a single object.</span></span> <span data-ttu-id="dbf4f-144">(例如，调用`PersonReference.Load`方法以加载`Person`导航属性`Department`实体。)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-144">(For example, you call the `PersonReference.Load` method to load the `Person` navigation property of a `Department` entity.)</span></span>

    <span data-ttu-id="dbf4f-145">[![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-145">[![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span></span>

<span data-ttu-id="dbf4f-146">因为它们不立即检索的属性值，延迟加载和显式加载也同时称为*延迟加载*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-146">Because they don't immediately retrieve the property values, lazy loading and explicit loading are also both known as *deferred loading*.</span></span>

<span data-ttu-id="dbf4f-147">延迟加载是由设计器生成的对象上下文的默认行为。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-147">Lazy loading is the default behavior for an object context that has been generated by the designer.</span></span> <span data-ttu-id="dbf4f-148">如果你打开*SchoolModel.Designer.cs*文件，它定义对象上下文类，你将找到三个构造函数方法，以及每个包含以下语句：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-148">If you open the *SchoolModel.Designer.cs* file that defines the object context class, you'll find three constructor methods, and each of them includes the following statement:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

<span data-ttu-id="dbf4f-149">一般情况下，如果你知道需要相关的数据检索，预先加载提供最佳性能，每个实体因为单个查询发送到数据库通常比用于检索每个实体的单独查询效率更高。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-149">In general, if you know you need related data for every entity retrieved, eager loading offers the best performance, because a single query sent to the database is typically more efficient than separate queries for each entity retrieved.</span></span> <span data-ttu-id="dbf4f-150">另一方面，如果你需要仅不常访问实体的导航属性，还是仅为一个较小的实体、 延迟加载或显式加载集可能因更高效，因为预先加载将检索比你需要更多的数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-150">On the other hand, if you need to access an entity's navigation properties only infrequently or only for a small set of the entities, lazy loading or explicit loading may be more efficient, because eager loading would retrieve more data than you need.</span></span>

<span data-ttu-id="dbf4f-151">在 web 应用程序，延迟加载可能的相对较小的值，由于会影响对相关数据的需求的用户操作发生在浏览器，没有连接到对象上下文呈现页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-151">In a web application, lazy loading may be of relatively little value anyway, because user actions that affect the need for related data take place in the browser, which has no connection to the object context that rendered the page.</span></span> <span data-ttu-id="dbf4f-152">另一方面，当你数据绑定控件，你通常知道哪些数据需要并因此它通常是最佳选择预先加载或基于的延迟的加载时什么是适用于每个方案。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-152">On the other hand, when you databind a control, you typically know what data you need, and so it's generally best to choose eager loading or deferred loading based on what's appropriate in each scenario.</span></span>

<span data-ttu-id="dbf4f-153">此外，数据绑定控件可能使用的实体对象后释放对象上下文。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-153">In addition, a databound control might use an entity object after the object context is disposed.</span></span> <span data-ttu-id="dbf4f-154">在这种情况下，若要延迟加载的导航属性的尝试会失败。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-154">In that case, an attempt to lazy-load a navigation property would fail.</span></span> <span data-ttu-id="dbf4f-155">您收到的错误消息十分明显： &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;</span><span class="sxs-lookup"><span data-stu-id="dbf4f-155">The error message you receive is clear: &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;</span></span>

<span data-ttu-id="dbf4f-156">`EntityDataSource`控件默认情况下禁用延迟加载。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-156">The `EntityDataSource` control disables lazy loading by default.</span></span> <span data-ttu-id="dbf4f-157">有关`ObjectDataSource`控制你使用的当前教程 （或如果你从页的代码访问的对象上下文），有几种方法，你可以延迟加载默认禁用。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-157">For the `ObjectDataSource` control that you're using for the current tutorial (or if you access the object context from page code), there are several ways you can make lazy loading disabled by default.</span></span> <span data-ttu-id="dbf4f-158">当实例化对象上下文时，你可以禁用它。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-158">You can disable it when you instantiate an object context.</span></span> <span data-ttu-id="dbf4f-159">例如，可以将以下行添加到构造函数方法`SchoolRepository`类：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-159">For example, you can add the following line to the constructor method of the `SchoolRepository` class:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

<span data-ttu-id="dbf4f-160">对于 Contoso 大学应用程序，你将使自动禁用延迟加载的因此，此属性不必须时实例化上下文设置的对象上下文。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-160">For the Contoso University application, you'll make the object context automatically disable lazy loading so that this property doesn't have to be set whenever a context is instantiated.</span></span>

<span data-ttu-id="dbf4f-161">打开*SchoolModel.edmx*数据模型，单击设计图面上，，然后在属性窗格中设置**延迟加载启用**属性`False`。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-161">Open the *SchoolModel.edmx* data model, click the design surface, and then in the properties pane set the **Lazy Loading Enabled** property to `False`.</span></span> <span data-ttu-id="dbf4f-162">保存并关闭数据模型。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-162">Save and close the data model.</span></span>

<span data-ttu-id="dbf4f-163">[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-163">[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span></span>

## <a name="managing-view-state"></a><span data-ttu-id="dbf4f-164">管理视图状态</span><span class="sxs-lookup"><span data-stu-id="dbf4f-164">Managing View State</span></span>

<span data-ttu-id="dbf4f-165">为了提供更新功能，ASP.NET 网页时，必须存储实体的原始属性值中呈现页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-165">In order to provide update functionality, an ASP.NET web page must store the original property values of an entity when a page is rendered.</span></span> <span data-ttu-id="dbf4f-166">处理控件的回发期间重新创建该实体的原始状态，调用实体的`Attach`方法，然后才能应用更改并调用`SaveChanges`方法。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-166">During postback processing the control can re-create the original state of the entity and call the entity's `Attach` method before applying changes and calling the `SaveChanges` method.</span></span> <span data-ttu-id="dbf4f-167">默认情况下，ASP.NET Web 窗体数据控件使用视图状态来存储的原始值。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-167">By default, ASP.NET Web Forms data controls use view state to store the original values.</span></span> <span data-ttu-id="dbf4f-168">但是，视图状态会影响性能，因为它存储在会显著增加发送到和从浏览器的页面大小的隐藏字段。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-168">However, view state can affect performance, because it's stored in hidden fields that can substantially increase the size of the page that's sent to and from the browser.</span></span>

<span data-ttu-id="dbf4f-169">技术用于管理视图状态或替代产品，例如会话状态，并不到实体框架中，唯一的因此本教程不转到本主题中详细信息。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-169">Techniques for managing view state, or alternatives such as session state, aren't unique to the Entity Framework, so this tutorial doesn't go into this topic in detail.</span></span> <span data-ttu-id="dbf4f-170">有关详细信息，请参阅链接，在本教程末尾。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-170">For more information see the links at the end of the tutorial.</span></span>

<span data-ttu-id="dbf4f-171">但是，版本 4 的 ASP.NET 提供了使用 Web 窗体应用程序的每个 ASP.NET 开发人员应注意的视图状态的新方法：`ViewStateMode`属性。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-171">However, version 4 of ASP.NET provides a new way of working with view state that every ASP.NET developer of Web Forms applications should be aware of: the `ViewStateMode` property.</span></span> <span data-ttu-id="dbf4f-172">可以在页或控件级别，设置此新属性，它可用于页面的默认情况下禁用视图状态，并仅为需要它的控件中启用它。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-172">This new property can be set at the page or control level, and it enables you to disable view state by default for a page and enable it only for controls that need it.</span></span>

<span data-ttu-id="dbf4f-173">性能关键的应用程序，一个好的做法是始终禁用页级的视图状态，并仅为需要它的控件中启用它。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-173">For applications where performance is critical, a good practice is to always disable view state at the page level and enable it only for controls that require it.</span></span> <span data-ttu-id="dbf4f-174">Contoso 大学页中的视图状态的大小不会显著减少通过这种方法，但若要查看其工作原理，你将执行此操作*Instructors.aspx*页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-174">The size of view state in the Contoso University pages wouldn't be substantially decreased by this method, but to see how it works, you'll do it for the *Instructors.aspx* page.</span></span> <span data-ttu-id="dbf4f-175">该页面包含很多控件，包括`Label`禁用了视图状态的控件。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-175">That page contains many controls, including a `Label` control that has view state disabled.</span></span> <span data-ttu-id="dbf4f-176">无此页上的控件实际上需要已启用状态的视图。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-176">None of the controls on this page actually need to have view state enabled.</span></span> <span data-ttu-id="dbf4f-177">(`DataKeyNames`属性`GridView`控件指定必须回发，之间保持的状态，但这些值保存在通过不受影响的控件状态`ViewStateMode`属性。)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-177">(The `DataKeyNames` property of the `GridView` control specifies state that must be maintained between postbacks, but these values are kept in control state, which isn't affected by the `ViewStateMode` property.)</span></span>

<span data-ttu-id="dbf4f-178">`Page`指令和`Label`控件标记当前类似于下面的示例：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-178">The `Page` directive and `Label` control markup currently resembles the following example:</span></span>

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

<span data-ttu-id="dbf4f-179">进行以下更改：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-179">Make the following changes:</span></span>

- <span data-ttu-id="dbf4f-180">添加`ViewStateMode="Disabled"`到`Page`指令。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-180">Add `ViewStateMode="Disabled"` to the `Page` directive.</span></span>
- <span data-ttu-id="dbf4f-181">删除`ViewStateMode="Disabled"`从`Label`控件。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-181">Remove `ViewStateMode="Disabled"` from the `Label` control.</span></span>

<span data-ttu-id="dbf4f-182">标记现在将类似于下面的示例：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-182">The markup now resembles the following example:</span></span>

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

<span data-ttu-id="dbf4f-183">视图状态现已禁用的所有控件。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-183">View state is now disabled for all controls.</span></span> <span data-ttu-id="dbf4f-184">如果你稍后添加控件确实需要使用视图状态，你需要做是包括`ViewStateMode="Enabled"`该控件的属性。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-184">If you later add a control that does need to use view state, all you need to do is include the `ViewStateMode="Enabled"` attribute for that control.</span></span>

## <a name="using-the-notracking-merge-option"></a><span data-ttu-id="dbf4f-185">使用 NoTracking 合并选项</span><span class="sxs-lookup"><span data-stu-id="dbf4f-185">Using The NoTracking Merge Option</span></span>

<span data-ttu-id="dbf4f-186">当对象上下文检索数据库行，并创建表示它们的实体对象时，默认情况下它还跟踪这些实体对象使用其对象状态管理器。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-186">When an object context retrieves database rows and creates entity objects that represent them, by default it also tracks those entity objects using its object state manager.</span></span> <span data-ttu-id="dbf4f-187">此跟踪数据充当缓存，并更新实体时使用。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-187">This tracking data acts as a cache and is used when you update an entity.</span></span> <span data-ttu-id="dbf4f-188">Web 应用程序通常具有生存期较短的对象上下文实例，因为查询通常返回不需要进行跟踪，因为将释放对象上下文读取它们，再次使用它读取的实体的任何之前的数据或更新。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-188">Because a web application typically has short-lived object context instances, queries often return data that doesn't need to be tracked, because the object context that reads them will be disposed before any of the entities it reads are used again or updated.</span></span>

<span data-ttu-id="dbf4f-189">在实体框架中，你可以指定的对象上下文是否通过设置跟踪实体对象*合并选项*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-189">In the Entity Framework, you can specify whether the object context tracks entity objects by setting a *merge option*.</span></span> <span data-ttu-id="dbf4f-190">你可以设置的单个查询或实体集的合并选项。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-190">You can set the merge option for individual queries or for entity sets.</span></span> <span data-ttu-id="dbf4f-191">如果将其设置为实体集，这意味着你要设置的默认合并选项为该实体集创建的所有查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-191">If you set it for an entity set, that means that you're setting the default merge option for all queries that are created for that entity set.</span></span>

<span data-ttu-id="dbf4f-192">对于 Contoso 大学应用程序，跟踪无需任何你访问从存储库，因此你可以设置的合并选项为的实体集`NoTracking`为这些实体集时实例化的对象上下文中的存储库类。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-192">For the Contoso University application, tracking isn't needed for any of the entity sets that you access from the repository, so you can set the merge option to `NoTracking` for those entity sets when you instantiate the object context in the repository class.</span></span> <span data-ttu-id="dbf4f-193">（请注意，在本教程中，设置的合并选项不会产生明显影响对应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-193">(Note that in this tutorial, setting the merge option won't have a noticeable effect on the application's performance.</span></span> <span data-ttu-id="dbf4f-194">`NoTracking`选项有可能使仅在某些大数据容量方案中的可观察到的性能改进。)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-194">The `NoTracking` option is likely to make an observable performance improvement only in certain high-data-volume scenarios.)</span></span>

<span data-ttu-id="dbf4f-195">在 DAL 文件夹中，打开*SchoolRepository.cs*文件并添加的实体设置存储库访问设置的合并选项的构造函数方法：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-195">In the DAL folder, open the *SchoolRepository.cs* file and add a constructor method that sets the merge option for the entity sets that the repository accesses:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

## <a name="pre-compiling-linq-queries"></a><span data-ttu-id="dbf4f-196">预编译的 LINQ 查询</span><span class="sxs-lookup"><span data-stu-id="dbf4f-196">Pre-Compiling LINQ Queries</span></span>

<span data-ttu-id="dbf4f-197">实体框架所执行的生存期内的 Entity SQL 查询的第一个时间给定`ObjectContext`实例，需要一段时间来编译查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-197">The first time that the Entity Framework executes an Entity SQL query within the life of a given `ObjectContext` instance, it takes some time to compile the query.</span></span> <span data-ttu-id="dbf4f-198">缓存的编译结果，这意味着后续执行的查询快得多。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-198">The result of compilation is cached, which means that subsequent executions of the query are much quicker.</span></span> <span data-ttu-id="dbf4f-199">LINQ 查询按照类似的模式，只不过某些编译查询所需的工作完成每次执行查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-199">LINQ queries follow a similar pattern, except that some of the work required to compile the query is done every time the query is executed.</span></span> <span data-ttu-id="dbf4f-200">换而言之，对于 LINQ 查询，默认情况下不是所有的编译结果进行缓存。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-200">In other words, for LINQ queries, by default not all of the results of compilation are cached.</span></span>

<span data-ttu-id="dbf4f-201">如果你有你希望重复运行生活中的对象上下文的 LINQ 查询，你可以编写代码，使所有编译将缓存第一次运行 LINQ 查询的结果。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-201">If you have a LINQ query that you expect to run repeatedly in the life of an object context, you can write code that causes all of the results of compilation to be cached the first time the LINQ query is run.</span></span>

<span data-ttu-id="dbf4f-202">为说明，你需要执行此操作适用于两个`Get`中的方法`SchoolRepository`类，其中不带任何参数 (`GetInstructorNames`方法)，和一个需要一个参数 (`GetDepartmentsByAdministrator`方法)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-202">As an illustration, you'll do this for two `Get` methods in the `SchoolRepository` class, one of which doesn't take any parameters (the `GetInstructorNames` method), and one that does require a parameter (the `GetDepartmentsByAdministrator` method).</span></span> <span data-ttu-id="dbf4f-203">这些方法为代表现在实际上不需要编译，因为它们不是 LINQ 查询：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-203">These methods as they stand now actually don't need to be compiled because they aren't LINQ queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

<span data-ttu-id="dbf4f-204">但是，以便你还可以尝试已编译的查询，你将继续进行，犹如这些编写为以下 LINQ 查询：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-204">However, so that you can try out compiled queries, you'll proceed as if these had been written as the following LINQ queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

<span data-ttu-id="dbf4f-205">具有上面所示和运行应用程序来验证其工作在继续之前，无法更改这些方法中的代码。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-205">You could change the code in these methods to what's shown above and run the application to verify that it works before continuing.</span></span> <span data-ttu-id="dbf4f-206">但以下说明阅读右本文档中创建预编译的版本。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-206">But the following instructions jump right into creating pre-compiled versions of them.</span></span>

<span data-ttu-id="dbf4f-207">创建中的类文件*DAL*文件夹中，将其命名为*SchoolEntities.cs*，并将现有代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-207">Create a class file in the *DAL* folder, name it *SchoolEntities.cs*, and replace the existing code with the following code:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

<span data-ttu-id="dbf4f-208">此代码将创建扩展自动生成的对象上下文类的分部类。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-208">This code creates a partial class that extends the automatically generated object context class.</span></span> <span data-ttu-id="dbf4f-209">分部类包含两个已编译的 LINQ 查询使用`Compile`方法`CompiledQuery`类。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-209">The partial class includes two compiled LINQ queries using the `Compile` method of the `CompiledQuery` class.</span></span> <span data-ttu-id="dbf4f-210">它还将创建可用于调用查询的方法。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-210">It also creates methods that you can use to call the queries.</span></span> <span data-ttu-id="dbf4f-211">保存并关闭此文件。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-211">Save and close this file.</span></span>

<span data-ttu-id="dbf4f-212">接下来，在*SchoolRepository.cs*，更改现有`GetInstructorNames`和`GetDepartmentsByAdministrator`储存库中的方法的类，使它们调用已编译的查询：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-212">Next, in *SchoolRepository.cs*, change the existing `GetInstructorNames` and `GetDepartmentsByAdministrator` methods in the repository class so that they call the compiled queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

<span data-ttu-id="dbf4f-213">运行*Departments.aspx*页以验证它能否像以前一样工作。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-213">Run the *Departments.aspx* page to verify that it works as it did before.</span></span> <span data-ttu-id="dbf4f-214">`GetInstructorNames`以便填充管理员下拉列表中，调用方法和`GetDepartmentsByAdministrator`单击时，方法调用**更新**为了验证没有教师是否的多个管理员部门。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-214">The `GetInstructorNames` method is called in order to populate the administrator drop-down list, and the `GetDepartmentsByAdministrator` method is called when you click **Update** in order to verify that no instructor is an administrator of more than one department.</span></span>

<span data-ttu-id="dbf4f-215">[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-215">[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span></span>

<span data-ttu-id="dbf4f-216">在 Contoso 大学应用程序只是为了不是因为它会明显提高性能，请参阅如何做到这一点，已预编译的查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-216">You've pre-compiled queries in the Contoso University application only to see how to do it, not because it would measurably improve performance.</span></span> <span data-ttu-id="dbf4f-217">预编译的 LINQ 查询未添加到代码中的复杂性，因此请确保你执行此操作仅对实际表示你的应用程序中的性能瓶颈的查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-217">Pre-compiling LINQ queries does add a level of complexity to your code, so make sure you do it only for queries that actually represent performance bottlenecks in your application.</span></span>

## <a name="examining-queries-sent-to-the-database"></a><span data-ttu-id="dbf4f-218">检查查询发送到数据库</span><span class="sxs-lookup"><span data-stu-id="dbf4f-218">Examining Queries Sent to the Database</span></span>

<span data-ttu-id="dbf4f-219">当你正在调查性能问题时，有时会有帮助以了解确切实体框架将发送到数据库的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-219">When you're investigating performance issues, sometimes it's helpful to know the exact SQL commands that the Entity Framework is sending to the database.</span></span> <span data-ttu-id="dbf4f-220">如果你正在使用`IQueryable`对象，执行此操作的一种方法是使用`ToTraceString`方法。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-220">If you're working with an `IQueryable` object, one way to do this is to use the `ToTraceString` method.</span></span>

<span data-ttu-id="dbf4f-221">在*SchoolRepository.cs*，更改中的代码`GetDepartmentsByName`方法以匹配以下示例：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-221">In *SchoolRepository.cs*, change the code in the `GetDepartmentsByName` method to match the following example:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.cs)]

<span data-ttu-id="dbf4f-222">`departments`变量必须强制转换为`ObjectQuery`键入只是因为`Where`方法在前面的行的末尾创建`IQueryable`对象; 而无需`Where`方法，该强制转换不是必需。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-222">The `departments` variable must be cast to an `ObjectQuery` type only because the `Where` method at the end of the preceding line creates an `IQueryable` object; without the `Where` method, the cast would not be necessary.</span></span>

<span data-ttu-id="dbf4f-223">上设置断点`return`行，然后再运行*Departments.aspx*在调试器中的页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-223">Set a breakpoint on the `return` line, and then run the *Departments.aspx* page in the debugger.</span></span> <span data-ttu-id="dbf4f-224">当命中断点时，检查`commandText`变量中**局部变量**窗口并使用文本可视化工具 (在放大镜**值**列) 以显示其值在**文本可视化工具**窗口。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-224">When you hit the breakpoint, examine the `commandText` variable in the **Locals** window and use the text visualizer (the magnifying glass in the **Value** column) to display its value in the **Text Visualizer** window.</span></span> <span data-ttu-id="dbf4f-225">你可以看到此代码生成的整个 SQL 命令：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-225">You can see the entire SQL command that results from this code:</span></span>

<span data-ttu-id="dbf4f-226">[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-226">[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span></span>

<span data-ttu-id="dbf4f-227">作为替代方法，在 Visual Studio Ultimate 中的 IntelliTrace 功能使您能够查看生成的实体框架不需要你更改代码或甚至设置断点的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-227">As an alternative, the IntelliTrace feature in Visual Studio Ultimate provides a way to view SQL commands generated by the Entity Framework that doesn't require you to change your code or even set a breakpoint.</span></span>

> [!NOTE]
> <span data-ttu-id="dbf4f-228">仅当你有 Visual Studio Ultimate，您可以执行以下过程。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-228">You can perform the following procedures only if you have Visual Studio Ultimate.</span></span>


<span data-ttu-id="dbf4f-229">还原中的原始代码`GetDepartmentsByName`方法，并再次运行*Departments.aspx*在调试器中的页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-229">Restore the original code in the `GetDepartmentsByName` method, and then run the *Departments.aspx* page in the debugger.</span></span>

<span data-ttu-id="dbf4f-230">在 Visual Studio 中，选择**调试**菜单，然后**IntelliTrace**，，然后**IntelliTrace 事件**。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-230">In Visual Studio, select the **Debug** menu, then **IntelliTrace**, and then **IntelliTrace Events**.</span></span>

<span data-ttu-id="dbf4f-231">[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-231">[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span></span>

<span data-ttu-id="dbf4f-232">在**IntelliTrace**窗口中，单击**全部中断**。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-232">In the **IntelliTrace** window, click **Break All**.</span></span>

<span data-ttu-id="dbf4f-233">[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-233">[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span></span>

<span data-ttu-id="dbf4f-234">**IntelliTrace**窗口显示最新事件的列表：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-234">The **IntelliTrace** window displays a list of recent events:</span></span>

<span data-ttu-id="dbf4f-235">[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-235">[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span></span>

<span data-ttu-id="dbf4f-236">单击**ADO.NET**行。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-236">Click the **ADO.NET** line.</span></span> <span data-ttu-id="dbf4f-237">它将展开以显示命令文本：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-237">It expands to show you the command text:</span></span>

<span data-ttu-id="dbf4f-238">[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-238">[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span></span>

<span data-ttu-id="dbf4f-239">你可以将整个命令文本字符串复制到从剪贴板**局部变量**窗口。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-239">You can copy the entire command text string to the clipboard from the **Locals** window.</span></span>

<span data-ttu-id="dbf4f-240">假设具有多个表、 关系和的列比简单的数据库与你共事`School`数据库。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-240">Suppose you were working with a database with more tables, relationships, and columns than the simple `School` database.</span></span> <span data-ttu-id="dbf4f-241">你可能会发现收集的所有信息的查询需要在单个`Select`包含多个语句`Join`子句变得太复杂，能够高效工作。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-241">You might find that a query that gathers all the information you need in a single `Select` statement containing multiple `Join` clauses becomes too complex to work efficiently.</span></span> <span data-ttu-id="dbf4f-242">在这种情况下，你就可以从预先加载到显式加载可以简化查询切换。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-242">In that case you can switch from eager loading to explicit loading to simplify the query.</span></span>

<span data-ttu-id="dbf4f-243">例如，尝试更改中的代码`GetDepartmentsByName`中的方法*SchoolRepository.cs*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-243">For example, try changing the code in the `GetDepartmentsByName` method in *SchoolRepository.cs*.</span></span> <span data-ttu-id="dbf4f-244">当前，方法您可以具有一个对象查询`Include`方法`Person`和`Courses`导航属性。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-244">Currently in that method you have an object query that has `Include` methods for the `Person` and `Courses` navigation properties.</span></span> <span data-ttu-id="dbf4f-245">替换`return`，执行显式加载，如下面的示例中所示的代码语句：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-245">Replace the `return` statement with code that performs explicit loading, as shown in the following example:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

<span data-ttu-id="dbf4f-246">运行*Departments.aspx*在调试器中页上，并检查**IntelliTrace**再次为你的窗口之前一致。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-246">Run the *Departments.aspx* page in the debugger and check the **IntelliTrace** window again as you did before.</span></span> <span data-ttu-id="dbf4f-247">现在，其中没有单个查询之前，你将看到一长串的它们。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-247">Now, where there was a single query before, you see a long sequence of them.</span></span>

<span data-ttu-id="dbf4f-248">[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-248">[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span></span>

<span data-ttu-id="dbf4f-249">单击第一个**ADO.NET**行以查看发生了什么复杂查询你查看更早版本。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-249">Click the first **ADO.NET** line to see what has happened to the complex query you viewed earlier.</span></span>

<span data-ttu-id="dbf4f-250">[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-250">[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span></span>

<span data-ttu-id="dbf4f-251">部门中的查询已变得简单`Select`查询没有`Join`子句，但它后跟检索相关的课程，又是管理员的单独查询，使用为每个部门的一组的两个查询返回的原始查询。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-251">The query from Departments has become a simple `Select` query with no `Join` clause, but it's followed by separate queries that retrieve related courses and an administrator, using a set of two queries for each department returned by the original query.</span></span>

> [!NOTE]
> <span data-ttu-id="dbf4f-252">如果你离开延迟加载启用，你使用相同的查询重复很多时候，在这里，看的模式可能会导致从延迟加载。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-252">If you leave lazy loading enabled, the pattern you see here, with the same query repeated many times, might result from lazy loading.</span></span> <span data-ttu-id="dbf4f-253">你通常想要避免的模式是主表的每一行的延迟加载相关的数据。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-253">A pattern that you typically want to avoid is lazy-loading related data for every row of the primary table.</span></span> <span data-ttu-id="dbf4f-254">除非你已验证的单一联接查询太过复杂，来有效地，通常将可以通过更改要使用预先加载的主查询来提高在这些情况下的性能。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-254">Unless you've verified that a single join query is too complex to be efficient, you'd typically be able to improve performance in such cases by changing the primary query to use eager loading.</span></span>


## <a name="pre-generating-views"></a><span data-ttu-id="dbf4f-255">预生成视图</span><span class="sxs-lookup"><span data-stu-id="dbf4f-255">Pre-Generating Views</span></span>

<span data-ttu-id="dbf4f-256">当`ObjectContext`对象首次创建新的应用程序域中，实体框架生成一组类，并用于访问数据库。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-256">When an `ObjectContext` object is first created in a new application domain, the Entity Framework generates a set of classes that it uses to access the database.</span></span> <span data-ttu-id="dbf4f-257">这些类称为*视图*，而如果你有一个非常大的数据模型，生成这些视图可以延迟页的第一个请求的网站的响应后初始化新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-257">These classes are called *views*, and if you have a very large data model, generating these views can delay the web site's response to the first request for a page after a new application domain is initialized.</span></span> <span data-ttu-id="dbf4f-258">你可以通过在编译时而不在运行时创建视图来减少此第一个请求延迟。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-258">You can reduce this first-request delay by creating the views at compile time rather than at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="dbf4f-259">如果你的应用程序没有过大的数据模型，或者如果它具有较大的数据模型，但无需考虑性能问题影响仅第一个页面请求回收 IIS 后，你可以跳过此部分。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-259">If your application doesn't have an extremely large data model, or if it does have a large data model but you aren't concerned about a performance problem that affects only the very first page request after IIS is recycled, you can skip this section.</span></span> <span data-ttu-id="dbf4f-260">每次您实例化时也不会发生创建的视图`ObjectContext`对象，因为视图将缓存应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-260">View creation doesn't happen every time you instantiate an `ObjectContext` object, because the views are cached in the application domain.</span></span> <span data-ttu-id="dbf4f-261">因此，除非你经常要回收 IIS 中的应用程序，非常少的页请求将受益于预生成视图。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-261">Therefore, unless you're frequently recycling your application in IIS, very few page requests would benefit from pre-generated views.</span></span>


<span data-ttu-id="dbf4f-262">你可以预生成视图使用*EdmGen.exe*命令行工具或通过使用*文本模板转换工具包*(T4) 模板。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-262">You can pre-generate views using the *EdmGen.exe* command-line tool or by using a *Text Template Transformation Toolkit* (T4) template.</span></span> <span data-ttu-id="dbf4f-263">在本教程中，你将使用 T4 模板。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-263">In this tutorial you'll use a T4 template.</span></span>

<span data-ttu-id="dbf4f-264">在*DAL*文件夹中，添加文件使用**文本模板**模板 (它位于**常规**中的节点**已安装的模板**列表)，并将其命名*SchoolModel.Views.tt*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-264">In the *DAL* folder, add a file using the **Text Template** template (it's under the **General** node in the **Installed Templates** list), and name it *SchoolModel.Views.tt*.</span></span> <span data-ttu-id="dbf4f-265">文件中的现有代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-265">Replace the existing code in the file with the following code:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

<span data-ttu-id="dbf4f-266">此代码生成视图*.edmx*文件位于与模板相同的文件夹并为模板文件具有相同的名称。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-266">This code generates views for an *.edmx* file that's located in the same folder as the template and that has the same name as the template file.</span></span> <span data-ttu-id="dbf4f-267">例如，如果名为你的模板文件*SchoolModel.Views.tt*，它将查找名为的数据模型文件*SchoolModel.edmx*。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-267">For example, if your template file is named *SchoolModel.Views.tt*, it will look for a data model file named *SchoolModel.edmx*.</span></span>

<span data-ttu-id="dbf4f-268">保存该文件，然后右键单击中的文件**解决方案资源管理器**和选择**运行自定义工具**。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-268">Save the file, then right-click the file in **Solution Explorer** and select **Run Custom Tool**.</span></span>

<span data-ttu-id="dbf4f-269">[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-269">[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span></span>

<span data-ttu-id="dbf4f-270">Visual Studio 将生成的代码文件创建视图，这名为*SchoolModel.Views.cs*在基于的模板。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-270">Visual Studio generates a code file that creates the views, which is named *SchoolModel.Views.cs* based on the template.</span></span> <span data-ttu-id="dbf4f-271">(你可能已经注意到甚至在你选择之前，生成的代码文件**运行自定义工具**，就会立即保存模板文件。)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-271">(You might have noticed that the code file is generated even before you select **Run Custom Tool**, as soon as you save the template file.)</span></span>

<span data-ttu-id="dbf4f-272">[![Image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-272">[![Image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span></span>

<span data-ttu-id="dbf4f-273">你现在可以运行应用程序，并确认它像以前一样的方式工作。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-273">You can now run the application and verify that it works as it did before.</span></span>

<span data-ttu-id="dbf4f-274">有关预生成视图的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-274">For more information about pre-generated views, see the following resources:</span></span>

- <span data-ttu-id="dbf4f-275">[如何： 预生成视图提高查询性能](https://msdn.microsoft.com/library/bb896240.aspx)MSDN 网站上。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-275">[How to: Pre-Generate Views to Improve Query Performance](https://msdn.microsoft.com/library/bb896240.aspx) on the MSDN web site.</span></span> <span data-ttu-id="dbf4f-276">说明如何使用`EdmGen.exe`视图预生成的命令行工具。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-276">Explains how to use the `EdmGen.exe` command-line tool to pre-generate views.</span></span>
- <span data-ttu-id="dbf4f-277">[隔离与预编译/前 generated 视图实体 Framework 4 中的性能](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx)Windows Server AppFabric 客户咨询团队博客上。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-277">[Isolating Performance with Precompiled/Pre-generated Views in the Entity Framework 4](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) on the Windows Server AppFabric Customer Advisory Team blog.</span></span>

<span data-ttu-id="dbf4f-278">这将完成简介提高的 ASP.NET web 应用程序使用实体框架中的性能。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-278">This completes the introduction to improving performance in an ASP.NET web application that uses the Entity Framework.</span></span> <span data-ttu-id="dbf4f-279">有关更多信息，请参见以下资源：</span><span class="sxs-lookup"><span data-stu-id="dbf4f-279">For more information, see the following resources:</span></span>

- <span data-ttu-id="dbf4f-280">[性能注意事项 （实体框架）](https://msdn.microsoft.com/library/cc853327.aspx) MSDN 网站上。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-280">[Performance Considerations (Entity Framework)](https://msdn.microsoft.com/library/cc853327.aspx) on the MSDN web site.</span></span>
- <span data-ttu-id="dbf4f-281">[实体框架团队博客上与性能相关的文章](https://blogs.msdn.com/b/adonet/archive/tags/performance/)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-281">[Performance-related posts on the Entity Framework Team blog](https://blogs.msdn.com/b/adonet/archive/tags/performance/).</span></span>
- <span data-ttu-id="dbf4f-282">[EF 合并选项和已编译的查询](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-282">[EF Merge Options and Compiled Queries](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx).</span></span> <span data-ttu-id="dbf4f-283">说明的已编译的查询和合并的意外的行为的博客文章选项如`NoTracking`。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-283">Blog post that explains unexpected behaviors of compiled queries and merge options such as `NoTracking`.</span></span> <span data-ttu-id="dbf4f-284">如果你打算使用已编译的查询或操作应用程序中的合并选项设置，这首先阅读。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-284">If you plan to use compiled queries or manipulate merge option settings in your application, read this first.</span></span>
- <span data-ttu-id="dbf4f-285">[数据和建模客户咨询团队博客中的实体框架相关文章](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-285">[Entity Framework-related posts in the Data and Modeling Customer Advisory Team blog](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/).</span></span> <span data-ttu-id="dbf4f-286">包括有关已编译的查询和使用 Visual Studio 2010 探查器来发现性能问题的文章。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-286">Includes posts on compiled queries and using the Visual Studio 2010 Profiler to discover performance issues.</span></span>
- <span data-ttu-id="dbf4f-287">[使用提升的非常复杂的查询性能的建议的实体框架论坛线程](https://social.msdn.microsoft.com/Forums/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-287">[Entity Framework forum thread with advice on improving performance of highly complex queries](https://social.msdn.microsoft.com/Forums/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6).</span></span>
- <span data-ttu-id="dbf4f-288">[ASP.NET 状态管理建议](https://msdn.microsoft.com/library/z1hkazw7.aspx)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-288">[ASP.NET State Management Recommendations](https://msdn.microsoft.com/library/z1hkazw7.aspx).</span></span>
- <span data-ttu-id="dbf4f-289">[使用实体框架和 ObjectDataSource： 自定义分页](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx)。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-289">[Using the Entity Framework and the ObjectDataSource: Custom Paging](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx).</span></span> <span data-ttu-id="dbf4f-290">这些教程中创建的 ContosoUniversity 应用程序说明如何实现中的分页生成的博客文章*Departments.aspx*页。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-290">Blog post that builds on the ContosoUniversity application created in these tutorials to explain how to implement paging in the *Departments.aspx* page.</span></span>

<span data-ttu-id="dbf4f-291">下一教程查看一些对 Entity Framework 版本 4 中新增的重要增强功能。</span><span class="sxs-lookup"><span data-stu-id="dbf4f-291">The next tutorial reviews some of the important enhancements to the Entity Framework that are new in version 4.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="dbf4f-292">[上一页](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
> [下一页](what-s-new-in-the-entity-framework-4.md)</span><span class="sxs-lookup"><span data-stu-id="dbf4f-292">[Previous](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
[Next](what-s-new-in-the-entity-framework-4.md)</span></span>
