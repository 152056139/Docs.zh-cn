---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-vb
title: "处理未经处理的异常 (VB) |Microsoft 文档"
author: rick-anderson
description: "对 web 应用程序在生产中发生运行时错误时务必通知开发人员，并记录错误，以便它可能在诊断，a la..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/09/2009
ms.topic: article
ms.assetid: 051296f0-9519-4e78-835c-d868da13b0a0
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-vb
msc.type: authoredcontent
ms.openlocfilehash: c1653cb3a8c684fd3d4fc2a039a947cfb5d42400
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="processing-unhandled-exceptions-vb"></a><span data-ttu-id="a31e2-103">处理未经处理的异常 (VB)</span><span class="sxs-lookup"><span data-stu-id="a31e2-103">Processing Unhandled Exceptions (VB)</span></span>
====================
<span data-ttu-id="a31e2-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="a31e2-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="a31e2-105">[下载代码](http://download.microsoft.com/download/1/0/C/10CC829F-A808-4302-97D3-59989B8F9C01/ASPNET_Hosting_Tutorial_12_VB.zip)或[下载 PDF](http://download.microsoft.com/download/5/C/5/5C57DB8C-5DEA-4B3A-92CA-4405544D313B/aspnet_tutorial12_ErrorHandling_vb.pdf)</span><span class="sxs-lookup"><span data-stu-id="a31e2-105">[Download Code](http://download.microsoft.com/download/1/0/C/10CC829F-A808-4302-97D3-59989B8F9C01/ASPNET_Hosting_Tutorial_12_VB.zip) or [Download PDF](http://download.microsoft.com/download/5/C/5/5C57DB8C-5DEA-4B3A-92CA-4405544D313B/aspnet_tutorial12_ErrorHandling_vb.pdf)</span></span>

> <span data-ttu-id="a31e2-106">对 web 应用程序在生产中发生运行时错误时务必通知开发人员，并记录错误，以便它可能诊断在稍后的时间。</span><span class="sxs-lookup"><span data-stu-id="a31e2-106">When a runtime error occurs on a web application in production it is important to notify a developer and to log the error so that it may be diagnosed at a later point in time.</span></span> <span data-ttu-id="a31e2-107">本教程提供如何 ASP.NET 处理运行时错误，并考察的执行时最多 ASP.NET 运行时未处理的异常气泡的自定义代码的一种方法的概述。</span><span class="sxs-lookup"><span data-stu-id="a31e2-107">This tutorial provides an overview of how ASP.NET processes runtime errors and looks at one way to have custom code execute whenever an unhandled exception bubbles up to the ASP.NET runtime.</span></span>


## <a name="introduction"></a><span data-ttu-id="a31e2-108">介绍</span><span class="sxs-lookup"><span data-stu-id="a31e2-108">Introduction</span></span>

<span data-ttu-id="a31e2-109">ASP.NET 应用程序中未经处理的异常时，它将冒泡到 ASP.NET 运行时，将引发`Error`事件，并显示相应的错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-109">When an unhandled exception occurs in an ASP.NET application, it bubbles up to the ASP.NET runtime, which raises the `Error` event and displays the appropriate error page.</span></span> <span data-ttu-id="a31e2-110">有三种不同类型的错误页： 运行时错误黄色屏幕的死亡 (YSOD);异常详细信息 YSOD;和自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-110">There are three different types of error pages: the Runtime Error Yellow Screen of Death (YSOD); the Exception Details YSOD; and custom error pages.</span></span> <span data-ttu-id="a31e2-111">在[前面教程](displaying-a-custom-error-page-vb.md)我们配置应用程序以用于远程用户和本地访问的用户异常详细信息 YSOD 的自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-111">In the [preceding tutorial](displaying-a-custom-error-page-vb.md) we configured the application to use a custom error page for remote users and the Exception Details YSOD for users visiting locally.</span></span>

<span data-ttu-id="a31e2-112">使用匹配的站点的外观和感觉人工友好自定义错误页是首选方法为默认值运行时错误 YSOD，但显示自定义错误页是仅一个全面的错误处理解决方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="a31e2-112">Using a human-friendly custom error page that matches the look and feel of the site is preferred to the default Runtime Error YSOD, but displaying a custom error page is only one part of a comprehensive error handling solution.</span></span> <span data-ttu-id="a31e2-113">在生产环境中的应用程序错误时，很重要，以便他们可以暴露异常的原因和解决方法，开发人员会通知错误。</span><span class="sxs-lookup"><span data-stu-id="a31e2-113">When an error occurs in an application in production, it is important that the developers are notified of the error so that they can unearth the cause of the exception and address it.</span></span> <span data-ttu-id="a31e2-114">此外，以便可以检查错误，并将其时间稍后诊断，则应记录错误的详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-114">Furthermore, the error's details should be logged so that the error can be examined and diagnosed at a later point in time.</span></span>

<span data-ttu-id="a31e2-115">本教程演示如何访问未经处理的异常的详细信息，以便可以记录以及开发人员通知。</span><span class="sxs-lookup"><span data-stu-id="a31e2-115">This tutorial shows how to access the details of an unhandled exception so that they can be logged and a developer notified.</span></span> <span data-ttu-id="a31e2-116">按照此一个的两个教程浏览错误日志记录库之后，执行少量配置，将自动通知的运行时错误的开发人员和记录及其详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-116">The two tutorials following this one explore error logging libraries that, after a bit of configuration, will automatically notify developers of runtime errors and log their details.</span></span>

> [!NOTE]
> <span data-ttu-id="a31e2-117">检查在本教程中的信息是最有用，如果你需要以某种唯一或自定义方式处理未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="a31e2-117">The information examined in this tutorial is most useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="a31e2-118">在其中你只需将异常记录并通知开发人员的情况下，使用错误日志记录库是转的方法。</span><span class="sxs-lookup"><span data-stu-id="a31e2-118">In cases where you only need to log the exception and notify a developer, using an error logging library is the way to go.</span></span> <span data-ttu-id="a31e2-119">下面的两个教程提供了两个这种库的概述。</span><span class="sxs-lookup"><span data-stu-id="a31e2-119">The next two tutorials provide an overview of two such libraries.</span></span>


## <a name="executing-code-when-theerrorevent-is-raised"></a><span data-ttu-id="a31e2-120">执行代码时`Error`引发事件</span><span class="sxs-lookup"><span data-stu-id="a31e2-120">Executing Code When The`Error`Event Is Raised</span></span>

<span data-ttu-id="a31e2-121">事件提供一种机制信号性沉寂一些有趣的内容已发生的以及要在响应中执行代码的另一个对象的对象。</span><span class="sxs-lookup"><span data-stu-id="a31e2-121">Events provide an object a mechanism for signaling that something interesting has occurred, and for another object to execute code in response.</span></span> <span data-ttu-id="a31e2-122">作为 ASP.NET 开发人员你习惯于在事件方面的考虑。</span><span class="sxs-lookup"><span data-stu-id="a31e2-122">As an ASP.NET developer you are accustomed to thinking in terms of events.</span></span> <span data-ttu-id="a31e2-123">如果你想要在距访客单击特定的按钮时运行某些代码，该按钮创建一个事件处理程序`Click`事件和放置在那里的你的代码。</span><span class="sxs-lookup"><span data-stu-id="a31e2-123">If you want to run some code when the visitor clicks a particular Button, you create an event handler for that Button's `Click` event and put your code there.</span></span> <span data-ttu-id="a31e2-124">假设 ASP.NET 运行时将引发其[`Error`事件](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.error.aspx)每次发生未经处理的异常时，它遵循，用于记录错误的详细信息的代码将进入事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a31e2-124">Given that the ASP.NET runtime raises its [`Error` event](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.error.aspx) whenever an unhandled exception occurs, it follows that the code for logging the error's details would go in an event handler.</span></span> <span data-ttu-id="a31e2-125">如何创建的事件处理程序，但`Error`事件？</span><span class="sxs-lookup"><span data-stu-id="a31e2-125">But how do you create an event handler for the `Error` event?</span></span>

<span data-ttu-id="a31e2-126">`Error`事件是中的许多事件之一[`HttpApplication`类](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.aspx)期间请求的生存期，会引发在 HTTP 管道中的某些阶段。</span><span class="sxs-lookup"><span data-stu-id="a31e2-126">The `Error` event is one of many events in the [`HttpApplication` class](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.aspx) that are raised at certain stages in the HTTP pipeline during the lifetime of a request.</span></span> <span data-ttu-id="a31e2-127">例如，`HttpApplication`类的[`BeginRequest`事件](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.beginrequest.aspx)引发在开始时每个请求; 其[`AuthenticateRequest`事件](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.authenticaterequest.aspx)安全模块已标识请求者时，将引发。</span><span class="sxs-lookup"><span data-stu-id="a31e2-127">For example, the `HttpApplication` class's [`BeginRequest` event](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.beginrequest.aspx) is raised at the start of every request; its [`AuthenticateRequest` event](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.authenticaterequest.aspx) is raised when a security module has identified the requestor.</span></span> <span data-ttu-id="a31e2-128">这些`HttpApplication`事件为页开发人员提供了一种方式来执行请求的生存期内的各个点的自定义逻辑。</span><span class="sxs-lookup"><span data-stu-id="a31e2-128">These `HttpApplication` events give the page developer a means to execute custom logic at the various points in the lifetime of a request.</span></span>

<span data-ttu-id="a31e2-129">事件处理程序`HttpApplication`事件可以放置在名为的特殊文件`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-129">Event handlers for the `HttpApplication` events can be placed in a special file named `Global.asax`.</span></span> <span data-ttu-id="a31e2-130">在你的网站中创建此文件，将新项添加到全局应用程序类模板与名称使用您网站的根目录`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-130">To create this file in your website, add a new item to the root of your website using the Global Application Class template with the name `Global.asax`.</span></span>

[![](processing-unhandled-exceptions-vb/_static/image2.png)](processing-unhandled-exceptions-vb/_static/image1.png)

<span data-ttu-id="a31e2-131">**图 1**： 添加`Global.asax`到 Web 应用程序</span><span class="sxs-lookup"><span data-stu-id="a31e2-131">**Figure 1**: Add `Global.asax` To Your Web Application</span></span>  
 <span data-ttu-id="a31e2-132">([单击以查看实际尺寸的图像](processing-unhandled-exceptions-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="a31e2-132">([Click to view full-size image](processing-unhandled-exceptions-vb/_static/image3.png))</span></span>

<span data-ttu-id="a31e2-133">内容和结构`Global.asax`略有根据使用的 Web 应用程序项目 (WAP) 或网站项目 (WSP) Visual Studio 创建的文件会有所不同。</span><span class="sxs-lookup"><span data-stu-id="a31e2-133">The contents and structure of the `Global.asax` file created by Visual Studio differ slightly based on whether you are using a Web Application Project (WAP) or Web Site Project (WSP).</span></span> <span data-ttu-id="a31e2-134">与 WAP`Global.asax`作为两个单独的文件-实现`Global.asax`和`Global.asax.vb`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-134">With a WAP, the `Global.asax` is implemented as two separate files - `Global.asax` and `Global.asax.vb`.</span></span> <span data-ttu-id="a31e2-135">`Global.asax`文件不包含任何内容，但`@Application`引用的指令`.vb`文件; 感兴趣的处理程序中定义的事件`Global.asax.vb`文件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-135">The `Global.asax` file contains nothing but an `@Application` directive that references the `.vb` file; the event handlers of interest are defined in the `Global.asax.vb` file.</span></span> <span data-ttu-id="a31e2-136">对于 WSPs，都会创建单个文件， `Global.asax`，并且事件处理程序将在定义`<script runat="server">`块。</span><span class="sxs-lookup"><span data-stu-id="a31e2-136">For WSPs, only a single file is created, `Global.asax`, and the event handlers are defined in a `<script runat="server">` block.</span></span>

<span data-ttu-id="a31e2-137">`Global.asax`在 WAP 中创建 Visual Studio 的全局应用程序类模板的文件包含名为的事件处理程序`Application_BeginRequest`， `Application_AuthenticateRequest`，和`Application_Error`，这是事件处理程序`HttpApplication`事件`BeginRequest`， `AuthenticateRequest`，和`Error`分别。</span><span class="sxs-lookup"><span data-stu-id="a31e2-137">The `Global.asax` file created in a WAP by Visual Studio's Global Application Class template includes event handlers named `Application_BeginRequest`, `Application_AuthenticateRequest`, and `Application_Error`, which are event handlers for the `HttpApplication` events `BeginRequest`, `AuthenticateRequest`, and `Error`, respectively.</span></span> <span data-ttu-id="a31e2-138">也有事件处理程序名为`Application_Start`， `Session_Start`， `Application_End`，和`Session_End`，后者是 web 应用程序启动时、 时将新的会话启动，应用程序结束时，会触发的事件处理程序并在会话结束时，分别。</span><span class="sxs-lookup"><span data-stu-id="a31e2-138">There are also event handlers named `Application_Start`, `Session_Start`, `Application_End`, and `Session_End`, which are event handlers that fire when the web application starts, when a new session starts, when the application ends, and when a session ends, respectively.</span></span> <span data-ttu-id="a31e2-139">`Global.asax` WSP 在 Visual Studio 中创建的文件只包含`Application_Error`， `Application_Start`， `Session_Start`， `Application_End`，和`Session_End`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a31e2-139">The `Global.asax` file created in a WSP by Visual Studio contains just the `Application_Error`, `Application_Start`, `Session_Start`, `Application_End`, and `Session_End` event handlers.</span></span>

> [!NOTE]
> <span data-ttu-id="a31e2-140">部署 ASP.NET 应用程序时，你需要进行复制`Global.asax`到生产环境的文件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-140">When deploying the ASP.NET application you need to copy the `Global.asax` file to the production environment.</span></span> <span data-ttu-id="a31e2-141">`Global.asax.vb`文件，在 WAP 中创建的是，不需要复制到生产环境中，因为此代码会编译成项目的程序集。</span><span class="sxs-lookup"><span data-stu-id="a31e2-141">The `Global.asax.vb` file, which is created in the WAP, does not need to be copied to production because this code is compiled into the project's assembly.</span></span>


<span data-ttu-id="a31e2-142">由 Visual Studio 的全局应用程序类模板创建的事件处理程序并不详尽。</span><span class="sxs-lookup"><span data-stu-id="a31e2-142">The event handlers created by Visual Studio's Global Application Class template are not exhaustive.</span></span> <span data-ttu-id="a31e2-143">您可以为任何添加事件处理程序`HttpApplication`通过命名事件处理程序的事件`Application_EventName`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-143">You can add an event handler for any `HttpApplication` event by naming the event handler `Application_EventName`.</span></span> <span data-ttu-id="a31e2-144">例如，可以添加到下面的代码`Global.asax`文件以创建的事件处理程序[`AuthorizeRequest`事件](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.authorizerequest.aspx):</span><span class="sxs-lookup"><span data-stu-id="a31e2-144">For example, you could add the following code to the `Global.asax` file to create an event handler for the [`AuthorizeRequest` event](https://msdn.microsoft.com/en-us/library/system.web.httpapplication.authorizerequest.aspx):</span></span>

[!code-vb[Main](processing-unhandled-exceptions-vb/samples/sample1.vb)]

<span data-ttu-id="a31e2-145">同样，你可以删除全局应用程序类模板创建的任何事件处理程序，则不需要。</span><span class="sxs-lookup"><span data-stu-id="a31e2-145">Likewise, you can remove any event handlers created by the Global Application Class template that are not needed.</span></span> <span data-ttu-id="a31e2-146">本教程中我们只需要一个事件处理程序`Error`事件; 随意删除从其他事件处理程序`Global.asax`文件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-146">For this tutorial we only require an event handler for the `Error` event; feel free to remove the other event handlers from the `Global.asax` file.</span></span>

> [!NOTE]
> <span data-ttu-id="a31e2-147">*HTTP 模块*提供另一种方法来定义事件处理程序`HttpApplication`事件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-147">*HTTP Modules* offer another way to define event handlers for `HttpApplication` events.</span></span> <span data-ttu-id="a31e2-148">HTTP 模块创建为一个类文件，可以直接在 web 应用程序项目内放置或分隔到单独的类库。</span><span class="sxs-lookup"><span data-stu-id="a31e2-148">HTTP Modules are created as a class file that can be placed directly within the web application project or separated out into a separate class library.</span></span> <span data-ttu-id="a31e2-149">因为它们可以分为一个类库，HTTP 模块提供用于创建更加灵活和可重用模型`HttpApplication`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a31e2-149">Because they can be separated out into a class library, HTTP Modules offer a more flexible and reusable model for creating `HttpApplication` event handlers.</span></span> <span data-ttu-id="a31e2-150">而`Global.asax`文件是特定于它所在的位置的 web 应用，HTTP 模块可以编译到程序集，此时将 HTTP 模块添加到网站非常简单，只将程序集放入适当`Bin`文件夹和注册中的模块`Web.config`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-150">Whereas the `Global.asax` file is specific to the web application where it resides, HTTP Modules can be compiled into assemblies, at which point adding the HTTP Module to a website is as simple as dropping the assembly in the `Bin` folder and registering the Module in `Web.config`.</span></span> <span data-ttu-id="a31e2-151">本教程不会查找在创建和使用 HTTP 模块，但在以下两个教程中使用的两个错误日志记录库实现为 HTTP 模块。</span><span class="sxs-lookup"><span data-stu-id="a31e2-151">This tutorial does not look at creating and using HTTP Modules, but the two error logging libraries used in the following two tutorials are implemented as HTTP Modules.</span></span> <span data-ttu-id="a31e2-152">有关 HTTP 模块的优势的更多背景指[使用 HTTP 模块和处理程序以创建可插入 ASP.NET 组件](https://msdn.microsoft.com/en-us/library/aa479332.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-152">For more background on the benefits of HTTP Modules refer to [Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components](https://msdn.microsoft.com/en-us/library/aa479332.aspx).</span></span>


## <a name="retrieving-information-about-the-unhandled-exception"></a><span data-ttu-id="a31e2-153">检索有关未经处理的异常的信息</span><span class="sxs-lookup"><span data-stu-id="a31e2-153">Retrieving Information About the Unhandled Exception</span></span>

<span data-ttu-id="a31e2-154">此时我们可以具有的 Global.asax 文件`Application_Error`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a31e2-154">At this point we have a Global.asax file with an `Application_Error` event handler.</span></span> <span data-ttu-id="a31e2-155">此事件处理程序执行时我们需要通知开发人员的错误和日志其详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-155">When this event handler executes we need to notify a developer of the error and log its details.</span></span> <span data-ttu-id="a31e2-156">若要完成这些任务我们首先需要确定引发异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-156">To accomplish these tasks we first need to determine the details of the exception that was raised.</span></span> <span data-ttu-id="a31e2-157">使用服务器对象的[`GetLastError`方法](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility.getlasterror.aspx)若要检索的未经处理的异常导致的详细信息`Error`事件激发。</span><span class="sxs-lookup"><span data-stu-id="a31e2-157">Use the Server object's [`GetLastError` method](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility.getlasterror.aspx) to retrieve details of the unhandled exception that caused the `Error` event to fire.</span></span>

[!code-vb[Main](processing-unhandled-exceptions-vb/samples/sample2.vb)]

<span data-ttu-id="a31e2-158">`GetLastError`方法返回类型的对象`Exception`，这是.NET Framework 中的所有异常的基类型。</span><span class="sxs-lookup"><span data-stu-id="a31e2-158">The `GetLastError` method returns an object of type `Exception`, which is the base type for all exceptions in the .NET Framework.</span></span> <span data-ttu-id="a31e2-159">但是，在上面的代码我正在强制转换返回的异常对象`GetLastError`到`HttpException`对象。</span><span class="sxs-lookup"><span data-stu-id="a31e2-159">However, in the code above I am casting the Exception object returned by `GetLastError` into an `HttpException` object.</span></span> <span data-ttu-id="a31e2-160">如果`Error`因为抛出异常 ASP.NET 资源在处理过程然后已引发的异常包装在激发事件`HttpException`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-160">If the `Error` event is being fired because an exception was thrown during the processing of an ASP.NET resource then the exception that was thrown is wrapped within an `HttpException`.</span></span> <span data-ttu-id="a31e2-161">若要获取引发错误事件使用的实际异常`InnerException`属性。</span><span class="sxs-lookup"><span data-stu-id="a31e2-161">To get the actual exception that precipitated the Error event use the `InnerException` property.</span></span> <span data-ttu-id="a31e2-162">如果`Error`事件被引发因为基于 HTTP 的异常，如不存在页，请求`HttpException`引发，但它不具有内部异常。</span><span class="sxs-lookup"><span data-stu-id="a31e2-162">If the `Error` event was raised because of an HTTP-based exception, such as a request for a non-existent page, an `HttpException` is thrown, but it does not have an inner exception.</span></span>

<span data-ttu-id="a31e2-163">下面的代码使用`GetLastErrormessage`检索有关触发的异常信息`Error`事件，存储`HttpException`在名为`lastErrorWrapper`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-163">The following code uses the `GetLastErrormessage` to retrieve information about the exception that triggered the `Error` event, storing the `HttpException` in a variable named `lastErrorWrapper`.</span></span> <span data-ttu-id="a31e2-164">它然后将存储类型、 消息和堆栈跟踪的原始异常在三个字符串变量，检查以查看是否`lastErrorWrapper`触发实际异常`Error`事件 （对于基于 HTTP 的异常） 或是否仅在处理请求时引发的异常的包装器。</span><span class="sxs-lookup"><span data-stu-id="a31e2-164">It then stores the type, message, and stack trace of the originating exception in three string variables, checking to see if the `lastErrorWrapper` is the actual exception that triggered the `Error` event (in the case of HTTP-based exceptions) or if it's merely a wrapper for an exception that was thrown while processing the request.</span></span>

[!code-vb[Main](processing-unhandled-exceptions-vb/samples/sample3.vb)]

<span data-ttu-id="a31e2-165">此时，你具有需要编写代码将记录到数据库表的异常的详细信息的所有信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-165">At this point you have all the information you need to write code that will log the exception's details to a database table.</span></span> <span data-ttu-id="a31e2-166">为每个感兴趣的类型、 消息、 堆栈跟踪和等等的其他有用信息段，如请求的页面的 URL 和当前登录用户的名称以及错误详细信息，无法创建带有列的数据库表。</span><span class="sxs-lookup"><span data-stu-id="a31e2-166">You could create a database table with columns for each of the error details of interest - the type, the message, the stack trace, and so on - along with other useful pieces of information, such as the URL of the requested page and the name of the currently logged on user.</span></span> <span data-ttu-id="a31e2-167">在`Application_Error`事件处理程序然后将连接到数据库，并将一个记录插入表。</span><span class="sxs-lookup"><span data-stu-id="a31e2-167">In the `Application_Error` event handler you would then connect to the database and insert a record into the table.</span></span> <span data-ttu-id="a31e2-168">同样，你可以添加代码以警报通过电子邮件错误的开发人员。</span><span class="sxs-lookup"><span data-stu-id="a31e2-168">Likewise, you could add code to alert a developer of the error via e-mail.</span></span>

<span data-ttu-id="a31e2-169">检查下面的两个教程中的错误日志记录库提供在初始状态下，此类功能，因此无需自行生成此错误日志记录和通知。</span><span class="sxs-lookup"><span data-stu-id="a31e2-169">The error logging libraries examined in the next two tutorials provide such functionality out of the box, so there's no need to build this error logging and notification yourself.</span></span> <span data-ttu-id="a31e2-170">但是，为了说明这一点`Error`正在引发事件且`Application_Error`事件处理程序可以用于记录错误详细信息和通知开发人员，让我们添加发生错误时通知开发人员的代码。</span><span class="sxs-lookup"><span data-stu-id="a31e2-170">However, to illustrate that the `Error` event is being raised and that the `Application_Error` event handler can be used to log error details and notify a developer, let's add code that notifies a developer when an error occurs.</span></span>

## <a name="notifying-a-developer-when-an-unhandled-exception-occurs"></a><span data-ttu-id="a31e2-171">未经处理的异常发生时通知开发人员</span><span class="sxs-lookup"><span data-stu-id="a31e2-171">Notifying a Developer When an Unhandled Exception Occurs</span></span>

<span data-ttu-id="a31e2-172">在生产环境中发生未经处理的异常时务必警告开发团队，以便它们可以评估错误，并确定需要采取的操作。</span><span class="sxs-lookup"><span data-stu-id="a31e2-172">When an unhandled exception occurs in the production environment it is important to alert the development team so that they can assess the error and determine what actions need to be taken.</span></span> <span data-ttu-id="a31e2-173">例如，如果没有中连接到数据库，然后你将需要为双精度的错误检查连接字符串，并且可能是，打开支持票证与您的 web 托管公司。</span><span class="sxs-lookup"><span data-stu-id="a31e2-173">For example, if there is an error in connecting to the database then you'll need to double check your connection string and, perhaps, open a support ticket with your web hosting company.</span></span> <span data-ttu-id="a31e2-174">如果由于编程错误导致出现异常，可能需要其他代码或验证逻辑要添加到在将来防止此类错误。</span><span class="sxs-lookup"><span data-stu-id="a31e2-174">If the exception occurred because of a programming error, additional code or validation logic may need to be added to prevent such errors in the future.</span></span>

<span data-ttu-id="a31e2-175">.NET Framework 中的类[`System.Net.Mail`命名空间](https://msdn.microsoft.com/en-us/library/system.net.mail.aspx)方便地发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-175">The .NET Framework classes in the [`System.Net.Mail` namespace](https://msdn.microsoft.com/en-us/library/system.net.mail.aspx) make it easy to send an email.</span></span> <span data-ttu-id="a31e2-176">[ `MailMessage`类](https://msdn.microsoft.com/en-us/library/system.net.mail.mailmessage.aspx)表示电子邮件和具有属性，例如`To`， `From`， `Subject`， `Body`，和`Attachments`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-176">The [`MailMessage` class](https://msdn.microsoft.com/en-us/library/system.net.mail.mailmessage.aspx) represents an e-mail message and has properties like `To`, `From`, `Subject`, `Body`, and `Attachments`.</span></span> <span data-ttu-id="a31e2-177">`SmtpClass`用于发送`MailMessage`对象使用指定的 SMTP 服务器; 可以以编程方式或以声明方式在指定的 SMTP 服务器设置[`<system.net>`元素](https://msdn.microsoft.com/en-us/library/6484zdc1.aspx)中`Web.config file`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-177">The `SmtpClass` is used to send a `MailMessage` object using a specified SMTP server; the SMTP server settings can be specified programmatically or declaratively in the [`<system.net>` element](https://msdn.microsoft.com/en-us/library/6484zdc1.aspx) in the `Web.config file`.</span></span> <span data-ttu-id="a31e2-178">有关详细信息将电子邮件发送 ASP.NET 应用程序中的消息签出我文章[在 ASP.NET 中发送电子邮件](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)，和[System.Net.Mail 常见问题](http://systemnetmail.com/)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-178">For more information on sending e-mail messages in an ASP.NET application check out my article, [Sending Email in ASP.NET](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx), and the [System.Net.Mail FAQ](http://systemnetmail.com/).</span></span>

> [!NOTE]
> <span data-ttu-id="a31e2-179">`<system.net>`元素包含使用的 SMTP 服务器设置`SmtpClient`类发送一封电子邮件时。</span><span class="sxs-lookup"><span data-stu-id="a31e2-179">The `<system.net>` element contains the SMTP server settings used by the `SmtpClient` class when sending an e-mail.</span></span> <span data-ttu-id="a31e2-180">您的 web 托管公司可能具有可用于从应用程序发送电子邮件的 SMTP 服务器。</span><span class="sxs-lookup"><span data-stu-id="a31e2-180">Your web hosting company likely has an SMTP server that you can use to send e-mail from your application.</span></span> <span data-ttu-id="a31e2-181">有关应在 web 应用程序中使用的 SMTP 服务器设置的信息，请查阅你的 web 主机支持部分。</span><span class="sxs-lookup"><span data-stu-id="a31e2-181">Consult your web host's support section for information on the SMTP server settings you should use in your web application.</span></span>


<span data-ttu-id="a31e2-182">以下代码添加到`Application_Error`事件处理程序来发送电子邮件开发人员时发生错误：</span><span class="sxs-lookup"><span data-stu-id="a31e2-182">Add the following code to the `Application_Error` event handler to send a developer an e-mail when an error occurs:</span></span>

[!code-vb[Main](processing-unhandled-exceptions-vb/samples/sample4.vb)]

<span data-ttu-id="a31e2-183">上面的代码非常长时，它的大容量在发送给开发人员的电子邮件中创建显示的 HTML。</span><span class="sxs-lookup"><span data-stu-id="a31e2-183">While the above code is quite lengthy, the bulk of it creates the HTML that appears in the e-mail sent to the developer.</span></span> <span data-ttu-id="a31e2-184">代码通过引用将启动`HttpException`返回`GetLastError`方法 (`lastErrorWrapper`)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-184">The code starts by referencing the `HttpException` returned by the `GetLastError` method (`lastErrorWrapper`).</span></span> <span data-ttu-id="a31e2-185">通过检索实际引发的请求的异常`lastErrorWrapper.InnerException`并分配给变量`lastError`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-185">The actual exception that was raised by the request is retrieved via `lastErrorWrapper.InnerException` and is assigned to the variable `lastError`.</span></span> <span data-ttu-id="a31e2-186">类型、 消息和堆栈跟踪信息检索从`lastError`并存储在三个字符串变量。</span><span class="sxs-lookup"><span data-stu-id="a31e2-186">The type, message, and stack trace information is retrieved from `lastError` and stored in three string variables.</span></span>

<span data-ttu-id="a31e2-187">接下来，`MailMessage`对象名为`mm`创建。</span><span class="sxs-lookup"><span data-stu-id="a31e2-187">Next, a `MailMessage` object named `mm` is created.</span></span> <span data-ttu-id="a31e2-188">电子邮件正文是 HTML 格式，并显示所请求的页面的 URL、 当前登录的用户，以及有关异常 （类型、 消息和堆栈跟踪） 的信息的名称。</span><span class="sxs-lookup"><span data-stu-id="a31e2-188">The e-mail body is HTML formatted and displays the URL of the requested page, the name of the currently logged on user, and information about the exception (the type, message, and stack trace).</span></span> <span data-ttu-id="a31e2-189">有关的冷项目之一`HttpException`类是你可以生成用于创建异常详细信息黄色屏幕的死亡 (YSOD) 通过调用的 HTML [GetHtmlErrorMessage 方法](https://msdn.microsoft.com/en-us/library/system.web.httpexception.gethtmlerrormessage.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-189">One of the cool things about the `HttpException` class is that you can generate the HTML used to create the Exception Details Yellow Screen of Death (YSOD) by calling the [GetHtmlErrorMessage method](https://msdn.microsoft.com/en-us/library/system.web.httpexception.gethtmlerrormessage.aspx).</span></span> <span data-ttu-id="a31e2-190">此处使用此方法检索的异常详细信息 YSOD 标记并将其添加到作为附件的电子邮件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-190">This method is used here to retrieve the Exception Details YSOD markup and add it to the email as an attachment.</span></span> <span data-ttu-id="a31e2-191">需要注意的一个字： 如果异常，触发`Error`事件已基于 HTTP 的异常 （如不存在页的请求） 则`GetHtmlErrorMessage`方法将返回`null`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-191">One word of caution: if the exception that triggered the `Error` event was an HTTP-based exception (such as a request for a non-existent page) then the `GetHtmlErrorMessage` method will return `null`.</span></span>

<span data-ttu-id="a31e2-192">最后一步是将发送`MailMessage`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-192">The final step is to send the `MailMessage`.</span></span> <span data-ttu-id="a31e2-193">这可通过创建一个新`SmtpClient`方法并调用其`Send`方法。</span><span class="sxs-lookup"><span data-stu-id="a31e2-193">This is done by creating a new `SmtpClient` method and calling its `Send` method.</span></span>

> [!NOTE]
> <span data-ttu-id="a31e2-194">Web 应用程序中使用此代码之前你将需要更改中的值`ToAddress`和`FromAddress`常量从support@example.com错误通知电子邮件应发送到和来自到任何电子邮件地址。</span><span class="sxs-lookup"><span data-stu-id="a31e2-194">Before using this code in your web application you'll want to change the values in the `ToAddress` and `FromAddress` constants from support@example.com to whatever e-mail address the error notification e-mail should be sent to and originate from.</span></span> <span data-ttu-id="a31e2-195">你还需要指定 SMTP 服务器设置中的`<system.net>`主题中`Web.config`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-195">You'll also need to specify SMTP server settings in the `<system.net>` section in `Web.config`.</span></span> <span data-ttu-id="a31e2-196">请查阅你的 web 主机提供商，以确定要使用的 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="a31e2-196">Consult your web host provider to determine the SMTP server settings to use.</span></span>


<span data-ttu-id="a31e2-197">对于就地此代码时出现错误的任何时候开发人员将发送电子邮件对错误进行概述，包括 YSOD。</span><span class="sxs-lookup"><span data-stu-id="a31e2-197">With this code in place anytime there's an error the developer is sent an e-mail message that summarizes the error and includes the YSOD.</span></span> <span data-ttu-id="a31e2-198">我们可以在前面的教程来演示通过访问 Genre.aspx，传递中无效的运行时错误`ID`值通过查询字符串，如`Genre.aspx?ID=foo`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-198">In the preceding tutorial we demonstrated a runtime error by visiting Genre.aspx and passing in an invalid `ID` value through the querystring, like `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="a31e2-199">访问的页`Global.asax`就地文件生成相同的用户体验与在前面的教程-在开发环境中你将继续时在生产环境中你将看到异常详细信息黄色死机，请参阅自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-199">Visiting the page with the `Global.asax` file in place produces the same user experience as in the preceding tutorial - in the development environment you'll continue to see the Exception Details Yellow Screen of Death, while in the production environment you'll see the custom error page.</span></span> <span data-ttu-id="a31e2-200">除了此现有的行为，开发人员发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-200">In addition to this existing behavior, the developer is sent an e-mail.</span></span>

<span data-ttu-id="a31e2-201">**图 2**显示访问时收到的电子邮件`Genre.aspx?ID=foo`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-201">**Figure 2** shows the e-mail received when visiting `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="a31e2-202">电子邮件正文总结了异常的信息，而`YSOD.htm`附件，显示异常详细信息 YSOD 所示的内容 (请参阅**图 3**)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-202">The e-mail body summarizes the exception information, while the `YSOD.htm` attachment displays the content that is shown in the Exception Details YSOD (see **Figure 3**).</span></span>

[![](processing-unhandled-exceptions-vb/_static/image5.png)](processing-unhandled-exceptions-vb/_static/image4.png)

<span data-ttu-id="a31e2-203">**图 2**： 开发人员在未处理的异常时发送电子邮件通知</span><span class="sxs-lookup"><span data-stu-id="a31e2-203">**Figure 2**: The Developer Is Sent An E-Mail Notification Whenever There's An Unhandled Exception</span></span>  
 <span data-ttu-id="a31e2-204">([单击以查看实际尺寸的图像](processing-unhandled-exceptions-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="a31e2-204">([Click to view full-size image](processing-unhandled-exceptions-vb/_static/image6.png))</span></span>

[![](processing-unhandled-exceptions-vb/_static/image8.png)](processing-unhandled-exceptions-vb/_static/image7.png)

<span data-ttu-id="a31e2-205">**图 3**： 电子邮件通知中包括异常详细信息作为附件 YSOD</span><span class="sxs-lookup"><span data-stu-id="a31e2-205">**Figure 3**: The E-Mail Notification Includes the Exception Details YSOD As An Attachment</span></span>  
 <span data-ttu-id="a31e2-206">([单击以查看实际尺寸的图像](processing-unhandled-exceptions-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="a31e2-206">([Click to view full-size image](processing-unhandled-exceptions-vb/_static/image9.png))</span></span>

## <a name="what-about-using-the-custom-error-page"></a><span data-ttu-id="a31e2-207">怎样使用自定义错误页？</span><span class="sxs-lookup"><span data-stu-id="a31e2-207">What About Using the Custom Error Page?</span></span>

<span data-ttu-id="a31e2-208">本教程说明了如何使用`Global.asax`和`Application_Error`事件处理程序代码发生时要执行未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="a31e2-208">This tutorial showed how to use `Global.asax` and the `Application_Error` event handler to execute code when an unhandled exception occurs.</span></span> <span data-ttu-id="a31e2-209">具体而言，我们使用此事件处理程序以通知的错误; 开发人员我们无法扩展它还在数据库中记录错误详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-209">Specifically, we used this event handler to notify a developer of an error; we could extend it to also log the error details in a database.</span></span> <span data-ttu-id="a31e2-210">是否存在`Application_Error`事件处理程序不会影响最终用户体验。</span><span class="sxs-lookup"><span data-stu-id="a31e2-210">The presence of the `Application_Error` event handler does not affect the end user's experience.</span></span> <span data-ttu-id="a31e2-211">他们仍将看到配置的错误页面，错误详细信息 YSOD、 运行时错误 YSOD，或自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-211">They still see the configured error page, be it the Error Details YSOD, the Runtime Error YSOD, or the custom error page.</span></span>

<span data-ttu-id="a31e2-212">自然想知道是否`Global.asax`文件和`Application_Error`事件时是必需的使用自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-212">It's natural to wonder whether the `Global.asax` file and `Application_Error` event is necessary when using a custom error page.</span></span> <span data-ttu-id="a31e2-213">出现错误时向用户显示自定义错误页因此为什么无法我们将代码以通知开发人员并登录到自定义错误页的代码隐藏类的错误详细信息？</span><span class="sxs-lookup"><span data-stu-id="a31e2-213">When an error occurs the user is shown the custom error page so why can't we put the code to notify the developer and log the error details into the code-behind class of the custom error page?</span></span> <span data-ttu-id="a31e2-214">当然，你可以将代码添加到自定义错误页的代码隐藏类时没有触发异常的详细信息的访问`Error`事件时使用我们探讨了前面教程中的技术。</span><span class="sxs-lookup"><span data-stu-id="a31e2-214">While you can certainly add code to the custom error page's code-behind class you do not have access to the details of the exception that triggered the `Error` event when using the technique we explored in the preceding tutorial.</span></span> <span data-ttu-id="a31e2-215">调用`GetLastError`从自定义错误页的方法返回`Nothing`。</span><span class="sxs-lookup"><span data-stu-id="a31e2-215">Calling the `GetLastError` method from the custom error page returns `Nothing`.</span></span>

<span data-ttu-id="a31e2-216">此行为的原因是因为自定义错误页达到通过重定向。</span><span class="sxs-lookup"><span data-stu-id="a31e2-216">The reason for this behavior is because the custom error page is reached via a redirect.</span></span> <span data-ttu-id="a31e2-217">在未经处理的异常到达 ASP.NET 运行时 ASP.NET 引擎引发其`Error`事件 (其中执行`Application_Error`事件处理程序)，然后*将重定向*对自定义错误页通过发出用户`Response.Redirect(customErrorPageUrl)`.</span><span class="sxs-lookup"><span data-stu-id="a31e2-217">When an unhandled exception reaches the ASP.NET runtime the ASP.NET engine raises its `Error` event (which executes the `Application_Error` event handler) and then *redirects* the user to the custom error page by issuing a `Response.Redirect(customErrorPageUrl)`.</span></span> <span data-ttu-id="a31e2-218">`Response.Redirect`方法可发送到客户端，HTTP 302 状态代码，指示要请求新的 URL，即自定义错误页的浏览器的响应。</span><span class="sxs-lookup"><span data-stu-id="a31e2-218">The `Response.Redirect` method sends a response to the client with an HTTP 302 status code, instructing the browser to request a new URL, namely the custom error page.</span></span> <span data-ttu-id="a31e2-219">然后浏览器会自动请求此新页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-219">The browser then automatically requests this new page.</span></span> <span data-ttu-id="a31e2-220">你可以判断，从页面中自定义错误页单独请求错误源于何处因为浏览器的地址栏中更改为自定义错误页的 URL (请参阅**图 4**)。</span><span class="sxs-lookup"><span data-stu-id="a31e2-220">You can tell that the custom error page was requested separately from the page where the error originated because the browser's Address bar changes to the custom error page URL (see **Figure 4**).</span></span>

[![](processing-unhandled-exceptions-vb/_static/image11.png)](processing-unhandled-exceptions-vb/_static/image10.png)

<span data-ttu-id="a31e2-221">**图 4**： 发生错误时浏览器将重定向到自定义错误页的 URL</span><span class="sxs-lookup"><span data-stu-id="a31e2-221">**Figure 4**: When an Error Occurs the Browser Gets Redirected to the Custom Error Page URL</span></span>  
 <span data-ttu-id="a31e2-222">([单击以查看实际尺寸的图像](processing-unhandled-exceptions-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="a31e2-222">([Click to view full-size image](processing-unhandled-exceptions-vb/_static/image12.png))</span></span>

<span data-ttu-id="a31e2-223">净效果是未经处理的异常发生在请求结束时服务器的响应使用 HTTP 302 重定向。</span><span class="sxs-lookup"><span data-stu-id="a31e2-223">The net effect is that the request where the unhandled exception occurred ends when the server responds with the HTTP 302 redirect.</span></span> <span data-ttu-id="a31e2-224">对自定义错误页的后续请求是一个全新的请求;此时 ASP.NET 引擎已丢弃的错误信息，此外，就无法将上一个请求中未处理的异常与新的自定义错误页请求相关联。</span><span class="sxs-lookup"><span data-stu-id="a31e2-224">The subsequent request to the custom error page is a brand new request; by this point the ASP.NET engine has discarded the error information and, moreover, has no way to associate the unhandled exception in the previous request with the new request for the custom error page.</span></span> <span data-ttu-id="a31e2-225">正因如此`GetLastError`返回`null`从自定义错误页中调用时。</span><span class="sxs-lookup"><span data-stu-id="a31e2-225">This is why `GetLastError` returns `null` when called from the custom error page.</span></span>

<span data-ttu-id="a31e2-226">但是，很可能能够在同一导致错误的请求期间执行自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-226">However, it is possible to have the custom error page executed during the same request that caused the error.</span></span> <span data-ttu-id="a31e2-227">[ `Server.Transfer(url)` ](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility.transfer.aspx)方法将执行传送到指定的 URL，并在同一请求对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="a31e2-227">The [`Server.Transfer(url)`](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility.transfer.aspx) method transfers execution to the specified URL and processes it within the same request.</span></span> <span data-ttu-id="a31e2-228">无法将代码移动`Application_Error`到自定义错误页的代码隐藏类，替换中的事件处理程序`Global.asax`替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="a31e2-228">You could move the code in the `Application_Error` event handler to the custom error page's code-behind class, replacing it in `Global.asax` with the following code:</span></span>

[!code-vb[Main](processing-unhandled-exceptions-vb/samples/sample5.vb)]

<span data-ttu-id="a31e2-229">未经处理的异常发生时现在`Application_Error`事件处理程序将控制权转交给根据 HTTP 状态代码的相应的自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-229">Now when an unhandled exception occurs the `Application_Error` event handler transfers control to the appropriate custom error page based on the HTTP status code.</span></span> <span data-ttu-id="a31e2-230">自定义错误页由于传送控件，有权访问通过未经处理的异常信息`Server.GetLastError`和可以通知开发人员的错误和日志其详细信息。</span><span class="sxs-lookup"><span data-stu-id="a31e2-230">Because control was transferred, the custom error page has access to the unhandled exception information via `Server.GetLastError` and can notify a developer of the error and log its details.</span></span> <span data-ttu-id="a31e2-231">`Server.Transfer`调用停止中将用户重定向到自定义错误页的 ASP.NET 引擎。</span><span class="sxs-lookup"><span data-stu-id="a31e2-231">The `Server.Transfer` call stops the ASP.NET engine from redirecting the user to the custom error page.</span></span> <span data-ttu-id="a31e2-232">相反，作为对生成错误的页的响应返回自定义错误页的内容。</span><span class="sxs-lookup"><span data-stu-id="a31e2-232">Instead, the custom error page's content is returned as the response to the page that generated the error.</span></span>

## <a name="summary"></a><span data-ttu-id="a31e2-233">摘要</span><span class="sxs-lookup"><span data-stu-id="a31e2-233">Summary</span></span>

<span data-ttu-id="a31e2-234">ASP.NET 运行时在 ASP.NET web 应用程序中发生未经处理的异常时引发`Error`事件，并显示配置的错误页。</span><span class="sxs-lookup"><span data-stu-id="a31e2-234">When an unhandled exception occurs in an ASP.NET web application the ASP.NET runtime raises the `Error` event and displays the configured error page.</span></span> <span data-ttu-id="a31e2-235">我们可以通知开发人员的错误，记录其详细信息，或者处理其以某种其他方式，通过创建的事件处理程序错误事件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-235">We can notify the developer of the error, log its details, or process it in some other fashion, by creating an event handler for the Error event.</span></span> <span data-ttu-id="a31e2-236">有两种方法创建的事件处理程序`HttpApplication`事件，如`Error`： 在`Global.asax`文件或从 HTTP 模块。</span><span class="sxs-lookup"><span data-stu-id="a31e2-236">There are two ways to create an event handler for `HttpApplication` events like `Error`: in the `Global.asax` file or from an HTTP Module.</span></span> <span data-ttu-id="a31e2-237">本教程介绍了如何创建`Error`中的事件处理程序`Global.asax`通过电子邮件通知的错误的开发人员的文件。</span><span class="sxs-lookup"><span data-stu-id="a31e2-237">This tutorial showed how to create an `Error` event handler in the `Global.asax` file that notifies developers of an error by means of an e-mail message.</span></span>

<span data-ttu-id="a31e2-238">创建`Error`事件处理程序是你需要以某种唯一或自定义方式处理未经处理的异常的情况下很有用。</span><span class="sxs-lookup"><span data-stu-id="a31e2-238">Creating an `Error` event handler is useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="a31e2-239">但是，创建你自己`Error`事件处理程序将异常记录或通知开发人员不最有效的时间使用，因为已存在可以在几分钟内中的设置的可用且易于使用的错误日志记录库。</span><span class="sxs-lookup"><span data-stu-id="a31e2-239">However, creating your own `Error` event handler to log the exception or to notify a developer is not the most efficient use of your time as there already exist free and easy to use error logging libraries that can be setup in a matter of minutes.</span></span> <span data-ttu-id="a31e2-240">下面的两个教程检查两个这种库。</span><span class="sxs-lookup"><span data-stu-id="a31e2-240">The next two tutorials examine two such libraries.</span></span>

<span data-ttu-id="a31e2-241">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="a31e2-241">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="a31e2-242">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="a31e2-242">Further Reading</span></span>

<span data-ttu-id="a31e2-243">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="a31e2-243">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="a31e2-244">ASP.NET HTTP 模块和 HTTP 处理程序概述</span><span class="sxs-lookup"><span data-stu-id="a31e2-244">ASP.NET HTTP Modules and HTTP Handlers Overview</span></span>](https://support.microsoft.com/kb/307985)
- [<span data-ttu-id="a31e2-245">正常响应未经处理的异常的处理未经处理的异常</span><span class="sxs-lookup"><span data-stu-id="a31e2-245">Gracefully Responding to Unhandled Exceptions - Processing Unhandled Exceptions</span></span>](http://aspnet.4guysfromrolla.com/articles/091306-1.aspx)
- [<span data-ttu-id="a31e2-246">`HttpApplication`类和 ASP.NET 应用程序对象</span><span class="sxs-lookup"><span data-stu-id="a31e2-246">`HttpApplication` Class and the ASP.NET Application Object</span></span>](http://www.eggheadcafe.com/articles/20030211.asp)
- [<span data-ttu-id="a31e2-247">HTTP 处理程序和 ASP.NET 中的 HTTP 模块</span><span class="sxs-lookup"><span data-stu-id="a31e2-247">HTTP Handlers and HTTP Modules in ASP.NET</span></span>](http://www.15seconds.com/Issue/020417.htm)
- [<span data-ttu-id="a31e2-248">在 ASP.NET 中发送电子邮件</span><span class="sxs-lookup"><span data-stu-id="a31e2-248">Sending Email in ASP.NET</span></span>](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)
- [<span data-ttu-id="a31e2-249">了解`Global.asax`文件</span><span class="sxs-lookup"><span data-stu-id="a31e2-249">Understanding the `Global.asax` File</span></span>](http://aspalliance.com/1114_Understanding_the_Globalasax_file.all)
- [<span data-ttu-id="a31e2-250">使用 HTTP 模块和处理程序创建可插入 ASP.NET 组件</span><span class="sxs-lookup"><span data-stu-id="a31e2-250">Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components</span></span>](https://msdn.microsoft.com/en-us/library/aa479332.aspx)
- [<span data-ttu-id="a31e2-251">使用 ASP.NET`Global.asax`文件</span><span class="sxs-lookup"><span data-stu-id="a31e2-251">Working with the ASP.NET `Global.asax` File</span></span>](http://articles.techrepublic.com.com/5100-10878_11-5771721.html)
- [<span data-ttu-id="a31e2-252">使用`HttpApplication`实例</span><span class="sxs-lookup"><span data-stu-id="a31e2-252">Working with `HttpApplication` Instances</span></span>](https://msdn.microsoft.com/en-us/library/a0xez8f2.aspx)

>[!div class="step-by-step"]
<span data-ttu-id="a31e2-253">[上一页](displaying-a-custom-error-page-vb.md)
[下一页](logging-error-details-with-asp-net-health-monitoring-vb.md)</span><span class="sxs-lookup"><span data-stu-id="a31e2-253">[Previous](displaying-a-custom-error-page-vb.md)
[Next](logging-error-details-with-asp-net-health-monitoring-vb.md)</span></span>
